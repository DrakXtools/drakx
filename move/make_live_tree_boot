#!/usr/bin/perl

use lib qw(../perl-install);
use common;
use lang;
use Getopt::Long;

GetOptions(u => \ (my $un_build)) or die '';

my $prefix = $ARGV[0] || `make get_dest_livetree`;


sub create_light_tree {
    my ($livetree_prefix, $live_name, $list) = @_;
    my $light_prefix = $prefix . '_' . $live_name;

    -e $light_prefix and die "you can't make_live_tree_boot since one already exists
Maybe you should remove it first with 'make_live_tree_boot -u'\n";

    foreach my $f (@$list) {
	my $dest = "$light_prefix$f";
	my $orig = "$livetree_prefix$f";

	mkdir_p(dirname($dest));

	if (-l $orig) {
	    symlink readlink($orig), $dest;
	} else {
	    my $link = $orig;
	    $link =~ s|^$livetree_prefix|/image_$live_name|;

	    rename $orig, $dest or die "moving $orig to $dest failed: $!\n";
	    symlink $link, $orig or die "symlinking from $dest to $orig failed: $!\n";
	}
    }
}

sub create_totem_links {
    my ($live_name, $list) = @_;
    my $light_prefix = $prefix . '_' . $live_name;

    #- creating all the dirs, even when things are in the "always" tree
    foreach my $f (@$list) {
	my $dest = "$light_prefix$f";
	my $orig = "$prefix$f";
	mkdir_p(dirname($dest)) if ! (-e $dest || -l $dest);

	if (-l $orig) {
	    symlink readlink($orig), $dest;
	}
    }

    foreach my $dir (chomp_(`cd $light_prefix ; find usr -type d`)) {
	foreach my $f (all("$prefix/$dir")) {
	    my $link;
	    my $fl = $f;
	    while (my $l = readlink("$prefix/$dir/$fl")) {
		if ($l =~ /^\w/) {
		    $fl = $l;
		    next;
		} elsif ($l =~ m!^/!) {
		    $link = $l;
		}
		last;
	    }
	    $link ||= "/image/$dir/$fl";
	    symlink $link, "$light_prefix/$dir/$f";
	}
    }
}

sub remove_light_tree {
    my ($live_name, $list) = @_;
    my $light_prefix = $prefix . '_' . $live_name;

    -d $light_prefix or return;

    foreach my $f (@$list) {
	my $dest = "$prefix$f";
	my $orig = "$light_prefix$f";

	if (-l $orig) {
	    unlink $orig;
	} elsif (-e $orig) {
	    if (-e $dest && -s $dest != -s $orig) {
		warn "ERROR: $dest already exist, skipping\n";
	    } elsif (!-d $dest || -l $dest) {
		unlink $dest or die "removing $dest failed: $!\n";
		rename $orig, $dest or die "moving $orig to $dest failed: $!\n";
	    }
	}
    }
    rmdir($_) foreach reverse(chomp_(`find $light_prefix -type d`));

    if (-e $light_prefix) {
	unlink($_) foreach chomp_(`find $light_prefix -type l`);

	foreach my $orig (chomp_(`find $light_prefix -type f`)) {
	    my $dest = $orig;
	    $dest =~ s|^$light_prefix|$prefix|;
	    if (my $orig2 = readlink($dest)) {
		$orig2 =~ s!/image_$live_name/!$light_prefix/! or next;
		$orig2 eq $orig or next;
	    } else {
		next if -e $dest && -s $dest != -s $orig;
	    }
	    unlink $dest or die "removing $dest failed: $!\n";
	    rename $orig, $dest or die "moving $orig to $dest failed: $!\n";
	}
	system("rm -rf $light_prefix/usr/bin/stage2/*.pm");
	system("rm -rf $light_prefix/usr/lib/libDrakX/*.pm");
	system("rm -rf $light_prefix/usr/share/langs/*.png");

	rmdir($_) foreach reverse(chomp_(`find $light_prefix -type d`));
    }

    if (-e $light_prefix) {
	print "still there:\n";
	system('find', $light_prefix);
    }
}
my @i18n = map { if_(/i18n_(.*)\.list$/, $1) } all('data');
my @clps = ('always', 'boot', 'totem', 'nvidia', map { "i18n_$_" } @i18n);

my %lists = map {
    $_ => [ chomp_(cat_("data/$_.list")) ];
} @clps, 'always_i18n';

$lists{always_simpl} = [ uniq(@{$lists{always}}, intersection($lists{boot}, $lists{totem})) ];
$lists{boot_simpl} = [ difference2($lists{boot}, $lists{always_simpl}) ];
$lists{totem_simpl} = [ difference2($lists{totem}, $lists{always_simpl}) ];

foreach (@clps, map { "always_i18n_$_" } @i18n) {
    remove_light_tree($_, $lists{$_ . '_simpl'} || $lists{$_} || []);
}

if (!$un_build) {
    foreach my $i18n (@i18n) {
	$lists{"always_i18n_$i18n"} = [ map {
	    my $s = $_;
	    $s =~ s/__LANG__/$i18n*/;
	    if (my ($f) = glob("$prefix$s")) {
		if (readlink($f) =~ m!^[^/]!) {
		    system('cp', $f, "$f-");
		    rename "$f-", $f;
		}
		$f =~ s/\Q$prefix// or die "<$f> should contain $prefix\n";
		$f;
	    } else {
		();
	    }
	} @{$lists{always_i18n}} ];
    }

    foreach my $i18n (@i18n) {
	create_light_tree($prefix, "always_i18n_$i18n", $lists{"always_i18n_$i18n"});
    }
    foreach (@clps) {
	my $list = $lists{$_ . '_simpl'} || $lists{$_};
	next if $_ eq 'nvidia' && ! -e $list->[0];
	create_light_tree($prefix, $_, $list);
    }
    create_totem_links('totem', $lists{totem});
}
