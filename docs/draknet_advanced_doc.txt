This document details the entry points you can call without the DrakX graohical
toolkit. First, the general variables you will encounter further. If you don't
know wht a variable is, look here. Any additional locally variables are
commented 'in place'

------------------------------
Special types (in upper cases)
------------------------------
 DB_FILE : file storing the ISDN ISP database. see share/isdndb.txt : file of lines in 'Unlisted - edit manually' or /^(.*)\|(.*)\|(.*)=>([0-9]*)=>(.*)=>(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})=>(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$/ where $1=Land $2=City $3=ISP_name $4=phone_number $5=hostname $6=dns1 $7=dns2

---------------------------------------------------------------------------------------
Summary of common variables used (local variables are described in the function itself)
---------------------------------------------------------------------------------------
notation : keys : description : type : format (regexp or enumeration. `...' means it's not exhaustive
 $prefix : prefix path (empty in post-install) : string : path
 $isLaptop : flag for laptop : boolean or int : guess
 $isdn : hash table containing isdn infos
  $isdn->{login} : cnx login : string
  $isdn->{passwd} : cnx passwd : string
  $isdn->{phone_in} : user phone : /^[0-9]*$/
  $isdn->{phone_out} : ISP phone : /^[0-9]*$/
  $isdn->{dialing_mode} : dialing mode : "auto" or "manual"
  $isdn->{driver} : driver used for the card : "hisax" or "b1pci" or ...
  $isdn->{type} : type of card, used for the driver, see netconnect_consts : integer : /^[1-22]|[24-37]$/
  $isdn->{irq} : irq of the ISA card : integer |
  $isdn->{mem} : mem of the ISA card : string  |
  $isdn->{io} : io of the ISA card : string    | see netconnect_consts for examples.
  $isdn->{io0} : io0 of the ISA card : string  |
  $isdn->{io1} : i01 of the ISA card : string  |
  $isdn->{idl} : amount of time after the cnx times out in secs : int
  $isdn->{user_name} : not used anymore. Not explicit. It represented the name of the connexion.
  $isdn->{card_type} : card type : string : "isa" or "pci" or "pcmcia"
  $isdn->{protocol} : cnx protocol : int : 1|2|3 : 1 for old german specific (not used anymore), 2 for europe, 3 for rest of the world
  $isdn->{id} : card id. Associated with vendor, identify strictly the card. see pcitable : integer
  $isdn->{description} : card description from pcitable : string
  $isdn->{vendor} : card vendor : integer
  $isdn->{passwd2} : passwd verification : string
 $modem : hash table containing modem infos
  $modem->{device} : device of the modem : string : /ttyS[0-9]/
 $adsl : hash table containing modem infos
  $adsl->{login} : cnx login : string
  $adsl->{passwd} : cnx passwd : string
  $adsl->{atboot} : 
 $netc : hash table containing system-wide networking infos (maybe not true, correct this) : 
  $netc->{NET_DEVICE}
  $netc->{dnsServer2}
  $netc->{dnsServer3}
  $netc->{DOMAINNAME2}
  $netc->{NET_INTERFACE} is set to "ppp0"
 $in : interactive object

------------
Entry points
------------

isdn_write_config_backend : write isdn info, only for ippp0 -> ask_connect_now
input :
 $prefix
 $isdn
$isdn input:
 $isdn->{login} $isdn->{passwd} $isdn->{phone_in} $isdn->{phone_out} $isdn->{dialing_mode}
 $isdn->{driver} $isdn->{type} $isdn->{irq} $isdn->{mem} $isdn->{io} $isdn->{io0} $isdn->{io1}

write_secret_backend : write login and passwd into /etc/ppp/{chap, pap}-secrets. Replace old passwd only if same login
input :
 $a : login : string : /^.*$/
 $b : passwd : string : /^.*$/

connect_backend : launch the cnx script
input : $prefix

connect_backend : launch the cnx script
input : $prefix

read_providers_backend : build the tree of isdn ISP
input :
 $file : 1st location of the file : ISDN_DB_FILE
 $file2 : 2nd location of the file : ISDN_DB_FILE
output : the list of ISP : array of strings : array of /^(.*)\|(.*)\|(.*)$/ where $1=Land $2=City $3=ISP_name

get_info_isdn_backend : fills the infos from the line of the tree returned into $isdn and $netc
input :
 $isdn
 $netc
 $name : the line choosen in the tree of ISP : string : /^(.*)\|(.*)\|(.*)$/ with $1=Land $2=City $3=ISP_name
 $file : 1st location of the file : ISDN_DB_FILE
 $file2 : 2nd location of the file : ISDN_DB_FILE
$isdn ouput
 $isdn->{user_name}, $isdn->{phone_out}, $netc->{DOMAINNAME2}, $netc->{dnsServer2}, $netc->{dnsServer3},
$netc output
 $netc->{DOMAINNAME2}, $netc->{dnsServer2}, $netc->{dnsServer3}

isdn_detect_backend : detects isdn pci card and fills the infos in $isdn : only detects one card
input
 $isdn
$isdn output:
 $isdn->{description} $isdn->{vendor} $isdn->{id} $isdn->{driver} $isdn->{card_type} $isdn->{type}

isdn_get_list : return isdn cards descriptions list. This function is not use internally.
output : descriptions : list of strings

isdn_get_info : return isdn card infos. This function is not use internally.
input : the description of the card (see isdn_get_list)
output : a reference on the decription of the card. : ref on a hash(description,type,irq,mem,io,io0,io1card,)

conf_network_card_backend : configure the network cards and return the list of them, or configure one specified interface : WARNING, you have to setup the ethernet cards, by calling setup_thiskind($in, 'net', !$::expert, 1) or setup_thiskind_backend before calling this function. Basically, you call this function in 2 times.
input
 $prefix
 $netc
 $intf
 $type : type of interface, must be given if $interface is : string : "static" or "dhcp"
 $interface : facultative, if given, set this interface and return it in a proper form. If not, return @all_cards
 $ipadr : facultative, ip address of the interface : string
 $netadr : facultative, netaddress of the interface : string
when $interface is given, informations are written in $intf and $netc. If not, @all_cards is returned.
$intf output: $device is the result of
 $intf->{$device}->{DEVICE} : which device is concerned : $device is the result of $interface =~ /(eth[0-9]+)/; my $device = $1;;
 $intf->{$device}->{BOOTPROTO} : $type
 $intf->{$device}->{NETMASK} : '255.255.255.0'
 $intf->{$device}->{NETWORK} : $netadr
 $intf->{$device}->{ONBOOT} : "yes"
$netc output:
 $netc->{nb_cards} : nb of ethernet cards
 $netc->{NET_DEVICE} : this is used to indicate that this eth card is used to connect to internet : $device
output:
 $all_cards : a list of a list ( (eth1, module1), ... , (ethn, modulen)). Pass the ethx as $interface in further call.
 $device : only returned in case $interface was given it's $interface, but filtered by /eth[0-9+]/ : string : /eth[0-9+]/

adsl_conf_backend : write adsl configuration
input :
 $prefix
 $adsl
 $netc
 $adsl_type : type of cnx : string : "pptp" or "pppoe"
$adsl input:
 $adsl->{login}, $adsl->{passwd}, $adsl->{atboot}
$netc input:
 $netc->{NET_DEVICE}
 $netc->{dnsServer2}
 $netc->{dnsServer3}
 $netc->{DOMAINNAME2}
$netc output:
 $netc->{NET_INTERFACE} is set to "ppp0"

modem_detect_backend : detects modem on serial ports and fills the infos in $modem : detects only one card
input
 $modem
 $mouse : facultative, hash containing device to exclude not to test mouse port : ( device => /ttyS[0-9]/ )
output:
 $modem->{device} : device where the modem were detected

get_net_device : return the device choosen for the net cnx
no input
output : name of the internet device.

read_net_conf : read the information stored in $prefix/etc/sysconfig/draknet and $prefix/etc/sysconfig/draknet.`type`
input:
 $prefix
 $netcnx
 $netc

set_net_conf : set the information from netcnx in $prefix/etc/sysconfig/draknet and $prefix/etc/sysconfig/draknet.`type`
 $prefix
 $netcnx
 $netc : useless! REMOVE ME
