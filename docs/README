Well here is a little description of what DrakX needs to work in comparison
to the standard newt install.

********************************************************************************
* CVS **************************************************************************
********************************************************************************
Like all good free software, DrakX is in CVS :)

You can access it at http://www.linux-mandrake.com/cgi-bin/cvsweb.cgi/gi

or via

export CVS_RSH=ssh
export CVSROOT=:ext:anoncvs@cvs.mandrakesoft.com:/cooker
cvs checkout gi
 (enter password 'cvs')


This is only read-only access. If you want more, tell me (pixel@mandrakesoft.com)

Alas, all is not in CVS as a lot of things are binary files.
For the other things, take cooker-contrib others/src/gi.tar.bz2

Please note that redoing *all* the stuff is not for the faint of heart. I myself
sometimes wonder what the whole make does :-%
Instead, changing some .pm files is quite easy (nice interpreted language)

********************************************************************************
* Making your custom install ***************************************************
********************************************************************************
If you have your own rpms you want to add, or make your own updated cdrom, you
just have to issue:

% gendistrib --noclean --distrib <DIRS>

Where <DIRS> is the root of all the media that the install will see:

(1) network or 1-cdrom installs
	DIRS == the root directory of the Distribution

(2) multi-cdrom install
	DIRS == the root directories of all the media that the install will see

``gendistrib'' will scan, from the DIRS you provide, for some
Mandrake/RPMS* directories containing some RPM packages. For multi-cd,
please use Mandrake/RPMS, Mandrake/RPMS2, etc. For one CD or a network/hd
volume, please use Mandrake/RPMS.

Optionnally, you can modify ``Mandrake/base/rpmsrate''; this file manages
the relative importance of the files, and thus their installation or not.

Also, mdkinst_stage2.gz must be remade if you modify files in Mandrake/mdkinst.
See below for information about these files.

********************************************************************************
* FILES ************************************************************************
********************************************************************************
First here are the different things needed :

Mandrake/base/hdlists
	description of the available install media

Mandrake/base/hdlist*.cz
	table of rpm's headers, referred by ``hdlists''
	! Need to be remade when Mandrake/RPMS changes (with ``gendistrib'') !

Mandrake/base/depslist
	for each packages, tell which package it depends on. Also contains the
	size for some (obscure) bloody reasons.
	! Need to be remade when Mandrake/RPMS changes !
	(with ``misc/gendepslist2 -o Mandrake/base/depslist Mandrake/base/hdlist.cz2'')

Mandrake/base/depslist.ordered
	more compact depslist with closure done, internally indexed

Mandrake/base/compss
	obsoletes comps. It store packages in different categories, generated
	from the %{GROUP} field

Mandrake/base/rpmsrate
	ranks and classify packages, so that the installer will know which
        ones to install (see beginning of perl-install/pkgs.pm for more)

Mandrake/mdkinst
	live system used on certain installs. See ``Ramdisk or not'' below for
	more.

Mandrake/base/mdkinst_stage2.gz
	for the ramdisk. live sytem in ext2 filesystem gzipped.
	generated from Mandrake/mdkinst tree using misc/make_mdkinst_stage2
	See ``Ramdisk or not'' below for more.

images/*.img
	boot images to use with DrakX. Use:
	- cdrom for cdrom install
	- network for ftp/nfs install (non-pcmcia devices)
	- hd for hard-disk install
	- pcmcia for pcmcia install (see ``PCMCIA install'' below for more)

  the following modules have been removed from:
          network.img: acenic sk98lin de4x5
          cdrom.img and hd.img: BusLogic seagate fdomain g_NCR5380 dc395x_trm tmscsim
          hd.img: dpt_i2o eata eata_pio eata_dma
          cdrom.img: aztcd gscd isp16 mcd mcdx optcd cm206 sjcd 
          pcmcia.img: apa1480_cb
  they are now in "other.img", 

  if you think one of those modules is used a lot, tell me, i may find some room
  to put it back on the main floppies.
	

********************************************************************************
* logs *************************************************************************
********************************************************************************
During install, a lot of interesting stuff can be found in different places:
in consoles and in files. To switch to console 2 for example, do Ctrl-Alt-F2
from the X install.
- alt-F1: the stdout of the install. Not very interesting stuff
- alt-F2: simple shell. Quite a lot of commands are available but as they are
written in perl (for space), they do not handle the very same options as normal.
After install, you can do ``chroot /mnt'' to see your system just like after
rebooting. ``rpm -qa'' works for example.
- alt-F3: a lot of interesting things. Be carefull, some ``ERROR'' messages are
not interesting.
- alt-F4: kernel's place. aka the output of dmesg.
- alt-F7: the graphical install lives there

- command "bug" puts on floppy lots of interesting stuff.
- /tmp/ddebug.log: same (or nearly the same) as alt-F3
- /tmp/syslog: same as alt-F4
- /mnt/root/ddebug.log: at the end of each step, DrakX tries to backup
/tmp/ddebug.log to /mnt/root. Available only after mounting of /.
- /mnt/root/install.log: the log of the installation (or upgrade) of the rpms
(just like rpm's /mnt/tmp/(install|upgrade).log)
- /mnt/root/auto_inst.cfg.pl: a kickstart file generated at the end of each
step. Can be used in 2 ways: kickstart install or ``defcfg'' install. Hopefully
you know about kickstart. ``defcfg'' is a way to customize the default values in
install. For example, French can be the default language with a qwerty keyboard,
the auto-partitionning partitions can be changed, the default user class can be
set to developer (!)...

********************************************************************************
* po translation files *********************************************************
********************************************************************************
DrakX uses .po files for its translation. A script takes the different
strings out of the .pm files. It generates the DrakX.pot file which contains
all the english strings to translate.
To add a new language, you just have to add it to lang.pm (if it's not there
already) and put the .po in the perl-install/po directory (see ``Ramdisk or
not'' to know if you have to regenerate the mdkinst_stage2.gz)

********************************************************************************
* PCMCIA install ***************************************************************
********************************************************************************
If the media you use to install is a pcmcia device, use the pcmcia boot disk.

********************************************************************************
* Ramdisk or not ***************************************************************
********************************************************************************
The DrakX install is much bigger than the newt one. So the ramdisk which was
used is getting big, and costs a lot in memory 
(eg: the mdkinst_stage2 is 14MB - 23/09/99)
(update! now size is 21MB - 24/01/01)

|       | newt    | DrakX
|-------+---------+----------------------------------------------------------
| nfs   | live    | live
| ftp   | ramdisk | ramdisk
| http  | ramdisk | ramdisk
| hd    | ramdisk | live if Mandrake/mdkinst/usr/bin/runinstall2 is a link,
|       |         |   ramdisk otherwise
| cdrom | ramdisk | live if memory < 52MB, ramdisk otherwise

Where ramdisk is needed, if detected memory is below the limit allowed for
ramdisk (maintained in file gi/mdk-stage1/config-stage1.h; currently 52 Mb),
a failure dialog will be printed explaining that there is not enough memory
to perform the installation.

When i say live, it means that the stage1 will *mount* the
Mandrake/mdkinst and use it that way.

The ramdisk is used in place of the live in some cases. This ramdisk is filled
with mdkinst_stage2.gz

For cdrom install, the ramdisk is used to speed up things (access time is quite
high on cdrom drives)

For pcmcia, it depends on the type of install.


********************************************************************************
* modules **********************************************************************
********************************************************************************
Modules can be found in at least 2 places:
- in /modules/modules.mar
- in /lib/modules.cz<KERNEL_VERSION_RELEASE>

/modules/modules.mar is used in mdk-stage1. It contains only modules
interesting for one kind of install. For example in an hd install, it
contains scsi modules. For a network install, it contains network card
modules. (To create, extract or view files in a ``mar'' archive, please
use gi/mdk-stage1/mar/mar; this is basically an archive format meant to
be minimalistic)

/lib/modules.cz<KERNEL_VERSION_RELEASE> contains all modules, it is used
in stage2.


To install a module, use modprobe which is in /usr/bin. It's a perl wrapper
around /usr/bin/insmod. It uses the dependencies found in
/modules/modules.dep (stage1).

/usr/bin/insmod is a wrapper around /usr/bin/insmod_. It just extracts the
module out of /lib/modules.cz in /tmp. Then it calls insmod_.

/usr/bin/insmod_ is the real prog (which you usually find in /sbin/). You need
to give it the complete path.

********************************************************************************
* Making screenshots ***********************************************************
********************************************************************************
On a test machine, make a network install, switch to console (ctrl-alt-F2), enter:
% xhost+

then, on another computer:
% DISPLAY=test_machine:0 xwd -root | convert - screenshot.png

********************************************************************************
* Adding a new step to DrakX ***************************************************
********************************************************************************
Say we want to add a question for setting "alawindows" option.
We put it pretty early in the install, let's say after "Select Installation
Class".

1. in install2.pm

add

  selectAlawindows => [ __("A la windows or not"), 0, 1, '' ],

after

  selectInstallClass => [ __("Select installation class"), 1, 1, '' ],

the 0, 1, '' means not "redoable", "skip on error", "don't hide"

2. add your function selectAlawindows in install2.pm

sub selectAlawindows  { $o->selectAlawindows }

3. add your function selectAlawindows in install_steps_interactive.pm

sub selectAlawindows {
    my ($o) = @_;
    $o->{alawindows} = $o->ask_yesorno('', _("Throw everything away as windobe does?"), 1);
}

4. add your function selectAlawindows in install_steps.pm (not needed in that
case, except for auto_install)

sub selectAlawindows  {}


********************************************************************************
* Miscellaneous ****************************************************************
********************************************************************************
>  o Media access methods: nfs, ftp, http, hd, cdrom
>  o Stages: init, stage1, stage2
>    - What exactly each stage does

init loads stage1
stage1 loads stage2, on various medium type

stage2 is too big to fit on a floppy, that's why stage1 exists

>    - How each stage relates to the various media access methods

stage1 knows only how to access to the media is compiled for. It contains only
the kernel modules needed for that media. For eg, the nfs/ftp/http stage1
doesn't contain scsi modules nor ide.

>    - How one stage terminates and another begins. i.e., How does
>      stage1 find, mount, and launch stage2?

/sbin/init just starts /sbin/stage1
/sbin/stage1 takes care of mounting stage2 (in ramdisk if necessary)
  then it runs /usr/bin/runinstall2

>  o Text and Graphic mode installers
>    - Architectural overview of each

have a look at gi/install.fig


********************************************************************************
* OEM **************************************************************************
********************************************************************************
> I am a system OEM in Bangalore,India selling systems bundled with
> Mandrake Linux. The problem is that with every system I sell, I need to
> install & configure the system which takes HOURS!. Can I do a diskcopy
> instead?
> 
> Please Help. This is a major bottleneck for  me.

many solutions:

- make an install on drive hdb, then either
   1. dd if=/dev/hdb of=/dev/hdc
   2. dd if=/dev/hdb of=/dev/hdc count=1 ; kernel_reread /dev/hdc ; 
      mke2fs /dev/hdc1 ; mount /dev/hdb1 /source ; mount /dev/hdc1 /dest ; cp -a /source /dest

- try the oem feature
   3. - burn a cd out of *latest* cooker
      - boot on it telling "oem" to syslinux
      !! it will destroy every data on the harddrive !!
      - you now have a very automated install matrix 
      (duplicate it with "dd if=/dev/hdb of=/dev/hdc bs=1M count=730")

    put the harddrive in the oem box, the user will now have an *very* automated
    install, just asking the root password and user password.

   4. (just like 3. without burning a cd, doing the first part by hand)
      have a look at the /etc/oem script on the rescue and do it by hand...


cu Pixel.


comments:
1. maybe copy unnecessary things -> take too long
   solution -> use bs=8k count=xxxx 
2. kernel_reread can be found on the new rescue, source is also at end of this
mail. This solution works with one partition. Can be easily enhanced to many
primary partitions... For extended partitions, more complicated, but not much :)
3. has just been added in latest cooker. It may still have some pb. The main
current limitation is IDE only, though it can be fixed easily for special cases.

--------------------------------------------------------------------------------
#include <stdio.h>
#include <sys/mount.h>
#include <fcntl.h>

void die(char *msg)
{
  perror(msg);
  exit(1);
}

void kernel_read(char *dev)
{
  int fd;
  if ((fd = open(dev, O_RDONLY)) == -1) die("can't open device");
  ioctl(fd, BLKRRPART, 0);
  close(fd);
}

int main(int argc, char **argv) 
{
  if (argc != 2) {
    fprintf(stderr, "usage: kernel_read_part <hard drive device>\n");
    exit(1);
  }
  kernel_read(argv[1]);
}
