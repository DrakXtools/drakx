<?xml version="1.0"  encoding="ISO-8859-1"?>
  <article lang="en">
  <title>Clone a node using KA method</title>
  <sect1>
    <title>Clone a computer over the network</title>
    <para>
      Goal of duplication is to easily deploy a computer over network without taking care of numbers of computer. In this documentation, we call golden node the node we want to clone.
      We can duplicate SCSI or IDE hard drive, and duplication support multiple filesystem (reiserfs, ext2, ext3, xfs, jfs).
    </para>
    <sect2>
      <title>KA method</title>
      <para>
	With KA method you can quickly duplicate a node using a <emphasis role="bold">desc</emphasis>
	file describing partitions. KA method only duplicate data on partitions, so if you have 80go HDD disk, and
	only 10go on it, KA only duplicates 10go, and not the whole disk. KA method doesn't not support RAID software.
      </para>
      <para>
	Drawbacks:
      </para>
      <para>
	<itemizedlist>
	  <listitem><para>KA method doesn't support RAID software</para></listitem>
	  <listitem><para>you can only clone Linux filesystems (if you want to duplicate another kinf of FS, it's up to you to modify the scripts)</para></listitem>
	  <listitem><para>you can only duplicate same kind of HDD (IDE or SCSI)</para></listitem>
	</itemizedlist>
      </para>
    </sect2>
    <sect2>
      <title>HOW it works</title>
      <sect3>
	<title>Steps</title>
	<para>
	  The clone process works in three steps
	</para>
	<itemizedlist>
	  <listitem><para><emphasis role="bold">PXE boot to retrieve stage1</emphasis>: the computer boot on PXE mode, retrieve <emphasis role="bold">vmlinuz</emphasis> and an <emphasis role="bold">initrd</emphasis>. The computer is in <emphasis role="bold">stage1</emphasis> mode, and is able to get the stage2 throug KA. Network is up.</para></listitem>
	  <listitem><para><emphasis role="bold">get stage2</emphasis>: the computer gets the stage2 with KA method. The <emphasis role="bold">stage2</emphasis> contains all necessary tools to recognize your hardware (the most important things is to detect your HDD), and all necessary tools to finalize the cloning process.</para></listitem>
	  <listitem><para><emphasis role="bold">Duplication process</emphasis>: the computer auto-probes needed modules to be able to access to HDD. A basic log server is launched on the client node to be able to run command and get status of the KA duplication process.</para></listitem>
	</itemizedlist>
      </sect3>
      <sect3>
	<title>Needed files</title>
	<para>
	  All needed files are available on Mandriva Linux cooker.
	</para>
	<para>
	  <itemizedlist>
	    <listitem><para><emphasis role="bold">install/stage2/rescue.sqhfs</emphasis>: this is the stage2 file with all needed files to detect and probe modules, and launch the third step of the duplication process. This file will be used on the golden node.</para></listitem>
	    <listitem><para><emphasis role="bold">isolinux/alt0/vmlinuz</emphasis>: linux kernel, needed in the <emphasis role="bold">/var/lib/tftpboot/X86PC/linux/images/</emphasis> directory of the PXE server</para></listitem>
	    <listitem><para><emphasis role="bold">isolinux/alt0/all.rdz</emphasis>: stage1 and all needed modules.</para></listitem>
	  </itemizedlist>
	</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Step 1: PXE, TFTP, DHCPD services</title>
      <para>
	To easily clone a computer node, we use PXE technology to boot a <emphasis role="bold">kernel</emphasis>, and an <emphasis role="bold">initrd</emphasis> image wich contains all needed modules for network and media storage. Documentation about PXE can be found here: <ulink url="http://people.mandriva.com/~aginies/doc/pxe/">PXE doc</ulink>. Please, keep in mind setting such services can <emphasis role="bold">DISTURB</emphasis> your current network architecture.
      </para>
      <sect3>
	<title>PXE parameters on server</title>
	<para>
	  Mandriva Linux installer supports various methods to install a computer. With PXE configuration file you can specify wich method you want to use to install your node, or add a specific option at boot prompt. Edit your default PXE configuration file to add your custom entry (<emphasis role="bold">/var/lib/tftpboot/X86PC/linux/pxelinux.cfg/default</emphasis>).
	</para>
	<para>
	  <screen>
PROMPT 1
DEFAULT local
DISPLAY messages
TIMEOUT 50
F1 help.txt

label local
    LOCALBOOT 0

label kamethod
    KERNEL images/vmlinuz
    APPEND initrd=images/all.rdz ramdisk_size=64000 vga=788 \
	      automatic=method:ka,interface:eth0,network:dhcp root=/dev/ram3 rw rescue kamethod</screen>
	</para>
	<para>
	  At boot prompt no you can boot:
	</para>
	<para>
	  <itemizedlist>
	    <listitem><para><emphasis role="bold">DEFAULT local</emphasis>: default boot will be local one, change it with the name of a <emphasis role="bold">LABEL</emphasis></para></listitem>
	    <listitem><para><emphasis role="bold">local</emphasis>: boot local</para></listitem>
	    <listitem><para><emphasis role="bold">kamethod</emphasis>: automatic mode, get stage2 through <emphasis role="bold">KA</emphasis>. Network interface is set to eth0. Auto setup the network with DHCP, and use the KA technology to launch the replication method.</para></listitem>
	  </itemizedlist>
	</para>
      </sect3>
      <sect3>
	<title>TFTP server</title>
	<para>
	  TFTP server should be activated in <emphasis role="bold">/etc/xinetd.d/tftp</emphasis> file, and the <emphasis role="bold">xinetd</emphasis> service started.
	</para>
	<para>
	  <screen>
service tftp
{
	    disable= no
	    socket_type= dgram
	    protocol= udp
	    wait= yes
	    user= root
	    server= /usr/sbin/in.tftpd
	    server_args = -s /var/lib/tftpboot
	    per_source= 11
	    cps= 100 2
	    flags= IPv4
}</screen>
	</para>
      </sect3>
      <sect3>
	<title>PXE configuration</title>
	<para>
<programlisting><![CDATA[
# which interface to use
interface=eth0
default_address=IPADDR_PXE

# the multicast ip address to listen on
multicast_address=224.0.1.2

# mtftp info
mtftp_address=IPADDR_TFTP
mtftp_client_port=1758
mtftp_server_port=1759

# the port to listen on
listen_port=4011

# enable multicast?
use_multicast=1

# enable broadcast?
use_broadcast=0

# user prompt
prompt=Press F8 to view menu ...
prompt_timeout=2

# what services to provide, priority in ordering
# CSA = Client System Architecture
# service=<CSA>,<min layer>,<max layer>,<basename>,<menu entry>
service=X86PC,0,2,linux,Mandrake Linux x86
service=IA64PC,0,2,linux,Mandrake Linux IA64
service=X86PC,0,0,local,Local boot

# tftpd base dir
tftpdbase=/

# domain=guibland.com
domain=
]]></programlisting>
	</para>
      </sect3>
      <sect3>
	<title>DHCPD configuration</title>
	<para>
	  IE of an <emphasis role="bold">/etc/dhcpd.conf</emphasis> configuration file. Change <emphasis role="bold">IPADDR_TFTP</emphasis> with the IP address of the TFTP serrver, and the <emphasis role="bold">NET</emphasis> value. Don't forget to adjust the <emphasis role="bold">domain-name</emphasis> and the <emphasis role="bold">domain-name-servers</emphasis>.
	</para>
	<para>
	  <screen>
ddns-update-style none;
allow booting;
allow bootp;

authoritative;

# Definition of PXE-specific options
# Code 1: Multicast IP address of bootfile
# Code 2: UDP port that client should monitor for MTFTP responses
# Code 3: UDP port that MTFTP servers are using to listen for MTFTP requests
# Code 4: Number of secondes a client must listen for activity before trying
#         to start a new MTFTP transfer
# Code 5: Number of secondes a client must listen before trying to restart
#         a MTFTP transfer

# define Option for the PXE class
option space PXE;
option PXE.mtftp-ip code 1 = ip-address;
option PXE.mtftp-cport code 2 = unsigned integer 16;
option PXE.mtftp-sport code 3 = unsigned integer 16;
option PXE.mtftp-tmout code 4 = unsigned integer 8;
option PXE.mtftp-delay code 5 = unsigned integer 8;
option PXE.discovery-control code 6 = unsigned integer 8;
option PXE.discovery-mcast-addr code 7 = ip-address;

#Define options for pxelinux
option space pxelinux;
option pxelinux.magic code 208 = string;
option pxelinux.configfile code 209 = text;
option pxelinux.pathprefix code 210 = text;
option pxelinux.reboottime code 211 = unsigned integer 32;
site-option-space "pxelinux";

option pxelinux.magic f1:00:74:7e;
option pxelinux.reboottime 30;

#Class that determine the options for Etherboot 5.x requests
class "Etherboot" {
#if The vendor-class-identifier equal Etherboot-5.0
match if substring (option vendor-class-identifier, 0, 13) = "Etherboot-5.0";
# filename define the file retrieve by the client, there nbgrub
# our tftp is chrooted so is just the path to the file
filename "/etherboot/nbgrub";
#Used by etherboot to detect a valid pxe dhcp server
option vendor-encapsulated-options 3c:09:45:74:68:65:72:62:6f:6f:74:ff;
# Set the  "vendor-class-identifier" field to "PXEClient" in dhcp answer
# if this field is not set the pxe client will ignore the answer !
option vendor-class-identifier "Etherboot-5.0";
vendor-option-space PXE;
option PXE.mtftp-ip 0.0.0.0;
# IP of you TFTP server
next-server IPADDR_TFTP;
}

# create the Class PXE
class "PXE" {
# if the "vendor-class-identifier" is set to "PXEClient" in the client dhcp request
match if substring(option vendor-class-identifier, 0, 9) = "PXEClient";
filename "/X86PC/linux/linux.0";
option vendor-class-identifier "PXEClient";
vendor-option-space PXE;
option PXE.mtftp-ip 0.0.0.0;
next-server IPADDR_TFTP;
}

#host node20 {
#    hardware ethernet 00:40:CA:8C:B6:E9;
#    fixed-address node20;
#}

subnet NET.0 netmask 255.255.255.0 {
  option subnet-mask 255.255.255.0;
  option routers IPADDR_GW;
  default-lease-time 288000;
  max-lease-time 864000;
  option domain-name "guibland.com";
  option domain-name-servers IPADDR_DNS;
  next-server IPADDR_TFTP;
  pool {
  range NET.30 NET.40;
  }
}</screen>
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Setup a node as a golden node</title>
    <sect2>
      <title>The rescue.sqfs file</title>
      <para>
	You need the rescue disk (wich contains the <emphasis role="bold">/ka</emphasis> directory),
	and mount it loop in <emphasis role="bold">/mnt/ka</emphasis>.
      </para>
      <para>
	<screen>
mkdir /mnt/ka
mount -o loop -t squashfs rescue.sqfs /mnt/ka</screen>
      </para>
      <para>
	Go in the <emphasis role="bold">/mnt/ka/ka</emphasis> directory, and see all new files available. All those files are needed
	to do a <emphasis role="bold">KA</emphasis> duplication process. We will explain now the rule of each of them. If you want
	to modify the content of this rescue disk (add scripts...), mount it in a tempory directory, and copy the content
	into the <emphasis role="bold">/mnt/ka</emphasis> directory.
      </para>
      <sect3>
	<title>ka-d.sh</title>
	<para>
	  This is the master script to declare a node as a golden node. This script takes a lot of arguments.
<screen>
    -h, --help : display this message
    -n num : specify the number of (destination) nodes
    -x dir : exclude directory
    -X sdb : exclude sdb for the replication
    -m drive : copy the master boot record (for windows) of this drive
    -M drive file : use 'file' as master boot record (must be 446 bytes long) for the specified drive
    -D partition : also copy partition 'partition'
    -p drive pdesc : use 'pdesc' file as partition scheme (see doc) for the specified drive
    -d delay : delay beteween the release of 2 clients (1/10 second)
    -r 'grub|lilo' : choose the bootloader (you can add mkinitrd options)

    ie: ka-d.sh -n 3 -p sda /tmp/desc -X sdb -r 'grub --with=ata_piix --with=piix'</screen>
	</para>
      </sect3>
      <sect3>
        <title>replication.conf</title>
	<para>
	  This file contain all variables needed by other scripts. It also tries to get information like IP address.
	</para>
      </sect3>
      <sect3>
	<title>fdisk_to_desc</title>
	<para>
	  This script generate the description table of the hard drive disk in the <emphasis role="bold">/tmp/desc</emphasis> file.
	  This file must follow some rules: one line per partition, with two fields : type of partition and size in megabytes.
	  The  type  can be linux, swap, extended. Other types can be obtained by appending their hexadecimal number to 'type'.
	  For example linux is the same as type83. The size is either a number of megabytes, or the keyword fill (to take all
	  available space). The logical  partitions must have the logical keyword.
	</para>
      </sect3>
      <sect3>
	<title>gen_modprobe_conf.pl</title>
	<para>
	  This script create a basic output like the content of the<emphasis role="bold">/etc/modprobe.conf</emphasis> file. Drawbacks
	  this file must be updated for each new modules available in the kernel (based on the <emphasis role="bold">kernel/list_modules.pm</emphasis> file).
	</para>
      </sect3>
      <sect3>
	<title>ka-d-client</title>
	<para>
	  The <emphasis role="bold">ka-d-client</emphasis> binary file is used to get stage2 with the <emphasis role="bold">KA</emphasis> method, and after
	  get the whole system. The important argument is the <emphasis role="bold">-s</emphasis> session name. A <emphasis role="bold">KA</emphasis>
	  can only connect to a specific session (getstage2, kainstall ...). The code source is available in the ka-deploy-0.92 SRPM.
	</para>
      </sect3>
      <sect3>
	<title>ka-d-server</title>
	<para>
	  The <emphasis role="bold">ka-d-server</emphasis> binary file is used to be a <emphasis role="bold">KA</emphasis> golden node server.
	  Like the <emphasis role="bold">ka-d-client</emphasis> the session arguments is an important parameter (<emphasis role="bold">-s session_name</emphasis>).
	  The code source is available in the ka-deploy-0.92 SRPM.
	</para>
      </sect3>
      <sect3>
	<title>ka_replication.sh</title>
	<para>
	  Script launched on the <emphasis role="bold">KA</emphasis> client (after getting stage2 and probing modules), to do the full process of the
	  <emphasis role="bold">Ka</emphasis> duplication.
	  This script call other scripts to prepare the node (prepare_node.sh), configure the bootloader (make_initrd_grub or make_initrd_lilo).
	</para>
      </sect3>
      <sect3>
	<title>store_log.sh</title>
	<para>
	  Basic script to store the log of the <emphasis role="bold">KA</emphasis> duplication process on an FTP server. Adjust to feet your need, and uncomment
	  the line <emphasis role="bold">#store_log.sh</emphasis> in the <emphasis role="bold">/mnt/ka/ka/ka_replication.sh</emphasis> file.
	</para>
      </sect3>
      <sect3>
	<title>bootable_flag.sh</title>
	<para>
	  Script to set bootable an HDD using fdisk. First arg must be the HDD device.
	</para>
      </sect3>
      <sect3>
        <title>make_initrd_grub</title>
	<para>
	  Restore and reload the Grub bootloader in the <emphasis role="bold">/mnt/disk</emphasis> directory. It's a very basic script, and perhaps
	  use the <emphasis role="bold">restore_bootloader</emphasis> of the Mandriva Linux Rescue should be a better idea.
	</para>
      </sect3>
      <sect3>
        <title>make_initrd_lilo</title>
	<para>
	  Restore and reload the lilo bootloader in the <emphasis role="bold">/mnt/disk</emphasis> directory. Again it's a very basic script, perhaps we should use the
	  <emphasis role="bold">restore_bootloader</emphasis> of the Mandriva Linux Rescue.
	</para>
      </sect3>
      <sect3>
        <title>prepare_node.sh</title>
	<para>
	  This script remove in the futur system the old network's udev rules, old dhcp cache files, launch the script <emphasis role="bold">gen_modprobe_conf.pl</emphasis> to
	  regenerate an uptodate <emphasis role="bold">/etc/modprobe.conf</emphasis> in the new system, and launch the script to restore the bootloader.
	  If you want to do more action on the installed, system, you can modify this script.
	</para>
      </sect3>
      <sect3>
        <title>send_status.pl</title>
	<para>
	  Very basic perl script to open the port 12345, and paste the content of the <emphasis role="bold">/tmp/ka*</emphasis> file. It also
	  permit the execution of commands on node, if user send a message from the golden node with the <emphasis role="bold">exec</emphasis> prefix.
	</para>
      </sect3>
      <sect3>
        <title>status_node.pl</title>
	<para>
	  Script to connect to a client node, first arg must be the IP address of the node. You can run command on the node with the <emphasis role="bold">exec</emphasis> prefix.
	</para>
      </sect3>
    </sect2>
  </sect1>
  <sect1>
    <title>The golden node, KA server</title>
    <para>
      Now, it is time to build a description of the node partitions. You can use the script
      <emphasis role="bold">/mnt/ka/ka/fdisk_to_desc</emphasis> as root user, or your favorite text editor,
      you can write a file like this one:
    </para>
    <para>
      <screen>
linux 3500
extended fill
logical swap 500
logical linux fill</screen>
    </para>
    <para>
      This file describes your partition table and the sample above can be considered as a default one for a recommended
      installation. There is a 3.5GB <emphasis role="bold">/</emphasis> partition, a 500 MB swap
      partition, and <emphasis role="bold">/var</emphasis> fills the rest, of course you can adjust
      sizes accoding to your system.
    </para>
    <para>
      Type the following to start the ka replication server as root user:
    </para>
    <para>
<programlisting><![CDATA[
      <screen>
[root@node40 ka]# ./ka-d.sh -n 1 -p sda /root/desc -X sdb -r "grub --with=jfs --with=ata_piix"
takembr =
desc = sda /root/desc
+ Mount points :
     /dev/sda5 / ext3
     /dev/sda1 swap swap
+ Hard drives :
     sda
+ Reading partition table description for sda
    Added partition 1 : type 82
    Added partition 5 : type 83
+ Included mount points : /
+ Bootloader is: grub --with=jfs --with=ata_piix
+++ Sending Stage2 +++
Compiled : Aug 23 2007 12:58:29
ARGS=+ka-d-server+-s+getstage2+-n+1+-e+(cd /mnt/ka; tar --create --one-file-system --sparse  . )+
Server IP = 10.0.1.40
command = (cd /mnt/ka; tar --create --one-file-system --sparse  . )
I want 1 clients
Socket 4 on port 30765 on node40.guibland.com ready.
Socket 5 on port 30764 on node40.guibland.com ready.
]]></programlisting>
    </para>
    <para>
      <itemizedlist>
	<listitem><para><emphasis role="bold">-r "grub --with=jfs --with=ata_piix"</emphasis>: use grub bootloader and <emphasis role="bold">--with=jfs --with=piix</emphasis> mkinitrd option in the chrooted system after the <emphasis role="bold">KA</emphasis> deploiement</para></listitem>
	<listitem><para><emphasis role="bold">-n nb_nodes</emphasis>: specify how many nodes are clients</para></listitem>
	<listitem><para><emphasis role="bold">-p sda/hda desc</emphasis>: specify if you want to duplicate SCSI or IDE storage, and the name of the hdd</para></listitem>
	<listitem><para><emphasis role="bold">-x /tmp</emphasis>: exclude <emphasis role="bold">/tmp</emphasis> directory</para></listitem>
	<listitem><para><emphasis role="bold">-X sdb</emphasis>: exclude <emphasis role="bold">sdb</emphasis> hdd for the duplication</para></listitem>
      </itemizedlist>
    </para>
    <para>
      Now the node is waiting for the rest of the nodes to start replication.
    </para>
  </sect1>
  <sect1>
    <title>KA client node</title>
    <sect2>
      <title>PXE server (kamethod)</title>
      <para>
	We have to configure the PXE to boot by default on <emphasis role="bold">kamethod</emphasis>.
	To do this just edit <emphasis role="bold">/var/lib/tftpboot/X86PC/linux/pxelinux.cfg/default</emphasis> and set
	  <emphasis role="bold">DEFAULT</emphasis> to kamethod:
      </para>
      <screen>DEFAULT kamethod</screen>
      <para>
	So, next time a node boots, the PXE server will force the
	node to boot using the kamethod.
      </para>
    </sect2>
    <sect2>
      <title>Stage1 KA method, node waiting stage2 </title>
      <para>
	Now, you boot all remaining nodes. The replication process
	will start once all nodes are up and waiting on the <emphasis role="bold">KA</emphasis>
	screen.
      </para>
      <para>
	If the nodes can't reach the golden node, running the <emphasis role="bold">KA</emphasis>
	server the message <emphasis role="bold">Can't reach a valid KA server</emphasis> will appear.
	Each node will try five times to reach the <emphasis role="bold">KA</emphasis> server, after that the node will reboot.
	As the node boots on <emphasis role="bold">kamethod</emphasis>, it will retry until it finds it.
      </para>
    </sect2>
    <sect2>
      <title>Stage2, the duplication process</title>
      <para>
	Once all the nodes have found the <emphasis role="bold">KA</emphasis> server, the first
	duplication process will start. This step duplicates the
	<emphasis role="bold">rescue_stage2</emphasis> from the <emphasis role="bold">/mnt/ka</emphasis> directory
	of the golden node, in the client's nodes memory (<emphasis role="bold">/dev/ram3</emphasis>). Then, nodes chroot their
	memories (the <emphasis role="bold">/tmp/stage2</emphasis> directory), and launch the <emphasis role="bold">drvinst</emphasis> command from the rescue disk, to probe all needed their modules (drivers).
	Then, the second step of the duplication starts.
      </para>
      <para>
	The duplication process will clone your drives following
	the description you have made (<emphasis role="bold">/tmp/desc</emphasis> of the golden node).
	Nodes will rewrite their partition table, then format their filesystems (ReiserFs, XFS,
	ext2/3, JFS). All new partitions will be mounted in the <emphasis role="bold">/mnt/disk</emphasis> directory.
	Then, the drive duplication process will begin. On a fast Ethernet switch you can reach speeds of 10MBytes/sec.
      </para>
    </sect2>
    <sect2>
      <title>Prepare the node</title>
	<para>
	At the end of the duplication process, each node will
	chroot its partitions and rebuild its <emphasis role="bold">/boot/initrd.img</emphasis>,
	and <emphasis role="bold">/etc/modprobe.conf</emphasis> files.
	This step ensures that your node will reboot using its potential
	SCSI drives and adjusting its network card driver. Before
	rebooting, each node reinstalls lilo/grub. All your node are
	now ready, and are clone of master node.
      </para>
      </sect2>
    <sect2><title>PXE server to local boot</title>
      <para>
	Don't forget to change the default PXE boot to <emphasis role="bold">local</emphasis>
	so node after replication will boot localy.
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>full log of a KA duplication</title>
    <sect2>
      <title>Golden node side</title>
      <para>
<programlisting><![CDATA[
[root@node40 ka]# ./ka-d.sh -n 1 -p sda /root/desc -X sdb -r "grub --with=jfs --with=ata_piix"
takembr =
desc = sda /root/desc
+ Mount points :
     /dev/sda5 / ext3
     /dev/sda1 swap swap
+ Hard drives :
     sda
+ Reading partition table description for sda
    Added partition 1 : type 82
    Added partition 5 : type 83
+ Included mount points : /
+ Bootloader is: grub --with=jfs --with=ata_piix
+++ Sending Stage2 +++
Compiled : Aug 23 2007 12:58:29
ARGS=+ka-d-server+-s+getstage2+-n+1+-e+(cd /mnt/ka; tar --create --one-file-system --sparse  . )+
Server IP = 10.0.1.40
command = (cd /mnt/ka; tar --create --one-file-system --sparse  . )
I want 1 clients
Socket 4 on port 30765 on node40.guibland.com ready.
Socket 5 on port 30764 on node40.guibland.com ready.
got UDP packet from 10.0.1.35
Session name matches
Sending UDP reply to 10.0.1.35
Accepting connection from 10.0.1.35
Clients : want_data 0  / connected 0
client says hello !
Client sends options
Client accepts data
Added client 10.0.1.35, daddy = 10.0.1.40
Accepting connection from 10.0.1.35
checking connection auth10.0.1.40 reports 10.0.1.35 has opened data connection
Client 10.0.1.35 reports data position : 0
10.0.1.40 reports 10.0.1.35 has been accepted
Welcome son, you are number 1 (MAX 4)
Let's go!
Total data read = 45 Megs, BUF: 0M  FREE = 34M  startpos = 10M
End of data flow
Dropping children
Dropping child 10.0.1.35
All children dropped
Client says dad disconnected
Client says he has finished
Client has finished transfer
Busy clients: 0 -- connected : 1
Peer closed connection on socket 6
close_connection(6)
Busy clients: 0 -- connected : 0
All clients left, I quit
Total data sent = 48 Megs, in 2172 packets
Transfer time = 6.125 seconds, throughput = 7.881 Mbytes/second
The pipeline was emptied in 0.026 seconds
 - Sending partition/filesystem/mount points informations...
 +++ Running ka-deploy +++
Compiled : Aug 23 2007 12:58:29
ARGS=+ka-d-server+-s+kainstall1+-n+1+-e+(cd /tmp/ka-d6083 && tar c *)+
Server IP = 10.0.1.40
command = (cd /tmp/ka-d6083 && tar c *)
I want 1 clients
Socket 4 on port 30765 on node40.guibland.com ready.
Socket 5 on port 30764 on node40.guibland.com ready.
got UDP packet from 10.0.1.35
Session name matches
Sending UDP reply to 10.0.1.35
Accepting connection from 10.0.1.35
Clients : want_data 0  / connected 0
client says hello !
Client sends options
Client accepts data
Added client 10.0.1.35, daddy = 10.0.1.40
Accepting connection from 10.0.1.35
checking connection auth10.0.1.40 reports 10.0.1.35 has opened data connection
Client 10.0.1.35 reports data position : 0
10.0.1.40 reports 10.0.1.35 has been accepted
Welcome son, you are number 1 (MAX 4)
Let's go!
Total data read = 0 Megs, BUF: 0M  FREE = 34M  startpos = 0M
End of data flow
Dropping children
Dropping child 10.0.1.35
All children dropped
Client says dad disconnected
Client says he has finished
Client has finished transfer
Busy clients: 0 -- connected : 1
Peer closed connection on socket 6
close_connection(6)
Busy clients: 0 -- connected : 0
All clients left, I quit
Total data sent = 0 Megs, in 1 packets
Transfer time = 0.016 seconds, throughput = 0.628 Mbytes/second
The pipeline was emptied in 0.027 seconds
 WAITING node (partition/format)
 - Sending Linux filesystem...
 +++ Running ka-deploy +++
Compiled : Aug 23 2007 12:58:29
ARGS=+ka-d-server+-s+kainstall2+-n+1+-e+(cd /; tar --create --one-file-system --sparse  /)+
Server IP = 10.0.1.40
command = (cd /; tar --create --one-file-system --sparse  /)
I want 1 clients
Socket 4 on port 30765 on node40.guibland.com ready.
Socket 5 on port 30764 on node40.guibland.com ready.
got UDP packet from 10.0.1.35
Session name matches
Sending UDP reply to 10.0.1.35
Accepting connection from 10.0.1.35
Clients : want_data 0  / connected 0
client says hello !
Client sends options
Client accepts data
Added client 10.0.1.35, daddy = 10.0.1.40
Accepting connection from 10.0.1.35
checking connection auth10.0.1.40 reports 10.0.1.35 has opened data connection
Client 10.0.1.35 reports data position : 0
10.0.1.40 reports 10.0.1.35 has been accepted
Welcome son, you are number 1 (MAX 4)
Let's go!
Total data read = 621 Megs, BUF: 24M  FREE = 10M  startpos = 586M
End of data flow
Dropping children
Dropping child 10.0.1.35
All children dropped
Client says dad disconnected
Client says he has finished
Client has finished transfer
Busy clients: 0 -- connected : 1
Peer closed connection on socket 6
close_connection(6)
Busy clients: 0 -- connected : 0
All clients left, I quit
Total data sent = 627 Megs, in 34011 packets
Transfer time = 127.140 seconds, throughput = 4.937 Mbytes/second
The pipeline was emptied in 1.549 seconds
]]></programlisting>
      </para>
    </sect2>
    <sect2>
      <title>KA client side</title>
      <para>
	Just launch <emphasis role="bold">/mnt/ka/ka/status_node.pl IPADD</emphasis> to get log of the KA client.
      </para>
<programlisting><![CDATA[
10.0.1.35> ------| Ka |---- Install starting...
10.0.1.35> Current session is -s kainstall1
10.0.1.35>  Receiving partitions information...OK
10.0.1.35>  Cleaning hard drive...
10.0.1.35> ==> /tmp/kacmd <==
10.0.1.35> Starting log server..
10.0.1.35> 
10.0.1.35> ==> /tmp/ka_log-10.0.1.35-20071024-10h32 <==
10.0.1.35> OK
10.0.1.35> Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel
10.0.1.35> Building a new DOS disklabel with disk identifier 0x59be1427.
10.0.1.35> Changes will remain in memory only, until you decide to write them.
10.0.1.35> After that, of course, the previous content won't be recoverable.
10.0.1.35> 
10.0.1.35> 
10.0.1.35> The number of cylinders for this disk is set to 1116.
10.0.1.35> There is nothing wrong with that, but this is larger than 1024,
10.0.1.35> and could in certain setups cause problems with:
10.0.1.35> 1) software that runs at boot time (e.g., old versions of LILO)
10.0.1.35> 2) booting and partitioning software from other OSs
10.0.1.35>    (e.g., DOS FDISK, OS/2 FDISK)
10.0.1.35> Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)
10.0.1.35> 
10.0.1.35> Command (m for help): The partition table has been altered!
10.0.1.35> 
10.0.1.35> Calling ioctl() to re-read partition table.
10.0.1.35> Syncing disks.
10.0.1.35>  Writing partition table for sda using fdisk...OK
10.0.1.35>  Formatting /dev/sda5 as ext3...OK
10.0.1.35>  Formatting /dev/sda1 as swap...OK
10.0.1.35> - Mounting /dev/sda5 as /mnt/disk/ ......OK
10.0.1.35> ++++++++++++++++++++++++++
10.0.1.35> rootfs on / type rootfs (rw)
10.0.1.35> /proc on /proc type proc (rw)
10.0.1.35> none on /sys type sysfs (rw)
10.0.1.35> none on /proc/bus/usb type usbfs (rw)
10.0.1.35> /dev/ram3 on /tmp/stage2 type ext2 (rw)
10.0.1.35> /dev/sda5 on /mnt/disk type ext3 (rw,data=ordered)
10.0.1.35> ++++++++++++++++++++++++++
10.0.1.35> Linux copy is about to start 
10.0.1.35> Server IP is 10.0.1.40
10.0.1.35> Buffers names :pipe 
Total data received = 620 Megs (11.222 Mbytes/sec); BUF :0M End of data flow
10.0.1.35> Flushing buffers
10.0.1.35> Total data received = 627 Megs, in 434960 packets
10.0.1.35> Elapsed time = 128.482 seconds, throughput = 4.886 Mbytes/second
10.0.1.35>  Syncing disks...OK
10.0.1.35> Linux copy done.
10.0.1.35> Creating excluded directories
10.0.1.35> - bootloader is grub --with=jfs --with=ata_piix (user choice and options)
10.0.1.35> - Removing duplicated dhcp cache
10.0.1.35> - Writing modprobe.conf
10.0.1.35> ********************
10.0.1.35> install scsi_hostadapter /sbin/modprobe aic7xxx; /sbin/modprobe ata_piix; /bin/true
10.0.1.35> alias eth0 eepro100
10.0.1.35> alias eth1 eepro100
10.0.1.35> ********************
10.0.1.35> - Remove ude network rules
10.0.1.35> removed `/mnt/disk/etc/udev/rules.d/61-net_config.rules'
10.0.1.35> - Running mkinitrd
10.0.1.35> Looking for default grub menu
10.0.1.35> - erase old initrd.img link
10.0.1.35> removed `/mnt/disk/boot/initrd.img'
10.0.1.35>  initrd will be : /boot/initrd-2.6.22.9-desktop-1mdv.img
10.0.1.35> running: chroot /mnt/disk /sbin/mkinitrd -v -f --with=jfs /boot/initrd-2.6.22.9-desktop-1mdv.img 2.6.22.9-desktop-1mdv
10.0.1.35> Looking for deps of module aic7xxx
	10.0.1.35>  scsi_transport_spi scsi_mod
10.0.1.35> Looking for deps of module scsi_transport_spi
	10.0.1.35>  scsi_mod
10.0.1.35> Looking for deps of module scsi_mod
10.0.1.35> skip dups
10.0.1.35> Looking for deps of module sd_mod
	10.0.1.35>  scsi_mod
10.0.1.35> Looking for deps of module scsi_wait_scan
	10.0.1.35>  scsi_mod
10.0.1.35> Looking for deps of module ext3
	10.0.1.35>  jbd
10.0.1.35> Looking for deps of module jbd
10.0.1.35> Looking for deps of module jfs
10.0.1.35> Using modules:  /lib/modules/2.6.22.9-desktop-1mdv/kernel/drivers/scsi/scsi_mod.ko /lib/modules/2.6.22.9-desktop-1mdv/kernel/drivers/scsi/scsi_transport_spi.ko /lib/modules/2.6.22.9-desktop-1mdv/kernel/drivers/scsi/aic7xxx/aic7xxx.ko /lib/modules/2.6.22.9-desktop-1mdv/kernel/drivers/scsi/sd_mod.ko /lib/modules/2.6.22.9-desktop-1mdv/kernel/drivers/scsi/scsi_wait_scan.ko /lib/modules/2.6.22.9-desktop-1mdv/kernel/fs/jbd/jbd.ko /lib/modules/2.6.22.9-desktop-1mdv/kernel/fs/ext3/ext3.ko /lib/modules/2.6.22.9-desktop-1mdv/kernel/fs/jfs/jfs.ko
10.0.1.35> Using /tmp as temporary directory.
10.0.1.35> /sbin/nash -> /tmp/initrd.tG1408/bin/nash
	10.0.1.35> /lib/modules/2.6.22.9-desktop-1mdv/kernel/drivers/scsi/scsi_mod.ko.gz: 60.6%
	10.0.1.35> /lib/modules/2.6.22.9-desktop-1mdv/kernel/drivers/scsi/scsi_transport_spi.ko.gz: 63.1%
	10.0.1.35> /lib/modules/2.6.22.9-desktop-1mdv/kernel/drivers/scsi/aic7xxx/aic7xxx.ko.gz: 61.4%
	10.0.1.35> /lib/modules/2.6.22.9-desktop-1mdv/kernel/drivers/scsi/sd_mod.ko.gz: 60.2%
	10.0.1.35> /lib/modules/2.6.22.9-desktop-1mdv/kernel/drivers/scsi/scsi_wait_scan.ko.gz: 77.3%
	10.0.1.35> /lib/modules/2.6.22.9-desktop-1mdv/kernel/fs/jbd/jbd.ko.gz: 60.5%
	10.0.1.35> /lib/modules/2.6.22.9-desktop-1mdv/kernel/fs/ext3/ext3.ko.gz: 53.9%
	10.0.1.35> /lib/modules/2.6.22.9-desktop-1mdv/kernel/fs/jfs/jfs.ko.gz: 51.4%
10.0.1.35> Loading module scsi_mod.ko
10.0.1.35> Loading module scsi_transport_spi.ko
10.0.1.35> Loading module aic7xxx.ko
10.0.1.35> Loading module sd_mod.ko
10.0.1.35> Loading module scsi_wait_scan.ko
10.0.1.35> Loading module jbd.ko
10.0.1.35> Loading module ext3.ko
10.0.1.35> Loading module jfs.ko
10.0.1.35> /usr/sbin/resume -> /tmp/initrd.tG1408/bin
10.0.1.35> Contents of RCFILE:
10.0.1.35> #!/bin/nash
10.0.1.35> 
10.0.1.35> echo "Loading scsi_mod.ko module"
10.0.1.35> insmod /lib/scsi_mod.ko 
10.0.1.35> echo "Loading scsi_transport_spi.ko module"
10.0.1.35> insmod /lib/scsi_transport_spi.ko 
10.0.1.35> echo "Loading aic7xxx.ko module"
10.0.1.35> insmod /lib/aic7xxx.ko 
10.0.1.35> echo "Loading sd_mod.ko module"
10.0.1.35> insmod /lib/sd_mod.ko 
10.0.1.35> echo "Loading scsi_wait_scan.ko module"
10.0.1.35> insmod /lib/scsi_wait_scan.ko 
10.0.1.35> echo "Loading jbd.ko module"
10.0.1.35> insmod /lib/jbd.ko 
10.0.1.35> echo "Loading ext3.ko module"
10.0.1.35> insmod /lib/ext3.ko 
10.0.1.35> echo "Loading jfs.ko module"
10.0.1.35> insmod /lib/jfs.ko 
10.0.1.35> echo Mounting /proc filesystem
10.0.1.35> mount -t proc /proc /proc
10.0.1.35> echo Mounting sysfs
10.0.1.35> mount -t sysfs none /sys
10.0.1.35> echo Creating device files
10.0.1.35> mountdev size=32M,mode=0755
10.0.1.35> mkdevices /dev
10.0.1.35> echo Creating root device
10.0.1.35> mkrootdev /dev/root
10.0.1.35> resume
10.0.1.35> echo 1 > /sys/power/suspend2/do_resume
10.0.1.35> echo 1 > /sys/power/tuxonice/do_resume
10.0.1.35> echo Mounting root filesystem /dev/root with flags relatime
10.0.1.35> mount -o relatime --ro -t ext3 /dev/root /sysroot
10.0.1.35> echo Switching to new root
10.0.1.35> switchroot --movedev /sysroot
10.0.1.35> echo Initrd finished
10.0.1.35>  First drive will be: /dev/sda
10.0.1.35> Installation finished. No error reported.
10.0.1.35> This is the contents of the device map /boot/grub/device.map.
10.0.1.35> Check if this is correct or not. If any of the lines is incorrect,
10.0.1.35> fix it and re-run the script `grub-install'.
10.0.1.35> 
10.0.1.35> (hd0) /dev/sda
10.0.1.35> (hd1) /dev/sdb
10.0.1.35> umount: /mnt/disk/dev: not mounted
10.0.1.35>  Umounting /dev/sda5...OK
10.0.1.35> AUTH not understood
10.0.1.35> Local directory now /tmp
exec lsmod
10.0.1.35> <console> 
10.0.1.35> <console> 
10.0.1.35> <console> exec lsmod
10.0.1.35> Module                  Size  Used by
10.0.1.35> aic7xxx               167992  0 
10.0.1.35> scsi_transport_spi     22432  1 aic7xxx
10.0.1.35> ata_piix               12228  0 
10.0.1.35> libata                109424  1 ata_piix
10.0.1.35> sr_mod                 15044  0 
10.0.1.35> sd_mod                 25888  0 
10.0.1.35> scsi_mod              124908  5 aic7xxx,scsi_transport_spi,libata,sr_mod,sd_mod
10.0.1.35> loop                   14212  0 
10.0.1.35> jfs                   176708  0 
10.0.1.35> xfs                   528088  0 
10.0.1.35> reiserfs              247908  0 
10.0.1.35> ext3                  118824  0 
10.0.1.35> jbd                    50184  1 ext3
10.0.1.35> vfat                   10816  0 
10.0.1.35> nls_iso8859_1           4672  0 
10.0.1.35> nls_cp437               6304  0 
10.0.1.35> fat                    45980  1 vfat
10.0.1.35> isofs                  31452  0 
10.0.1.35> piix                    9060  0 [permanent]
10.0.1.35> ide_cd                 35488  0 
10.0.1.35> ide_disk               14496  0 
10.0.1.35> ide_core               99396  3 piix,ide_cd,ide_disk
10.0.1.35> af_packet              17960  0 
10.0.1.35> eepro100               28432  0 
10.0.1.35> mii                     5376  1 eepro100
10.0.1.35> usbkbd                  6304  0 
10.0.1.35> uhci_hcd               22736  0 
10.0.1.35> usbcore               113928  3 usbkbd,uhci_hcd
]]></programlisting>
    </sect2>
  </sect1>
</article>
<!-- Keep this comment at the end of the file
Local Variables:
mode: xml
sgml-parent-document: (".duplication.xml" "legalnotice")
End:
-->
