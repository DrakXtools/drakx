#!/usr/bin/perl

@ARGV >= 2 or die "usage: $0 <image> all|other|cdrom|hd|network|blank|pcmcia|live|tftp|tftprd\n";

use Config;
Config->import;
my ($arch) = $Config{archname} =~ /(.*)-/;
my $corporate = $ENV{CORPORATE} && " corporate"; #- use this for building a corporate version.

($img, $type) = @ARGV;

$instdir = "install";
$mnt = "/tmp/drakx_mnt";
$mke2fs = "/sbin/mke2fs -q -m 0 -F -s 1";

if ($>) {
    $sudo = "sudo";
    $ENV{PATH} = "/sbin:/usr/sbin:$ENV{PATH}";
}

sub __ { print @_, "\n"; system(@_); }
sub _ { __ @_; $? and die; }

_ "$sudo mkdir $mnt" unless -e $mnt;
_ "$sudo mkdir ${mnt}2" unless -e "${mnt}2";

$install = $ {{
    all => "full-install",
    other => "full-install",
    blank => "full-install",
    live => "full-install",
    tftp => "full-install",
    tftprd => "full-install",
    pcmcia => "full-install",
    network => "install",
    cdrom => "local-install",
    hd => "local-install",
    live64 => "full-install",
    tftp64 => "full-install",
    tftprd64 => "full-install",
    pcmcia64 => "full-install",
    network64 => "install",
    cdrom64 => "local-install",
    hd64 => "local-install",
}}{$type} or die;

$img =~ /rdz$/ ? initrd($mnt, $img) : $::{"boot_img_$arch"}->($mnt, $img);

sub install_s { _ "strip $_[0]"; _ "$sudo install $_[0] $_[1]" }

sub initrd {
    my ($mnt, $img) = @_;
    my ($ltype, $I) = $type =~ /(.*?)(64)/; $ltype ||= $type;
    my $tmp = "$ENV{HOME}/tmp/initrd";
    my $tar = "$instdir/install1.tar.bz2";

    __ "$sudo umount $tmp $mnt 2>/dev/null";
    _ "dd if=/dev/zero of=$tmp bs=1k count=" . ($type eq "all" ? 4000 : 2000);
    _ "$mke2fs $tmp";
    _ "$sudo mount -t ext2 $tmp $mnt -o loop";

    _ "$sudo tar xyC $mnt -f $tar";
    install_s("$instdir/installinit/init", "$mnt/sbin");
    install_s("$instdir/$install", "$mnt/sbin/install");

    if ($type eq "pcmcia") {
	unlink "$mnt/sbin/sh";
	_ "$sudo cp -a tools/$arch/sh $mnt/sbin";
	_ "$sudo cp -a /etc/pcmcia $mnt/etc";
	_ "$sudo patch -p0 -d $mnt/etc < $instdir/pcmcia_config.patch";
    }
    my $ftype = $type =~ /^(all)$/ ? "pcmcia" : $type;
    _ "$sudo cp -f install_${ftype}_modules/* $mnt/modules/" if -d "install_${ftype}_modules";
    _ "$sudo cp -f modules$I/${ltype}_modules.cgz $mnt/modules/modules$I.cgz" if $type !~ /blank/;
    _ "$sudo cp -f modules$I/modules.dep $mnt/modules/";
    _ "$sudo umount $mnt";

# Workaround for vfat-loop bug (quite touchy)
    _ "gzip -9f $tmp";
    _ "cp -f $tmp.gz $img";
    _ "rm -f $tmp.gz";
#    _ "gzip -9 -c $tmp > $img";
#    _ "rm -f $tmp";
}

sub boot_img_i386 {
    my ($mnt, $img) = @_;

    __ "$sudo umount $mnt 2>/dev/null";
    if ($type eq "hd") {
	_ "bunzip2 -c $instdir/installinit/msgboot.img.bz2 > $img";
    } elsif ($type eq "all") {
	_ "bunzip2 -c $instdir/installinit/msgboot-graphicallogo-2880.img.bz2 > $img";
    } else {
	_ "bunzip2 -c $instdir/installinit/msgboot-graphicallogo.img.bz2 > $img";
    }
    _ "$sudo mount -t msdos -o umask=0 $img $mnt -o loop";
    _ "cat vmlinuz > $mnt/vmlinuz" if $type !~ /blank/;
    -f "$type.rdz" ? _ "cp -f $type.rdz $mnt" : initrd("${mnt}2", "$mnt/$type.rdz");

    my $ftype = $type =~ /^(other|all)$/ ? "cdrom" : $type;
    my $timeout = 72;
    output("$mnt/syslinux.cfg", "
default linux
prompt 1
timeout $timeout
display boot.msg
F1 help.msg
F2 boot.msg
label linux
  kernel vmlinuz
  append ramdisk_size=32000 initrd=$type.rdz $ftype vga=788
label vgalo
  kernel vmlinuz
  append ramdisk_size=32000 initrd=$type.rdz $ftype vga=785
label vgahi
  kernel vmlinuz
  append ramdisk_size=32000 initrd=$type.rdz $ftype vga=791
label vga16
  kernel vmlinuz
  append ramdisk_size=32000 initrd=$type.rdz $ftype vga16
label text
  kernel vmlinuz
  append ramdisk_size=32000 initrd=$type.rdz $ftype text
label patch
  kernel vmlinuz
  append ramdisk_size=32000 initrd=$type.rdz $ftype patch vga=788
label expert
  kernel vmlinuz
  append ramdisk_size=32000 initrd=$type.rdz $ftype expert vga=788
label rescue
  kernel vmlinuz
  append ramdisk_size=32000 initrd=$type.rdz $ftype rescue rw
label oem
  kernel vmlinuz
  append ramdisk_size=32000 initrd=cdrom.rdz cdrom rescue oem rw
label auto
  kernel vmlinuz
  append ramdisk_size=32000 initrd=$type.rdz $ftype auto_install=auto_inst.cfg.pl
");
    _ "sync";
    _ "df $mnt";
}

sub boot_img_alpha {
    my ($mnt, $img) = @_;

    __ "$sudo umount $mnt 2>/dev/null";
    _ "dd if=/dev/zero of=$img bs=1k count=1440";
    _ "$mke2fs $img";
    _ "/sbin/e2writeboot $img /boot/bootlx";
    _ "$sudo mount -t ext2 $img $mnt -o loop";
    _ "cp -f vmlinux.gz $mnt" if $type !~ /blank/;
    -f "$type.rdz" ? _ "cp -f $type.rdz $mnt" : initrd("${mnt}2", "$mnt/$type.rdz");

    mkdir "$mnt/etc", 0777;
    output("$mnt/etc/aboot.conf", 
"0:vmlinux.gz initrd=$type.rdz rw ramdisk_size=32000 $type
1:vmlinux.gz initrd=$type.rdz rw ramdisk_size=32000 text $type
");
    _ "sync";
    _ "df $mnt";
}

sub boot_img_sparc {
    my ($mnt, $img) = @_;
    if ($type =~ /^live(.*)/) {
	#- hack to produce directly into /export the needed file for cdrom boot.
	my $dir = "/export";
	my $boot = "boot"; #- non-absolute pathname only!

	_ "mkdir -p $dir/$boot";
	_ "cp -f /boot/cd.b /boot/second.b $dir/$boot";
	_ "cp -f vmlinux$1 $dir/$boot/vmlinux$1";
	-f "live$1.rdz" ? _ "cp -f live$1.rdz $dir/$boot" : initrd("${mnt}2", "$dir/$boot/live$1.rdz");

	output("$dir/$boot/silo.conf", "
partition=1
default=linux
timeout=100
read-write
message=/$boot/boot.msg
image=\"cat /$boot/boot.msg\"
  label=1
  single-key
image=\"cat /$boot/general.msg\"
  label=2
  single-key
image=\"cat /$boot/expert.msg\"
  label=3
  single-key
image=\"cat /$boot/rescue.msg\"
  label=4
  single-key
image=\"cat /$boot/kickit.msg\"
  label=5
  single-key
image=\"cat /$boot/param.msg\"
  label=6
  single-key
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=linux
  alias=install
  initrd=/$boot/live.rdz
  append=\"ramdisk_size=32000$corporate\"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=text
  initrd=/$boot/live.rdz
  append=\"ramdisk_size=32000 text$corporate\"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=expert
  initrd=/$boot/live.rdz
  append=\"ramdisk_size=32000 expert$corporate\"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=ks
  initrd=/$boot/live.rdz
  append=\"ramdisk_size=32000 ks$corporate\"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=rescue
  initrd=/$boot/live.rdz
  append=\"ramdisk_size=32000 rescue rw root=/dev/ram3$corporate\"
image[sun4u]=/$boot/vmlinux64
  label=linux
  alias=install
  initrd=/$boot/live64.rdz
  append=\"ramdisk_size=32000$corporate\"
image[sun4u]=/$boot/vmlinux64
  label=text
  initrd=/$boot/live64.rdz
  append=\"ramdisk_size=32000 text$corporate\"
image[sun4u]=/$boot/vmlinux64
  label=expert
  initrd=/$boot/live64.rdz
  append=\"ramdisk_size=32000 expert$corporate\"
image[sun4u]=/$boot/vmlinux64
  label=ks
  initrd=/$boot/live64.rdz
  append=\"ramdisk_size=32000 ks$corporate\"
image[sun4u]=/$boot/vmlinux64
  label=rescue
  initrd=/$boot/live64.rdz
  append=\"ramdisk_size=32000 rescue rw root=/dev/ram3$corporate\"
");

	output("$dir/$boot/README", "
To Build a Bootable CD-ROM, try:
  mkisofs -R -o t.iso -s /$boot/silo.conf /export
");
    } elsif ($type =~ /^tftprd(.*)/) {
	my $dir = "/export";
	my $boot = "images";
	my $setarch = $1 ? "sparc64" : "sparc32";

	_ "mkdir -p $dir/$boot";
	-f "$type.rdz" or initrd("${mnt}2", "$type.rdz");
	_ "cp -f vmlinux$1.aout $dir/$boot/$type.img";
	_ "$setarch kernel$1/src/arch/sparc$1/boot/piggyback $dir/$boot/$type.img kernel$1/boot/System.map $type.rdz";
    } elsif ($type =~ /^tftp(.*)/) {
	my $dir = "/export";
	my $boot = "images";

	_ "mkdir -p $dir/$boot";
	_ "cp -f vmlinux$1.aout $dir/$boot/$type.img";
    } else {
	my $dir = "floppy";
	my ($ltype, $I) = $type =~ /(.*?)(64)/; $ltype ||= $type;

	__ "$sudo umount $mnt 2>/dev/null";
	_ "rm -rf $dir";
	_ "mkdir -p $dir";
	_ "cp -f /boot/fd.b /boot/second.b $dir";
	_ "cp -f vmlinuz$I $dir/vmlinux$I.gz" if $type !~ /blank/;
	-f "$type.rdz" ? _ "cp -f $type.rdz $dir" : initrd("${mnt}2", "$dir/$type.rdz");

	output("$dir/boot.msg", "
Welcome to Linux-Mandrake 7.1

Press <Enter> to install or upgrade a system 7mLinux-Mandrake7m
");

	output("$dir/silo.conf", "
partition=1
default=linux
timeout=100
read-write
message=/boot.msg
image=/vmlinux$I.gz
  label=linux
  initrd=/$type.rdz
  append=\"ramdisk_size=32000 $ltype$corporate\"
");
	_ "genromfs -d $dir -f /dev/ram -A 2048,/.. -a 512 -V \'DrakX boot disk\'";
	_ "$sudo mount -t romfs /dev/ram $mnt";
	_ "silo -r $mnt -F -i /fd.b -b /second.b -C /silo.conf";
	_ "$sudo umount $mnt";
	_ "dd if=/dev/ram of=$type.img bs=1440k count=1";
	_ "sync";
	_ "$sudo mount -t romfs /dev/ram $mnt";
	_ "df $mnt";
    }
}

sub boot_img_ppc {
    my ($mnt, $img) = @_;
    # Here's a quick hack...  just to give the script somethign to do. :)
    # We do not yet have a set way of making bootable images.
    _ "cp $type.rdz $img";
}

sub output {
    my $f = shift;
    local *F;
    open F, "> $f" or die "error writing to $f";
    print F join '', @_;
}
