#!/usr/bin/perl

@ARGV >= 2 or die "usage: $0 <image> all|cdrom|hd|hdcdrom_usb|network|network_gigabit_usb|network_gigabit|network_usb|blank|pcmcia|live|tftp|tftprd\n";

use Config;
use MDK::Common;
Config->import;
my ($arch) = $Config{archname} =~ /(.*?)-/;

my ($img, $type) = @ARGV;

# move stuff to new "kernel" directory
-d 'kernel' or die "directory kernel is missing\n";
rename 'all.kernels', 'kernel/all.kernels';
rename 'all.modules', 'kernel/all.modules';

my $default_append = "ramdisk_size=128000 root=/dev/ram3";
# full acpi support for amd64, enough acpi support for x86 ht, no acpi for others
my $default_acpi = $arch =~ /i.86/ ? "acpi=ht" : $arch =~ /x86_64/ ? "acpi=off" : "acpi=off";
my $default_vga = "vga=788";

my $instdir = "mdk-stage1";
my $mnt = "/tmp/drakx_mnt";
my $mke2fs = "/sbin/mke2fs -q -m 0 -F -s 1";

my $sudo;
if ($>) {
    $sudo = "sudo";
    $ENV{PATH} = "/sbin:/usr/sbin:$ENV{PATH}";
}

sub __ { print @_, "\n"; system(@_) }
sub _ { __ @_; $? and die }

_ "$sudo mkdir $mnt" unless -e $mnt;
_ "$sudo mkdir ${mnt}2" unless -e "${mnt}2";

my $install = ${{
    all => "stage1-full",
    blank => "stage1-full",
    live => "stage1-full",
    tftp => "stage1-full",
    tftprd => "stage1-full",
    pcmcia => "stage1-full",
    network => "stage1-network",
    network_gigabit => "stage1-network",
    network_usb => "stage1-network-usb",
    network_gigabit_usb => "stage1-network-usb",
    cdrom => "stage1-cdrom",
    hd => "stage1-disk",
    hdcdrom_usb => "stage1-medias-usb",
    live64 => "stage1-full",
    tftp64 => "stage1-full",
    tftprd64 => "stage1-full",
    pcmcia64 => "stage1-full",
    network64 => "stage1-network",
    cdrom64 => "stage1-cdrom",
    hd64 => "stage1-disk",
}}{$type} or die;

mkdir "images";
chomp(my $main = `cat kernel/all.kernels/.main`);

if ($img =~ /hd_grub/) {
    hd_grub($img);
    exit 0;
}

my @kernels;
if ($img =~ /blank|pcmcia/) {
    @kernels = $main;
} else {
    @kernels = map { m|kernel/all.kernels/(.*)| } glob('kernel/all.kernels/*');
    $img =~ /usb/ and @kernels = grep { !/2\.2\.14/ } @kernels;  #- 2.2.14 is too old, usb support was not working properly
}

foreach (@kernels) {
    if ($img =~ /rdz$/) {
	initrd($mnt, "$img-$_");
    } else {
	print STDERR "calling boot_img_$arch\n";
	$::{"boot_img_$arch"}->($mnt, "$img-$_", glob("kernel/all.kernels/$_/boot/vmlinu*"));
	rename("$img-$main", $img);
    }
}
if ($arch =~ /x86_64/ && $img =~ /all/) {
    # isolinux is supposed to work on all those new hardware
    isolinux($main, @kernels);
}
if ($arch =~ /i.86/ && $img =~ /all/) {
    isolinux($main, @kernels);

    my ($img, $img_sav) = ("images/cdrom.img-$main", 'images/cdrom.img-sav');
    rename($img, $img_sav);
    $type = 'cdrom';
    $::{"boot_img_$arch"}->($mnt, $img, "kernel/all.kernels/$main/boot/vmlinu*", sub { $_[0] =~ s/\bautomatic=\S+\b//; "$_[0] changedisk" });
    rename($img, 'images/cdrom-changedisk.img');
    rename($img_sav, $img);
}

if (my ($tftpboot) = grep { -e $_ } qw(/tftpboot /var/lib/tftpboot)) {
    system("/bin/cp -f kernel/all.kernels/$main/boot/vmlinu* $tftpboot/vmlinuz 2>/dev/null");
    system("/bin/cp -f images/all.rdz-$main $tftpboot/all.rdz 2>/dev/null");
}

sub install_stripped { _ "strip $_[0]"; _ "$sudo install $_[0] $_[1]" }

sub initrd {
    my ($mnt, $img) = @_;
    my ($ltype, $I) = $type =~ /(.*?)(64)/; $ltype ||= $type;
    my $tmp = "$ENV{HOME}/tmp/initrd";
    my $tar = "$instdir/stage1-data/stage1.tar.bz2";

    __ "$sudo umount $tmp $mnt 2>/dev/null";
    _ "dd if=/dev/zero of=$tmp bs=1k count=" . ($arch =~ /ia64/ ? ($type eq "all" ? 16386 : 16384) : ($type eq "all" ? 5000 : 2000));
    _ "$mke2fs $tmp";
    _ "$sudo mount -t ext2 $tmp $mnt -o loop";

    _ "$sudo tar xjC $mnt -f $tar";
    symlinkf "/tmp/stage2/lib64", "$mnt/lib64" if $arch =~ /x86_64/;
    install_stripped("$instdir/init", "$mnt/sbin");
    install_stripped("$instdir/$install", "$mnt/sbin/stage1");

    if (member($type, qw(network network_gigabit_usb all blank))) {
	install_stripped("$instdir/ppp/pppd-bin", "$mnt/sbin/pppd");
	install_stripped("$instdir/rp-pppoe/pppoe-bin", "$mnt/sbin/pppoe");
	_ "$sudo mknod $mnt/dev/ppp c 108 0";
	_ "$sudo mknod $mnt/dev/ptyp0 c 2 0";
	_ "$sudo mknod $mnt/dev/ttyp0 c 3 0";
    }

    if (member($type, qw(pcmcia all network)) && $arch !~ /ppc|ia64|x86_64/) {
	 _ "$sudo cp -a /etc/pcmcia $mnt/etc";
	 _ "cp $mnt/etc/pcmcia/config /tmp/pcmcia_config_tmp";
	 _ "tools/patch_pcmcia_config.pl /tmp/pcmcia_config_tmp kernel/all.modules/$main/modules.dep";
	 _ "sudo mv /tmp/pcmcia_config_tmp $mnt/etc/pcmcia/config";
    }
    my ($ext) = $img =~ /rdz-(.*)/ or die "bad initrd name ($img)";
    my $modz = "kernel/all.modules$I/$ext";
    if ($type !~ /blank/) {
	_ "$sudo cp -f $modz/${ltype}_modules.mar $mnt/modules/modules$I.mar";
	_ "$sudo cp -f $modz/modules.dep $mnt/modules/";
    }
    _ "$sudo umount $mnt";


# Workaround for vfat-loop bug (quite touchy)
    _ "gzip -9f $tmp";
    _ "cp -f $tmp.gz $img";
    _ "rm -f $tmp.gz";
#    _ "gzip -9 -c $tmp > $img";
#    _ "rm -f $tmp";
}

sub entries_append {
    my ($type) = @_;

    my $automatic = "";
    $automatic = "automatic=method:cdrom" if $type eq "cdrom";
    $automatic = "automatic=method:disk" if $type eq "hd";

    my @simple_entries = (
	linux => $default_vga,
	vgalo => "vga=785",
	vgahi => "vga=791",
	vga16 => "vga16",
	text => "text",
	patch => "patch $default_vga",
	expert => "expert $default_vga",
	rescue => "rescue rw",
    );
    my @entries = (
        (map { $_->[0] => "$automatic $default_acpi $_->[1]" } group_by2(@simple_entries)),
	acpi => "$automatic $default_vga",
	if_(member($type, "cdrom", "all"), oem => "automatic=method:cdrom $default_vga $default_acpi rescue oem rw",),
        if_($type eq "all", all => "pcmcia $default_vga $default_acpi"),
    );

    map { [ $_->[0], "$default_append $_->[1]" ] }
      group_by2(@entries);
}

sub boot_img_i386 {
    my ($mnt, $img, $kernel, $args_callback) = @_;

    __ "$sudo umount $mnt 2>/dev/null";

    if ($type eq "hd") {
	_ "bunzip2 -c $instdir/init-data/msgboot.img.bz2 > $img";
    } elsif ($type eq "all") {
	_ "bunzip2 -c $instdir/init-data/msgboot-graphicallogo-2880.img.bz2 > $img";
    } elsif ($type eq "blank") {
	_ "bunzip2 -c $instdir/init-data/msgboot-blank.img.bz2 > $img";
    } else {
	_ "bunzip2 -c $instdir/init-data/msgboot-graphicallogo.img.bz2 > $img";
    }


    _ "$sudo mount -t vfat -o umask=0 $img $mnt -o loop";
    _ "cat $kernel > $mnt/vmlinuz" if $type !~ /blank/;

    my $rdz = $img; $rdz =~ s/\.img/.rdz/;
    initrd("${mnt}2", $rdz) if !-e $rdz;
    my $short_type = substr($type, 0, 8);
    eval { _ "cp -f $rdz $mnt/$short_type.rdz" };
    if ($@) {
	unlink "$mnt/$short_type.rdz";
	my $avail = (split ' ', `df $mnt`)[-3];
	my $s = int((-s $rdz) / 1024);

	my ($ext) = $img =~ /\.img-(.*)/ or die "bad initrd name ($img)";
	my $dir = "kernel/all.modules/$ext";
	my $pcitable = cat_('/usr/share/ldetect-lst/pcitable');
	my @l = sort { $a <=> $b } map {
	    my ($name) = /(\S+)\.k?o$/ or die "bad file in .mar";
	    my $gz_size = chomp_(`gzip -c $dir/$_ | wc -c`);
	    sprintf "%7d  %6d      %s\n", $gz_size, listlength($pcitable =~ /"$name"/g), $name;
	} split(' ', `mdk-stage1/mar/mar -l $dir/${type}_modules.mar`);
	output('.not-enough-room', "gz size - pcitable - name\n", @l);

	warn sprintf("not enough room for $rdz: need %dKB (available %dKB < needed %dKB)\n", $s - $avail, $avail, $s);
	die qq(check file ".not-enough-room" to see modules size and pcitable usage\n);
    }

    my $timeout = 72;
    output "$mnt/syslinux.cfg",
"default linux
prompt 1
timeout $timeout
display boot.msg
F1 help.msg
F2 advanced.msg
F3 boot.msg
" . join('', map {
    my $args = $args_callback ? $args_callback->($_->[1]) : $_->[1];
"label $_->[0]
  kernel vmlinuz
  append initrd=$short_type.rdz $args
" } entries_append($type));

    _ "sync";
    _ "df $mnt";
}

# alias to x86 variant, slightly bigger with images though
sub boot_img_x86_64 { &boot_img_i386 }

sub boot_img_alpha {
    my ($mnt, $img) = @_;

    __ "$sudo umount $mnt 2>/dev/null";
    _ "dd if=/dev/zero of=$img bs=1k count=1440";
    _ "$mke2fs $img";
    _ "/sbin/e2writeboot $img /boot/bootlx";
    _ "$sudo mount -t ext2 $img $mnt -o loop";
    _ "cp -f vmlinux.gz $mnt" if $type !~ /blank/;
    -f "$type.rdz" ? _ "cp -f $type.rdz $mnt" : initrd("${mnt}2", "$mnt/$type.rdz");

    mkdir "$mnt/etc", 0777;
    output("$mnt/etc/aboot.conf", 
"0:vmlinux.gz initrd=$type.rdz rw $default_append $type
1:vmlinux.gz initrd=$type.rdz rw $default_append text $type
");
    _ "sync";
    _ "df $mnt";
}

sub boot_img_ia64 {
    my ($mnt, $img, $kernel) = @_;
	my $rdz = $img; $rdz =~ s/\.img/.rdz/;

    __ "$sudo umount $mnt 2>/dev/null";
    _ "dd if=/dev/zero of=$img bs=1k count=16384";
    _ "mkdosfs $img";
    _ "$sudo mount -t vfat $img $mnt -o loop,umask=000";
    _ "$sudo cp -f $kernel $mnt/vmlinux";
    _ "cp -f $rdz $mnt/$type.rdz";
    _ "$sudo cp -f tools/ia64/elilo.efi $mnt";
	output("$mnt/elilo.conf", qq(
prompt
timeout=50

image=vmlinux
        label=linux
        root=/dev/ram3
        initrd=$type.rdz
        append=" ramdisk_size=120000"
        read-only

image=vmlinux
        label=rescue
        root=/dev/ram3
        initrd=$type.rdz
        append=" rescue ramdisk_size=120000"
"));
    _ "sync";
    _ "df $mnt";

}

sub boot_img_sparc {
    my ($mnt, $_img) = @_;
    if ($type =~ /^live(.*)/) {
	#- hack to produce directly into /export the needed file for cdrom boot.
	my $dir = "/export";
	my $boot = "boot"; #- non-absolute pathname only!

	_ "mkdir -p $dir/$boot";
	_ "cp -f /boot/cd.b /boot/second.b $dir/$boot";
	_ "cp -f vmlinux$1 $dir/$boot/vmlinux$1";
	-f "live$1.rdz" ? _ "cp -f live$1.rdz $dir/$boot" : initrd("${mnt}2", "$dir/$boot/live$1.rdz");

	output("$dir/$boot/silo.conf", qq(
partition=1
default=linux
timeout=100
read-write
message=/$boot/boot.msg
image="cat /$boot/boot.msg"
  label=1
  single-key
image="cat /$boot/general.msg"
  label=2
  single-key
image="cat /$boot/expert.msg"
  label=3
  single-key
image="cat /$boot/rescue.msg"
  label=4
  single-key
image="cat /$boot/kickit.msg"
  label=5
  single-key
image="cat /$boot/param.msg"
  label=6
  single-key
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=linux
  alias=install
  initrd=/$boot/live.rdz
  append="ramdisk_size=128000 root=/dev/ram3"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=text
  initrd=/$boot/live.rdz
  append="ramdisk_size=128000 text root=/dev/ram3"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=expert
  initrd=/$boot/live.rdz
  append="ramdisk_size=128000 expert root=/dev/ram3"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=ks
  initrd=/$boot/live.rdz
  append="ramdisk_size=128000 ks root=/dev/ram3"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=rescue
  initrd=/$boot/live.rdz
  append="ramdisk_size=128000 rescue rw root=/dev/ram3"
image[sun4u]=/$boot/vmlinux64
  label=linux
  alias=install
  initrd=/$boot/live64.rdz
  append="ramdisk_size=128000 root=/dev/ram3"
image[sun4u]=/$boot/vmlinux64
  label=text
  initrd=/$boot/live64.rdz
  append="ramdisk_size=128000 text root=/dev/ram3"
image[sun4u]=/$boot/vmlinux64
  label=expert
  initrd=/$boot/live64.rdz
  append="ramdisk_size=128000 expert root=/dev/ram3"
image[sun4u]=/$boot/vmlinux64
  label=ks
  initrd=/$boot/live64.rdz
  append="ramdisk_size=128000 ks root=/dev/ram3"
image[sun4u]=/$boot/vmlinux64
  label=rescue
  initrd=/$boot/live64.rdz
  append="ramdisk_size=128000 rescue rw root=/dev/ram3"
"));

	output("$dir/$boot/README", "
To Build a Bootable CD-ROM, try:
  mkisofs -R -o t.iso -s /$boot/silo.conf /export
");
    } elsif ($type =~ /^tftprd(.*)/) {
	my $dir = "/export";
	my $boot = "images";
	my $setarch = $1 ? "sparc64" : "sparc32";

	_ "mkdir -p $dir/$boot";
	-f "$type.rdz" or initrd("${mnt}2", "$type.rdz");
	_ "cp -f vmlinux$1.aout $dir/$boot/$type.img";
	_ "$setarch kernel$1/src/arch/sparc$1/boot/piggyback $dir/$boot/$type.img kernel$1/boot/System.map $type.rdz";
    } elsif ($type =~ /^tftp(.*)/) {
	my $dir = "/export";
	my $boot = "images";

	_ "mkdir -p $dir/$boot";
	_ "cp -f vmlinux$1.aout $dir/$boot/$type.img";
    } else {
	my $dir = "floppy";
	my ($ltype, $I) = $type =~ /(.*?)(64)/; $ltype ||= $type;

	__ "$sudo umount $mnt 2>/dev/null";
	_ "rm -rf $dir";
	_ "mkdir -p $dir";
	_ "cp -f /boot/fd.b /boot/second.b $dir";
	_ "cp -f vmlinuz$I $dir/vmlinux$I.gz" if $type !~ /blank/;
	-f "$type.rdz" ? _ "cp -f $type.rdz $dir" : initrd("${mnt}2", "$dir/$type.rdz");

	output("$dir/boot.msg", "
Welcome to Mandrake Linux 7.1

Press <Enter> to install or upgrade a system 7mMandrake Linux7m
");

	output("$dir/silo.conf", qq(
partition=1
default=linux
timeout=100
read-write
message=/boot.msg
image=/vmlinux$I.gz
  label=linux
  initrd=/$type.rdz
  append="ramdisk_size=128000 $ltype root=/dev/ram3"
"));
	_ "genromfs -d $dir -f /dev/ram -A 2048,/.. -a 512 -V 'DrakX boot disk'";
	_ "$sudo mount -t romfs /dev/ram $mnt";
	_ "silo -r $mnt -F -i /fd.b -b /second.b -C /silo.conf";
	_ "$sudo umount $mnt";
	_ "dd if=/dev/ram of=$type.img bs=1440k count=1";
	_ "sync";
	_ "$sudo mount -t romfs /dev/ram $mnt";
	_ "df $mnt";
    }
}

sub boot_img_ppc {
    my (@_kernels) = @_;
	#- hack to produce directly into /export the needed file for cdrom boot.
	my $dir = "/export";
	my $boot = "boot"; #- non-absolute pathname only!
    _ "rm -rf $dir/$boot"; mkdir "$dir/$boot", 0777;
	foreach (glob("kernel/all.kernels/*")) {
		my $ext = basename($_);
		if ($ext =~ /2.4/) {
			_ "cp $_/boot/vmlinux $dir/$boot/vmlinux";
			_ "cp images/all.rdz-$ext $dir/$boot/all.gz";
		}
		if ($ext =~ /2.2/) {
			_ "cp $_/boot/vmlinux $dir/$boot/vmlinux-2.2";
			_ "cp images/all.rdz-$ext $dir/$boot/all-2.2.gz";
		}
    }
    _ "cp -f /usr/lib/yaboot/yaboot $dir/$boot/yaboot";
	
	output("$dir/$boot/ofboot.b", '<CHRP-BOOT>
<COMPATIBLE>
MacRISC
</COMPATIBLE>
<DESCRIPTION>
Mandrake Linux PPC bootloader
</DESCRIPTION>
<BOOT-SCRIPT>
" screen" output
dev screen
" "(0000000000aa00aa0000aaaaaa0000aa00aaaa5500aaaaaa)" drop 0 8 set-colors
" "(5555555555ff55ff5555ffffff5555ff55ffffff55ffffff)" drop 8 8 set-colors
device-end
3 to foreground-color
0 to background-color
" "(0C)" fb8-write drop
" Booting Mandrake Linux PPC..." fb8-write drop 100 ms
boot cd:2,\\\\yaboot
</BOOT-SCRIPT>
<OS-BADGE-ICONS>
1010
000000000000F8FEACF6000000000000
0000000000F5FFFFFEFEF50000000000
00000000002BFAFEFAFCF70000000000
0000000000F65D5857812B0000000000
0000000000F5350B2F88560000000000
0000000000F6335708F8FE0000000000
00000000005600F600F5FD8100000000
00000000F9F8000000F5FAFFF8000000
000000008100F5F50000F6FEFE000000
000000F8F700F500F50000FCFFF70000
00000088F70000F50000F5FCFF2B0000
0000002F582A00F5000008ADE02C0000
00090B0A35A62B0000002D3B350A0000
000A0A0B0B3BF60000505E0B0A0B0A00
002E350B0B2F87FAFCF45F0B2E090000
00000007335FF82BF72B575907000000
000000000000ACFFFF81000000000000
000000000081FFFFFFFF810000000000
0000000000FBFFFFFFFFAC0000000000
000000000081DFDFDFFFFB0000000000
000000000081DD5F83FFFD0000000000
000000000081DDDF5EACFF0000000000
0000000000FDF981F981FFFF00000000
00000000FFACF9F9F981FFFFAC000000
00000000FFF98181F9F981FFFF000000
000000ACACF981F981F9F9FFFFAC0000
000000FFACF9F981F9F981FFFFFB0000
00000083DFFBF981F9F95EFFFFFC0000
005F5F5FDDFFFBF9F9F983DDDD5F0000
005F5F5F5FDD81F9F9E7DF5F5F5F5F00
0083DD5F5F83FFFFFFFFDF5F835F0000
000000FBDDDFACFBACFBDFDFFB000000
000000000000FFFFFFFF000000000000
0000000000FFFFFFFFFFFF0000000000
0000000000FFFFFFFFFFFF0000000000
0000000000FFFFFFFFFFFF0000000000
0000000000FFFFFFFFFFFF0000000000
0000000000FFFFFFFFFFFF0000000000
0000000000FFFFFFFFFFFFFF00000000
00000000FFFFFFFFFFFFFFFFFF000000
00000000FFFFFFFFFFFFFFFFFF000000
000000FFFFFFFFFFFFFFFFFFFFFF0000
000000FFFFFFFFFFFFFFFFFFFFFF0000
000000FFFFFFFFFFFFFFFFFFFFFF0000
00FFFFFFFFFFFFFFFFFFFFFFFFFF0000
00FFFFFFFFFFFFFFFFFFFFFFFFFFFF00
00FFFFFFFFFFFFFFFFFFFFFFFFFF0000
000000FFFFFFFFFFFFFFFFFFFF000000
</OS-BADGE-ICONS>
</CHRP-BOOT>
');

	output("$dir/$boot/yaboot.conf", '
init-message = "\nWelcome to Mandrake Linux PPC!\nHit <TAB> for boot options.\n\n"
timeout = 150
default = install-gui
message=cd:,\\\\yaboot.msg

image = cd:,\\\\vmlinux
    label = install-gui
    root = /dev/ram3
    initrd = cd:,\\\\all.gz
    initrd-size = 34000

image = cd:,\\\\vmlinux-2.2
    label = install-gui-2.2
    root = /dev/ram3
    initrd = cd:,\\\\all-2.2.gz
    initrd-size = 34000

image = cd:,\\\\vmlinux
    label = install-text
    root = /dev/ram3
    initrd = cd:,\\\\all.gz
    initrd-size = 34000
    append = " text video=ofonly"

image = cd:,\\\\vmlinux-2.2
    label = install-text-2.2
    root = /dev/ram3
    initrd = cd:,\\\\all-2.2.gz
    initrd-size = 34000
    append = " text video=ofonly"

image = cd:,\\\\vmlinux
    label = install-gui-old
    root = /dev/ram3
    initrd = cd:,\\\\all.gz
    initrd-size = 34000
    append = " gui-old video=ofonly"

image = cd:,\\\\vmlinux-2.2
    label = install-gui-old-2.2
    root = /dev/ram3
    initrd = cd:,\\\\all-2.2.gz
    initrd-size = 34000
    append = " gui-old video=ofonly"

image = enet:0,vmlinux
    label = install-net
    root = /dev/ram3
    initrd = enet:0,all.gz
    initrd-size = 34000
    append = " video=ofonly"

image = enet:0,vmlinux-2.2
    label = install-net-2.2
    root = /dev/ram3
    initrd = enet:0,all-2.2.gz
    initrd-size = 34000
    append = " video=ofonly"
	
image = enet:0,vmlinux
    label = install-net-text
    root = /dev/ram3
    initrd = enet:0,all.gz
    initrd-size = 34000
    append = " text video=ofonly"

image = enet:0,vmlinux-2.2
    label = install-net-text-2.2
    root = /dev/ram3
    initrd = enet:0,all-2.2.gz
    initrd-size = 34000
    append = " text video=ofonly"
	
image = cd:,\\\\vmlinux
    label = rescue
    root = /dev/ram3
    initrd = cd:,\\\\all.gz
    initrd-size = 34000
    append = " rescue video=ofonly"    

image = enet:0,vmlinux
    label = rescue-net
    root = /dev/ram3
    initrd = enet:0,all.gz
    initrd-size = 34000
    append = " rescue video=ofonly"    
');

	output("$dir/$boot/yaboot.msg", '
Thanks for choosing Mandrake Linux PPC.  The following is a short
explanation of the various options for booting the install CD.

All options ending with "2.2" will use the 2.2.20-9mdkBOOT kernel.
The default syntax with no suffix uses the 2.4.18-4mdkBOOT kernel.
The default if you just hit enter is "install-gui".

install-gui:        	uses XFree86 fbdev mode
install-text:       	text based install
install-gui-old:    	old Xpmac gui
install-net:            allows you to use a minimal boot CD,
                        pulling the rest of the install from
                        a network server
install-net-text:       text mode network install
rescue:                 boots the rescue image
rescue-net:             boots the rescue image from a network server

');

}

sub isolinux {
    my ($main, @kernels) = @_;
    @kernels = ($main, grep { $_ ne $main } @kernels);
    _ "rm -rf isolinux"; mkdir "isolinux", 0777;
    my $i = 0;
    foreach (@kernels) {
	mkdir "isolinux/alt$i", 0777;
	my ($kernel) = glob("kernel/all.kernels/$_/boot/vmlinu*");
	_ "cp $kernel isolinux/alt$i/vmlinuz";
	_ "cp images/all.rdz-$_ isolinux/alt$i/all.rdz";
	$i++;
    }
    if (-e "isolinux-graphic.bmp") {
	#- change here for newer picture isolinux-graphic.bmp and newer parameters.
	#- for old style pictures (9.1 and previous)
	# lilo-bmp2mdk mode:0x103 progress:425,173,16,7,64+21 clear:600,800,64+59 pos:0,0 <isolinux-graphic.bmp >isolinux/boot.msg
	#- for current 9.2 pictures.
	_ "lilo-bmp2mdk mode:0x103 progress:405,166,4,14,64+26 clear:600,800,64+127 pos:0,0 <isolinux-graphic.bmp >isolinux/boot.msg";
    }
    _ "cp /usr/lib/syslinux/isolinux.bin isolinux/isolinux.bin";
    output "isolinux/isolinux.cfg", "
default linux
prompt 1
timeout 150
" . (-e "isolinux/boot.msg" ? "display boot.msg" : "display help.msg") . "
F1 help.msg
F2 advanced.msg
" . (-e "isolinux/boot.msg" && "F3 boot.msg") . "
" . join('', map {
"label $_->[0]
  kernel alt0/vmlinuz
  append initrd=alt0/all.rdz $_->[1] automatic=method:cdrom
" } entries_append('all'))
  . join('', map_index {
"label alt$::i
  kernel alt$::i/vmlinuz
  append initrd=alt$::i/all.rdz $default_append $default_acpi $default_vga
" } @kernels);

    output "isolinux/help.msg", (-e "isolinux/boot.msg" && pack "C*", 0x0E, 0x80, 0x03, 0x00) .
"
                  0aWelcome to 09Mandrake Linux0a install help07

In most cases, the best way to get started is to simply press the 0e<Enter>07 key.
If you experience problems with standard install, try one of the following 
install types (type the highlighted text and press 0e<Enter>07):

 o  0fvgalo07 for low resolution graphical installation.
 o  0ftext07 for text installation instead of the graphical one.
 o  0flinux07 for standard graphical installation at normal resolution.
 o  0fexpert07 for expert graphical installation at normal resolution.


To use this CD to repair an already installed system type 0frescue07
followed by 0e<Enter>07.

You can also pass some 0f<specific kernel options>07 to the Linux kernel. 
For example, try 0flinux mem=128M07 if your system has 128Mb of RAM but the default
kernel ($main) does not detect it correctly.
0cNOTE07: You cannot pass options to modules (SCSI, ethernet card) or devices
such as CD-ROM drives in this way. If you need to do so, use expert mode.

" . (-e "isolinux/boot.msg" ?
     "0c[F1-Help] [F2-Advanced Help] [F3-Main]07" :
     "0c[F1-Help] [F2-Advanced Help]07") . "\n";

    output "isolinux/advanced.msg", (-e "isolinux/boot.msg" && pack "C*", 0x0E, 0x80, 0x03, 0x00) .
"
The following install types may be used instead of previously notified :
 o  0fvgahi07 for high resolution graphical installation.
 o  0fvga1607 for 640x480 in 16 colors graphical installation.

The following options may be added on the command line :
 o  0freadonly=107 to disable editing disk partitions.
 o  0fdisplay=ackbar:007 to export display to 09ackbar07 machine screen 0 during
    installation.
 o  0fnoauto07 to disable automatic detection (generally used with 0fexpert07).
 o  0fsecurity=n07 to set security level to value 09n07.
 o  0fupdatemodules07 to use the special update floppy containing modules updates.
 o  0fpatch07 to use a patch from the floppy (file named 09patch.pl07).
 o  0fauto_install=floppy07 to enable auto_install using 09auto_inst.cfg07 file on the
    floppy.

You can choose the following kernels :
" . join('', map_index { " o  0falt$::i07 is kernel $_\n" } @kernels) . "
" . (-e "isolinux/boot.msg" ?
     "0c[F1-Help] [F2-Advanced Help] [F3-Main]07" :
     "0c[F1-Help] [F2-Advanced Help]07") . "\n";
}

sub hd_grub {
    my ($img) = @_;
    my $mapfile = '/tmp/device.map.tmp';

    my @grub_files = map { "/boot/grub/$_" } qw(stage1 stage2);
    my $size = 40_000 + sum(map { -s $_ } @grub_files);

    __ "$sudo umount $mnt 2>/dev/null";
    _ "dd if=/dev/zero of=$img bs=1 count=$size";
    _ "mkdosfs $img";
    _ "$sudo mount -t vfat -o umask=0 $img $mnt -o loop";
    _ "cp @grub_files $mnt";

    output("$mnt/menu.lst", <<EOF);
timeout 0
default 0
fallback 1

title Mandrake Install

root (hd0,0)
kernel /cooker/isolinux/alt0/vmlinuz $default_append $default_acpi $default_vga automatic=method:disk
initrd /cooker/isolinux/alt0/all.rdz

title Help

pause To display the help, press <space> until you reach "HELP END"
pause .
pause To specify the location of your mirror of mandrake,
pause choose "Mandrake Install", and press "e".
pause Then change "root (hd0,0)". FYI:
pause - (hd0,0) is the first partition on first bios hard drive (usually hda1)
pause - (hd0,4) is the first extended partition (usually hda5)
pause - (hd1,0) is the first partition on second bios hard drive
pause Replace /cooker to suits the directory where your mirror is
pause .
pause HELP END
EOF

    _ "$sudo umount $mnt";

    output($mapfile, "(fd0) $img\n");

    open(my $G, "| grub --device-map=$mapfile --batch");
    print $G <<EOF;
root (fd0)
install /stage1 d (fd0) /stage2 p /menu.lst
quit
EOF
    close $G;
    unlink $mapfile;
}
