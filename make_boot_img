#!/usr/bin/perl

use Config;
use MDK::Common;
Config->import;
my ($arch) = $Config{archname} =~ /(.*?)-/;

my $default_append = '';
# full acpi support for x86_64, enough acpi support for x86 ht, no acpi for others
my $default_acpi = $arch =~ /i.86/ ? "acpi=ht" : $arch =~ /x86_64/ ? "" : "acpi=off";
my $default_vga = "vga=788 splash=silent";
my $timeout = 150;

my $instdir = "mdk-stage1";
my $tmp_mnt = '/tmp/drakx_mnt';
my $tmp_mnt_initrd = '/tmp/drakx_mnt2';

my $sudo;
if ($>) {
    $sudo = "sudo";
    $ENV{PATH} = "/sbin:/usr/sbin:$ENV{PATH}";
}

sub __ { print @_, "\n"; system(@_) }
sub _ { __ @_; $? and die }
sub mke2fs { 
    my ($f) = @_;
    _ "/sbin/mke2fs -q -m 0 -F -s 1 $f";
    _ "/sbin/tune2fs -c 0 -U clear -T 1970010101 $f";
}

_ "$sudo mkdir -p $tmp_mnt $tmp_mnt_initrd";
mkdir "images";

my $main = chomp_(cat_('kernel/RPMS/.main'));
my $main_BOOT = chomp_(cat_('kernel/RPMS/.main-BOOT'));
my @kernels = grep { !/xbox/ } all('kernel/all.kernels');
my @kernels_BOOT = grep { /BOOT/ } @kernels;

my @all_images = (
		  if_($arch =~ /i.86|x86_64/, 'cdrom.img', 'cdrom-changedisk.img', 'pcmcia.img', 'isolinux', 'boot.iso', 'all.img', 'hd_grub.img', 'network.img', 'network_drivers.img'),
		  if_($arch =~ /ia64/, 'all.img'),
		  if_($arch =~ /ppc/, 'all.img'),
		 );

my @images = @ARGV ? @ARGV : map { "images/$_" } @all_images;

if (any { /move/ } @images) {
    -e "$instdir/init-move" or die "ERROR: $instdir not built for move\n";
} else {
    -e "$instdir/init-move" and die "ERROR: $instdir built for move\n";
}

foreach my $img (@images) {
    my ($type, $I, $extension) = $img =~ m!([^/]*)(64)?\.([^.]*)$!;

    if ($img =~ /hd_grub/) {
	hd_grub($img);
    } elsif ($img =~ /isolinux/) {
	isolinux($main, @kernels);

	if (my ($tftpboot) = grep { -e $_ } qw(/tftpboot /var/lib/tftpboot)) {
	    system("/bin/cp -f isolinux/alt0/* $tftpboot");
	}
    } elsif ($img =~ /move/) {
	isolinux_move($main);

	if (my ($tftpboot) = grep { -e $_ } qw(/tftpboot /var/lib/tftpboot)) {
	    system("/bin/cp -f move/isolinux/* $tftpboot/move 2>/dev/null");
	}
    } elsif ($img =~ /boot.iso/) {
	boot_iso($img, \@kernels);
    } elsif ($img =~ /drivers/) {
	drivers($type, $I, "$img-$_") foreach @kernels_BOOT;
	rename("$img-$main_BOOT", $img);
    } elsif ($extension eq 'rdz') {
	initrd($tmp_mnt_initrd, $type, $I, "$img-$_") foreach @kernels;
    } elsif ($extension eq 'img') {
	print STDERR "calling boot_img_$arch for $img\n";
	$::{"boot_img_$arch"}->($type, $I, "$img-$_", "kernel/all.kernels/$_/vmlinuz") foreach $type eq 'all' ? @kernels : @kernels_BOOT;
	rename("$img-$main", $img) or rename("$img-$main_BOOT", $img);
    } else {
	die "unknown image $img";
    }
}

sub syslinux_color {
    "0" . {
	default => '7',
	blue    => '9',
	green   => 'a',
	red     => 'c',
	yellow  => 'e',
	white   => 'f',
    }->{$_[0]} || die "unknown color $_[0]\n";
}

sub syslinux_msg { 
    my ($msg_xml_file, @more_text) = @_;

    require XML::Parser;

    sub xml_tree2syslinux {
	my ($current_color, $tree) = @_;
	my (undef, @l) = @$tree;
	join('', map {
	    my ($type, $val) = @$_;
	    if ($type eq '0') {
		$val;
	    } else {
		syslinux_color($type) . xml_tree2syslinux($type, $val) . syslinux_color($current_color);
	    }
	} group_by2(@l));
    }

    print "parsing $msg_xml_file\n";
    my $tree = XML::Parser->new(Style => 'Tree')->parsefile($msg_xml_file);
    $tree->[0] eq 'document' or die "bad file $msg_xml_file\n";
    my $text = xml_tree2syslinux('default', $tree->[1]);

    pack("C*", 0x0E, 0x80, 0x03, 0x00) . ""
      . $text . join('', @more_text)
      . "\n" . syslinux_color('red') . "[F1-Help] [F2-Advanced Help] [F3-Main]" . syslinux_color('default') . "\n";
}

sub syslinux_cfg {
    my (@entries) = @_;

    my $header = <<EOF;
default linux
prompt 1
timeout $timeout
display boot.msg
F1 help.msg
F2 advanced.msg
F3 boot.msg
EOF

    my @l = map {
	$_->{append} =~ s/\s+/ /g;
	"label $_->{label}\n" .
	"  kernel $_->{kernel}\n" .
	($_->{initrd} ? "  append initrd=$_->{initrd} $_->{append}\n" : '');
    } @entries;

    $header . join('', @l);
}

sub install_stripped { _ "strip $_[0]"; _ "$sudo install $_[0] $_[1]" }

sub initrd {
    my ($mnt, $type, $I, $img, $o_raw_stage1_tree_kind) = @_;
    my $tmp = "$ENV{HOME}/tmp/initrd";
    my $tar = "$instdir/stage1-data/stage1$o_raw_stage1_tree_kind.tar.bz2";

    __ "$sudo umount $tmp $mnt 2>/dev/null";
    _ "dd if=/dev/zero of=$tmp bs=1k count=" . ($arch =~ /ia64/ || $type eq "all" ? 16384 : 2000);
    mke2fs($tmp);
    _ "$sudo mount -t ext2 $tmp $mnt -o loop";

    _ "$sudo tar xjC $mnt -f $tar";
    symlinkf "/tmp/stage2/lib64", "$mnt/lib64" if $arch =~ /x86_64/;

    {
	my $install = ${{
	    network => "stage1-network",
	    cdrom => "stage1-cdrom",
	}}{$type} || 'stage1-full';
	install_stripped("$instdir/init", "$mnt/sbin");
	install_stripped("$instdir/$install", "$mnt/sbin/stage1");
    }

    if (member($type, qw(network all))) {
	install_stripped("$instdir/ppp/pppd-bin", "$mnt/sbin/pppd");
	install_stripped("$instdir/rp-pppoe/pppoe-bin", "$mnt/sbin/pppoe");
	_ "$sudo mknod $mnt/dev/ppp c 108 0";
	_ "$sudo mknod $mnt/dev/ptyp0 c 2 0";
	_ "$sudo mknod $mnt/dev/ttyp0 c 3 0";
    }

    if (member($type, qw(pcmcia all network)) && $arch !~ /ppc|ia64/) {
	 _ "$sudo cp -a /etc/pcmcia $mnt/etc";
	 _ "cp $mnt/etc/pcmcia/config /tmp/pcmcia_config_tmp";
	 _ "tools/patch_pcmcia_config.pl /tmp/pcmcia_config_tmp kernel/all.kernels/$main/modules.dep";
	 _ "sudo mv /tmp/pcmcia_config_tmp $mnt/etc/pcmcia/config";
    }
    my ($ext) = $img =~ /rdz-(.*)/ or die "bad initrd name ($img)";
    my $modz = "kernel/all.kernels$I/$ext";
    if ($type eq 'all') {
	__ "$sudo tar xC $mnt/modules -f $modz/${type}_modules.tar";
    } else {
	_ "$sudo cp -f $modz/${type}_modules.mar $mnt/modules/modules$I.mar";
    }
    _ "$sudo cp -f $modz/modules.dep $mnt/modules/";
    _ "$sudo cp -f /sbin/sash $mnt/tmp/sh" if $type eq 'all' && $ENV{DEBUGSTAGE1};
    _ "$sudo umount $mnt";

# Workaround for vfat-loop bug (quite touchy)
    _ "gzip -9f $tmp";
    _ "cp -f $tmp.gz $img";
    _ "rm -f $tmp.gz";
#    _ "gzip -9 -c $tmp > $img";
#    _ "rm -f $tmp";
}

sub entries_append {
    my ($type) = @_;

    my $automatic = $type =~ /cdrom/ ? 'automatic=method:cdrom ' : '';
    $automatic .= 'changedisk ' if $type =~ /changedisk/;

    my @simple_entries = (
	linux => $default_vga,
	vgalo => "vga=785",
	vgahi => "vga=791",
	vga16 => "vga16",
	text => "text",
	patch => "patch $default_vga",
	rescue => "rescue",
    );
    my @entries = (
        (map { $_->[0] => "$automatic$default_acpi $_->[1]" } group_by2(@simple_entries)),
	acpi => "$automatic$default_vga",
    );

    map { { label => $_->[0], append => "$default_append $_->[1]" } }
      group_by2(@entries);
}

sub syslinux_cfg_all {
    my ($type) = @_;

    syslinux_cfg(
	(map {
	    { kernel => 'alt0/vmlinuz', initrd => 'alt0/all.rdz', %$_ };
	} entries_append($type)),
	(map_index {
	    { label => "alt$::i", kernel => "alt$::i/vmlinuz", initrd => "alt$::i/all.rdz", 
	      append => "$default_append $default_acpi $default_vga" };
	} @kernels),
	{ label => 'memtest', kernel => 'test/memtest.bin' },
    );
}
sub remove_ending_zero {
    my ($img) = @_;
    _(q(perl -0777 -pi -e 's/\0+$//' ) . $img);
}

sub boot_img_i386 {
    my ($type, $I, $img, $kernel) = @_;

    __ "$sudo umount $tmp_mnt 2>/dev/null";

    _ "dd if=/dev/zero of=$img bs=1k count=" . ($type eq 'all' ? 7000 : 1440);
    my $mk_options = $type eq 'all' ? '' : '-f 1 -r 16 -s 2'; # keep the FAT bookkeeping as small as possible
    _ "mkdosfs $mk_options $img";
    _ "$sudo syslinux-graphic $img";

    _ "$sudo mount -t vfat -o umask=0 $img $tmp_mnt -o loop";
    _ "cat $kernel > $tmp_mnt/vmlinuz";
    _ "lilo-bmp2mdk file:isolinux-graphic" . ($type eq 'all' ? '' : '-simple') . ".bmp >$tmp_mnt/boot.msg";

    output("$tmp_mnt/help.msg", syslinux_msg('help.msg.xml'));
    output("$tmp_mnt/advanced.msg", syslinux_msg('advanced.msg.xml'));

    (my $rdz = $img) =~ s/\.img/.rdz/;
    (my $initrd_type = $type) =~ s/-changedisk//;
    initrd($tmp_mnt_initrd, $initrd_type, $I, $rdz);
    my $short_type = substr($type, 0, 8);

    output("$tmp_mnt/syslinux.cfg", 
	   syslinux_cfg(map {
			    { kernel => 'vmlinuz', initrd => "$short_type.rdz", %$_ };
			} entries_append($type)));

    eval { _ "cp -f $rdz $tmp_mnt/$short_type.rdz" };
    if ($@) {
	#- argh not enough room, try to suggest how to solve this
	unlink "$tmp_mnt/$short_type.rdz";
	my $avail = (split ' ', `df $tmp_mnt`)[-3];
	my $s = int((-s $rdz) / 1024);

	my ($ext) = $img =~ /\.img-(.*)/ or die "bad initrd name ($img)";
	my $dir = "kernel/all.kernels/$ext";
	my $pcitable = cat_('/usr/share/ldetect-lst/pcitable');
	my @l = sort { $a <=> $b } map {
	    my ($name) = /(\S+)\.k?o$/ or die "bad file in .mar";
	    my $gz_size = chomp_(`tar xOf $dir/all_modules.tar $_ | gzip | wc -c`);
	    sprintf "%7d  %6d      %s\n", $gz_size, listlength($pcitable =~ /"$name"/g), $name;
	} split(' ', `mdk-stage1/mar/mar -l $dir/${initrd_type}_modules.mar`);
	output('.not-enough-room', "gz size - pcitable - name\n", @l);

	warn sprintf("not enough room for $rdz: need %dKB (available %dKB < needed %dKB)\n", $s - $avail, $avail, $s);
	die qq(check file ".not-enough-room" to see modules size and pcitable usage\n);
    }
    unlink $rdz;

    _ "sync";
    _ "df $tmp_mnt";
    _ "$sudo umount $tmp_mnt";
}

# alias to x86 variant, slightly bigger with images though
sub boot_img_x86_64 { &boot_img_i386 }

sub boot_img_alpha {
    my ($type, $I, $img) = @_;

    __ "$sudo umount $tmp_mnt 2>/dev/null";
    _ "dd if=/dev/zero of=$img bs=1k count=1440";
    mke2fs($img);
    _ "/sbin/e2writeboot $img /boot/bootlx";
    _ "$sudo mount -t ext2 $img $tmp_mnt -o loop";
    _ "cp -f vmlinux.gz $tmp_mnt";
    -f "$type.rdz" ? _ "cp -f $type.rdz $tmp_mnt" : initrd($tmp_mnt_initrd, $type, $I, "$tmp_mnt/$type.rdz");

    mkdir "$tmp_mnt/etc", 0777;
    output("$tmp_mnt/etc/aboot.conf", 
"0:vmlinux.gz initrd=$type.rdz rw $default_append $type
1:vmlinux.gz initrd=$type.rdz rw $default_append text $type
");
    _ "sync";
    _ "df $tmp_mnt";
}

sub boot_img_ia64 {
    my ($type, $_I, $img, $kernel) = @_;
	my $rdz = $img; $rdz =~ s/\.img/.rdz/;

    __ "$sudo umount $tmp_mnt 2>/dev/null";
    _ "dd if=/dev/zero of=$img bs=1k count=16384";
    _ "mkdosfs $img";
    _ "$sudo mount -t vfat $img $tmp_mnt -o loop,umask=000";
    _ "$sudo cp -f $kernel $tmp_mnt/vmlinux";
    _ "cp -f $rdz $tmp_mnt/$type.rdz";
    _ "$sudo cp -f tools/ia64/elilo.efi $tmp_mnt";
	output("$tmp_mnt/elilo.conf", qq(
prompt
timeout=50

image=vmlinux
        label=linux
        initrd=$type.rdz
        append=" ramdisk_size=120000"
        read-only

image=vmlinux
        label=rescue
        initrd=$type.rdz
        append=" rescue ramdisk_size=120000"
"));
    _ "sync";
    _ "df $tmp_mnt";

}

sub boot_img_sparc {
    my ($type, $I, $_img) = @_;
    if ($type =~ /^live(.*)/) {
	#- hack to produce directly into /export the needed file for cdrom boot.
	my $dir = "/export";
	my $boot = "boot"; #- non-absolute pathname only!

	_ "mkdir -p $dir/$boot";
	_ "cp -f /boot/cd.b /boot/second.b $dir/$boot";
	_ "cp -f vmlinux$1 $dir/$boot/vmlinux$1";
	-f "live$1.rdz" ? _ "cp -f live$1.rdz $dir/$boot" : initrd($tmp_mnt_initrd, $type, $I, "$dir/$boot/live$1.rdz");

	output("$dir/$boot/silo.conf", qq(
partition=1
default=linux
timeout=100
read-write
message=/$boot/boot.msg
image="cat /$boot/boot.msg"
  label=1
  single-key
image="cat /$boot/general.msg"
  label=2
  single-key
image="cat /$boot/expert.msg"
  label=3
  single-key
image="cat /$boot/rescue.msg"
  label=4
  single-key
image="cat /$boot/kickit.msg"
  label=5
  single-key
image="cat /$boot/param.msg"
  label=6
  single-key
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=linux
  alias=install
  initrd=/$boot/live.rdz
  append="ramdisk_size=128000"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=text
  initrd=/$boot/live.rdz
  append="ramdisk_size=128000 text"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=expert
  initrd=/$boot/live.rdz
  append="ramdisk_size=128000 expert"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=ks
  initrd=/$boot/live.rdz
  append="ramdisk_size=128000 ks"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=rescue
  initrd=/$boot/live.rdz
  append="ramdisk_size=128000 rescue"
image[sun4u]=/$boot/vmlinux64
  label=linux
  alias=install
  initrd=/$boot/live64.rdz
  append="ramdisk_size=128000"
image[sun4u]=/$boot/vmlinux64
  label=text
  initrd=/$boot/live64.rdz
  append="ramdisk_size=128000 text"
image[sun4u]=/$boot/vmlinux64
  label=expert
  initrd=/$boot/live64.rdz
  append="ramdisk_size=128000 expert"
image[sun4u]=/$boot/vmlinux64
  label=ks
  initrd=/$boot/live64.rdz
  append="ramdisk_size=128000 ks"
image[sun4u]=/$boot/vmlinux64
  label=rescue
  initrd=/$boot/live64.rdz
  append="ramdisk_size=128000 rescue"
"));

	output("$dir/$boot/README", "
To Build a Bootable CD-ROM, try:
  mkisofs -R -o t.iso -s /$boot/silo.conf /export
");
    } elsif ($type =~ /^tftprd(.*)/) {
	my $dir = "/export";
	my $boot = "images";
	my $setarch = $1 ? "sparc64" : "sparc32";

	_ "mkdir -p $dir/$boot";
	-f "$type.rdz" or initrd($tmp_mnt_initrd, $type, $I, "$type.rdz");
	_ "cp -f vmlinux$1.aout $dir/$boot/$type.img";
	_ "$setarch kernel$1/src/arch/sparc$1/boot/piggyback $dir/$boot/$type.img kernel$1/boot/System.map $type.rdz";
    } elsif ($type =~ /^tftp(.*)/) {
	my $dir = "/export";
	my $boot = "images";

	_ "mkdir -p $dir/$boot";
	_ "cp -f vmlinux$1.aout $dir/$boot/$type.img";
    } else {
	my $dir = "floppy";
	__ "$sudo umount $tmp_mnt 2>/dev/null";
	_ "rm -rf $dir";
	_ "mkdir -p $dir";
	_ "cp -f /boot/fd.b /boot/second.b $dir";
	_ "cp -f vmlinuz$I $dir/vmlinux$I.gz";
	-f "$type.rdz" ? _ "cp -f $type.rdz $dir" : initrd($tmp_mnt_initrd, $type, $I, "$dir/$type.rdz");

	output("$dir/boot.msg", "
Welcome to Mandriva Linux 7.1

Press <Enter> to install or upgrade a system 7mMandriva Linux7m
");

	output("$dir/silo.conf", qq(
partition=1
default=linux
timeout=100
read-write
message=/boot.msg
image=/vmlinux$I.gz
  label=linux
  initrd=/$type.rdz
  append="ramdisk_size=128000 $type"
"));
	_ "genromfs -d $dir -f /dev/ram -A 2048,/.. -a 512 -V 'DrakX boot disk'";
	_ "$sudo mount -t romfs /dev/ram $tmp_mnt";
	_ "silo -r $tmp_mnt -F -i /fd.b -b /second.b -C /silo.conf";
	_ "$sudo umount $tmp_mnt";
	_ "dd if=/dev/ram of=$type.img bs=1440k count=1";
	_ "sync";
	_ "$sudo mount -t romfs /dev/ram $tmp_mnt";
	_ "df $tmp_mnt";
    }
}

sub boot_img_ppc() {
	#- hack to produce directly into /export the needed file for cdrom boot.
	my $dir = "/export";
	my $boot = "boot"; #- non-absolute pathname only!
    _ "rm -rf $dir/$boot"; mkdir "$dir/$boot", 0777;
	foreach (glob("kernel/all.kernels/*")) {
		my $ext = basename($_);
		if ($ext =~ /power4/) {
			_ "cp $_/boot/vmlinuz-$ext* $dir/$boot/vmlinux-power4";
			_ "cp images/all.rdz-$ext $dir/$boot/all-power4.gz";
		}
		elsif ($ext =~ /2.6/) {
			_ "cp $_/boot/vmlinuz-$ext $dir/$boot/vmlinux";
			_ "cp images/all.rdz-$ext $dir/$boot/all.gz";
		}
		elsif ($ext =~ /2.4/) {
			_ "cp $_/boot/vmlinux $dir/$boot/vmlinux-2.4";
			_ "cp images/all.rdz-$ext $dir/$boot/all-2.4.gz";
		}
    }
    _ "cp -f /usr/lib/yaboot/yaboot $dir/$boot/yaboot";
	
	output("$dir/$boot/ofboot.b", '<CHRP-BOOT>
<COMPATIBLE>
MacRISC
</COMPATIBLE>
<DESCRIPTION>
Mandriva Linux PPC bootloader
</DESCRIPTION>
<BOOT-SCRIPT>
" screen" output
load-base release-load-area
dev screen
" "(0000000000aa00aa0000aaaaaa0000aa00aaaa5500aaaaaa)" drop 0 8 set-colors
" "(5555555555ff55ff5555ffffff5555ff55ffffff55ffffff)" drop 8 8 set-colors
device-end
3 to foreground-color
0 to background-color
" "(0C)" fb8-write drop
" Booting Mandriva Linux PPC..." fb8-write drop 100 ms
boot cd:,\boot\yaboot
</BOOT-SCRIPT>
<OS-BADGE-ICONS>
1010
000000000000F8FEACF6000000000000
0000000000F5FFFFFEFEF50000000000
00000000002BFAFEFAFCF70000000000
0000000000F65D5857812B0000000000
0000000000F5350B2F88560000000000
0000000000F6335708F8FE0000000000
00000000005600F600F5FD8100000000
00000000F9F8000000F5FAFFF8000000
000000008100F5F50000F6FEFE000000
000000F8F700F500F50000FCFFF70000
00000088F70000F50000F5FCFF2B0000
0000002F582A00F5000008ADE02C0000
00090B0A35A62B0000002D3B350A0000
000A0A0B0B3BF60000505E0B0A0B0A00
002E350B0B2F87FAFCF45F0B2E090000
00000007335FF82BF72B575907000000
000000000000ACFFFF81000000000000
000000000081FFFFFFFF810000000000
0000000000FBFFFFFFFFAC0000000000
000000000081DFDFDFFFFB0000000000
000000000081DD5F83FFFD0000000000
000000000081DDDF5EACFF0000000000
0000000000FDF981F981FFFF00000000
00000000FFACF9F9F981FFFFAC000000
00000000FFF98181F9F981FFFF000000
000000ACACF981F981F9F9FFFFAC0000
000000FFACF9F981F9F981FFFFFB0000
00000083DFFBF981F9F95EFFFFFC0000
005F5F5FDDFFFBF9F9F983DDDD5F0000
005F5F5F5FDD81F9F9E7DF5F5F5F5F00
0083DD5F5F83FFFFFFFFDF5F835F0000
000000FBDDDFACFBACFBDFDFFB000000
000000000000FFFFFFFF000000000000
0000000000FFFFFFFFFFFF0000000000
0000000000FFFFFFFFFFFF0000000000
0000000000FFFFFFFFFFFF0000000000
0000000000FFFFFFFFFFFF0000000000
0000000000FFFFFFFFFFFF0000000000
0000000000FFFFFFFFFFFFFF00000000
00000000FFFFFFFFFFFFFFFFFF000000
00000000FFFFFFFFFFFFFFFFFF000000
000000FFFFFFFFFFFFFFFFFFFFFF0000
000000FFFFFFFFFFFFFFFFFFFFFF0000
000000FFFFFFFFFFFFFFFFFFFFFF0000
00FFFFFFFFFFFFFFFFFFFFFFFFFF0000
00FFFFFFFFFFFFFFFFFFFFFFFFFFFF00
00FFFFFFFFFFFFFFFFFFFFFFFFFF0000
000000FFFFFFFFFFFFFFFFFFFF000000
</OS-BADGE-ICONS>
</CHRP-BOOT>
');

	output("$dir/$boot/yaboot.conf", '
init-message = "\nWelcome to Mandriva Linux PPC!\nHit <TAB> for boot options.\n\n"
timeout = 150
device=cd:
default = install-gui
message=/boot/yaboot.msg

image = /boot/vmlinux
    label = install-gui
    initrd = /boot/all.gz
    initrd-size = 34000
    append = " ramdisk_size=128000"

image = /boot/vmlinux-power4
    label = install-gui-power4
    initrd = /boot/all-power4.gz
    initrd-size = 34000
    append = " ramdisk_size=128000"

image = /boot/vmlinux
    label = install-text
    initrd = /boot/all.gz
    initrd-size = 34000
    append = " text ramdisk_size=128000"

image = /boot/vmlinux-power4
    label = install-text-power4
    initrd = /boot/all-power4.gz
    initrd-size = 34000
    append = " text ramdisk_size=128000"

image = /boot/vmlinux
    label = install-gui-old
    initrd = /boot/all.gz
    initrd-size = 34000
    append = " gui-old ramdisk_size=128000"

image = /boot/vmlinux-power4
    label = install-gui-old-power4
    initrd = /boot/all-power4.gz
    initrd-size = 34000
    append = " gui-old ramdisk_size=128000"

image = enet:0,vmlinux
    label = install-net
    initrd = enet:0,all.gz
    initrd-size = 34000
    append = " ramdisk_size=128000"

image = enet:0,vmlinux-power4
    label = install-net-power4
    initrd = enet:0,all-power4.gz
    initrd-size = 34000
    append = " ramdisk_size=128000"

image = enet:0,vmlinux
    label = install-net-text
    initrd = enet:0,all.gz
    initrd-size = 34000
    append = " text ramdisk_size=128000"

image = enet:0,vmlinux-power4
    label = install-net-text-power4
    initrd = enet:0,all-power4.gz
    initrd-size = 34000
    append = " text ramdisk_size=128000"

image = /boot/vmlinux
    label = rescue
    initrd = /boot/all.gz
    initrd-size = 34000
    append = " rescue ramdisk_size=128000"

image = /boot/vmlinux-power4
    label = rescue-power4
    initrd = /boot/all-power4.gz
    initrd-size = 34000
    append = " rescue ramdisk_size=128000"

image = enet:0,vmlinux
    label = rescue-net
    initrd = enet:0,all.gz
    initrd-size = 34000
    append = " rescue ramdisk_size=128000" 

image = enet:0,vmlinux-power4
    label = rescue-net-power4
    initrd = enet:0,all-power4.gz
    initrd-size = 34000
    append = " rescue ramdisk_size=128000" 
');

	output("$dir/$boot/yaboot.msg", '
Thanks for choosing Mandriva Linux PPC.  The following is a short
explanation of the various options for booting the install CD.

All options ending with "-power4" use the BOOT kernel for ppc 9xx and POWER4.
The default syntax with no suffix uses the BOOT kernel for ppc 6xx 7xx and 7xxx.
The default if you just hit enter is "install-gui".

install-gui:        	uses Xorg fbdev mode
install-text:       	text based install
install-net:            allows you to use a minimal boot CD,
                        pulling the rest of the install from
                        a network server
install-net-text:       text mode network install
rescue:                 boots the rescue image
rescue-net:             boots the rescue image from a network server

');

}

sub VERSION {
    my ($kernels) = @_;

    map { "$_\n" }
      $ENV{DISTRIB_DESCR},
      scalar gmtime(),
      '', @$kernels;
}

sub syslinux_all_files {
    my ($dir, $kernels) = @_;

    eval { rm_rf($dir) }; mkdir_p($dir);

    @$kernels or die "syslinux_all_files: no kernel\n";

    $default_vga =~ /788/ or die 'we rely on vga=788 for bootsplash';
    my $bootspash_cfg = '/etc/bootsplash/themes/Mandriva/config/bootsplash-800x600.cfg';
    -e $bootspash_cfg or die "can't find $bootspash_cfg";

    each_index {
	mkdir "$dir/alt$::i", 0777;
	_ "cp kernel/all.kernels/$_/vmlinuz $dir/alt$::i";
	initrd($tmp_mnt_initrd, 'all', '', "images/all.rdz-$_");
	_ "splash -s -f $bootspash_cfg >> images/all.rdz-$_" if !/BOOT/;
	rename("images/all.rdz-$_", "$dir/alt$::i/all.rdz");
    } @$kernels;

    _ "lilo-bmp2mdk file:isolinux-graphic.bmp >$dir/boot.msg";

    _ "install -m 644 -D /boot/memtest* $dir/test/memtest.bin";

    output("$dir/help.msg", syslinux_msg('help.msg.xml'));
    output("$dir/advanced.msg", syslinux_msg('advanced.msg.xml', 
					     "\nYou can choose the following kernels :\n",
					     map_index { " o  " . syslinux_color('white') . "alt$::i" . syslinux_color('default') . " is kernel $_\n" } @$kernels));
}

sub isolinux {
    my ($main, @kernels) = @_;
    @kernels = ($main, grep { $_ ne $main } @kernels);

    syslinux_all_files('isolinux', \@kernels);

    _ "cp /usr/lib/syslinux/isolinux.bin isolinux/isolinux.bin";
    output("isolinux/isolinux.cfg", syslinux_cfg_all('cdrom'));

    xbox_stage1() if arch() =~ /i.86/;
}

sub xbox_stage1() {
    my $dir = 'isolinux/xbox';

    eval { rm_rf($dir) }; mkdir_p($dir);

    my $xbox_kernel = find { /xbox/ } all('kernel/all.kernels') or return;

    _ "cp kernel/all.kernels/$xbox_kernel/vmlinuz $dir";
    initrd($tmp_mnt_initrd, 'all', '', "images/all.rdz-$xbox_kernel");
    rename("images/all.rdz-$xbox_kernel", "$dir/initrd");

    _ "cp /usr/share/cromwell/xromwell-installer.xbe $dir/default.xbe";
    output("$dir/linuxboot.cfg", <<EOF);
kernel $dir/vmlinuz
initrd $dir/initrd
append root=/dev/ram3 ramdisk_size=36000 automatic=method:cdrom
EOF
}

sub boot_iso {
    my ($iso, $kernels) = @_;

    syslinux_all_files('.boot_iso/isolinux', $kernels);

    output('.boot_iso/VERSION', VERSION($kernels));	   
   
    _ "cp /usr/lib/syslinux/isolinux.bin .boot_iso/isolinux/isolinux.bin";
    output('.boot_iso/isolinux/isolinux.cfg', syslinux_cfg_all(''));

    _ "mkisofs -r -f -J -cache-inodes -V 'Mdk Boot ISO' -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -o $iso .boot_iso";
    rm_rf('.boot_iso');
}

sub isolinux_move {   
    my ($main) = @_;

    _ "cp kernel/all.kernels/$main/vmlinuz move/isolinux";
    initrd($tmp_mnt_initrd, 'all', '', "move/isolinux/all.rdz-$main", '-with-busybox');
    rename "move/isolinux/all.rdz-$main", "move/isolinux/all.rdz";

    _ "lilo-bmp2mdk file:move/data/isolinux-graphic.bmp >move/isolinux/boot.msg";
    _ "cp /usr/lib/syslinux/isolinux.bin move/isolinux/isolinux.bin";
}

sub hd_grub {
    my ($img) = @_;
    my $mapfile = '/tmp/device.map.tmp';

    my @grub_files = map { "/boot/grub/$_" } qw(stage1 stage2);
    my $size = 40_000 + sum(map { -s $_ } @grub_files);

    __ "$sudo umount $tmp_mnt 2>/dev/null";
    _ "dd if=/dev/zero of=$img bs=1 count=$size";
    _ "mkdosfs $img";
    _ "$sudo mount -t vfat -o umask=0 $img $tmp_mnt -o loop";
    _ "cp @grub_files $tmp_mnt";

    output("$tmp_mnt/menu.lst", <<EOF);
timeout 10
default 0
fallback 1

title Mandriva Linux Install

root (hd0,0)
kernel /cooker/isolinux/alt0/vmlinuz $default_append $default_acpi $default_vga automatic=method:disk
initrd /cooker/isolinux/alt0/all.rdz

title Help

pause To display the help, press <space> until you reach "HELP END"
pause .
pause Please see http://qa.mandriva.com/hd_grub.cgi for a friendlier solution
pause .
pause To specify the location where Mandriva Linux is copied,
pause choose "Mandriva Linux Install", and press "e".
pause Then change "root (hd0,0)". FYI:
pause - (hd0,0) is the first partition on first bios hard drive (usually hda1)
pause - (hd0,4) is the first extended partition (usually hda5)
pause - (hd1,0) is the first partition on second bios hard drive
pause Replace /cooker to suits the directory containing Mandriva Linux
pause .
pause HELP END
EOF

    _ "$sudo umount $tmp_mnt";

    output($mapfile, "(fd0) $img\n");

    open(my $G, "| grub --device-map=$mapfile --batch");
    print $G <<EOF;
root (fd0)
install /stage1 d (fd0) /stage2 p /menu.lst
quit
EOF
    close $G;
    unlink $mapfile;
}

sub drivers {
    my ($type, $I, $img) = @_;

    _ "dd if=/dev/zero of=$img bs=1k count=1440";
    mke2fs($img);
    _ "$sudo mount -t ext2 $img $tmp_mnt -o loop";

    my ($ext) = $img =~ /img-(.*)/ or die "bad image name ($img)";
    _ "$sudo cp -f kernel/all.kernels$I/$ext/${type}_modules.mar $tmp_mnt/modules$I.mar";

    _ "sync";
    _ "df $tmp_mnt";

    _ "$sudo umount $tmp_mnt";
}
