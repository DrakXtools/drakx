#!/usr/bin/perl

@ARGV >= 2 or die "usage: $0 <image> all|other|cdrom|hd|network|usb|blank|pcmcia|live|tftp|tftprd\n";

use Config;
use MDK::Common;
Config->import;
my ($arch) = $Config{archname} =~ /(.*)-/;
my $corporate = $ENV{CORPORATE} && " corporate"; #- use this for building a corporate version.

($img, $type) = @ARGV;

$default_append = "ramdisk_size=32000 root=/dev/ram3";
$default_vga = "vga=788";

$instdir = "mdk-stage1";
$mnt = "/tmp/drakx_mnt";
$mke2fs = "/sbin/mke2fs -q -m 0 -F -s 1";

if ($>) {
    $sudo = "sudo";
    $ENV{PATH} = "/sbin:/usr/sbin:$ENV{PATH}";
}

sub __ { print @_, "\n"; system(@_); }
sub _ { __ @_; $? and die; }

_ "$sudo mkdir $mnt" unless -e $mnt;
_ "$sudo mkdir ${mnt}2" unless -e "${mnt}2";

$install = $ {{
    all => "stage1-full",
    other => "stage1-full",
    blank => "stage1-full",
    live => "stage1-full",
    tftp => "stage1-full",
    tftprd => "stage1-full",
    pcmcia => "stage1-full",
    network => "stage1-network",
    usb => "stage1-usb",
    cdrom => "stage1-cdrom",
    hd => "stage1-disk",
    live64 => "stage1-full",
    tftp64 => "stage1-full",
    tftprd64 => "stage1-full",
    pcmcia64 => "stage1-full",
    network64 => "stage1-network",
    cdrom64 => "stage1-cdrom",
    hd64 => "stage1-disk",
}}{$type} or die;

mkdir "images";
chomp($main = `cat all.kernels/.main`);

if ($img =~ /blank|other|pcmcia/) {
    @kernels = $main;
} else {
    @kernels = map { m|all.kernels/(.*)| } glob('all.kernels/*');
    $img =~ /usb/ and @kernels = grep { $_ !~ /2\.2\.14/ } @kernels;  #- 2.2.14 is too old, usb support was not working properly
}

foreach (@kernels) {
    if ($img =~ /rdz$/) {
	initrd($mnt, "$img-$_");
    } else {
	$::{"boot_img_$arch"}->($mnt, "$img-$_", glob("all.kernels/$_/boot/vmlinu*"));
	rename("$img-$main", "$img");
    }
}
if ($arch =~ /i.86/ && $img =~ /all/) {
    isolinux($main, @kernels);
}

if (my ($tftpboot) = grep { -e $_ } qw(/tftpboot /var/lib/tftpboot)) {
    system("/bin/cp -f all.kernels/$main/boot/vmlinu* $tftpboot/vmlinuz 2>/dev/null");
    system("/bin/cp -f images/network.rdz-$main $tftpboot/network.rdz 2>/dev/null");
}

sub install_stripped { _ "strip $_[0]"; _ "$sudo install $_[0] $_[1]" }

sub initrd {
    my ($mnt, $img) = @_;
    my ($ltype, $I) = $type =~ /(.*?)(64)/; $ltype ||= $type;
    my $tmp = "$ENV{HOME}/tmp/initrd";
    my $tar = "$instdir/stage1-data/stage1.tar.bz2";

    __ "$sudo umount $tmp $mnt 2>/dev/null";
    _ "dd if=/dev/zero of=$tmp bs=1k count=" . ($arch =~ /ia64/ ? ($type eq "all" ? 16386 : 16384) : ($type eq "all" ? 4000 : 2000));
    _ "$mke2fs $tmp";
    _ "$sudo mount -t ext2 $tmp $mnt -o loop";

    _ "$sudo tar xjC $mnt -f $tar";
    install_stripped("$instdir/init", "$mnt/sbin");
    install_stripped("$instdir/$install", "$mnt/sbin/stage1");

    if ($type eq "network" || $type eq "usb" || $type eq "all" || $type eq "other" || $type eq "blank") {
	install_stripped("$instdir/ppp/pppd-bin", "$mnt/sbin/pppd");
	install_stripped("$instdir/rp-pppoe/pppoe-bin", "$mnt/sbin/pppoe");
	_ "$sudo mknod $mnt/dev/ppp c 108 0";
	_ "$sudo mknod $mnt/dev/ptyp0 c 2 0";
	_ "$sudo mknod $mnt/dev/ttyp0 c 3 0";
    }

    if (member($type, qw(pcmcia all network)) && $arch !~ /ppc/ && $arch !~ /ia64/) {
	 _ "$sudo cp -a /etc/pcmcia $mnt/etc";
	 _ "cp $mnt/etc/pcmcia/config /tmp/pcmcia_config_tmp";
	 _ "tools/patch_pcmcia_config.pl /tmp/pcmcia_config_tmp all.modules/$main/modules.dep";
	 _ "sudo mv /tmp/pcmcia_config_tmp $mnt/etc/pcmcia/config";
    }
    my ($ext) = $img =~ /rdz-(.*)/ or die "bad initrd name ($img)";
    $modz = "all.modules$I/$ext";
    _ "$sudo cp -f $modz/${ltype}_modules.mar $mnt/modules/modules$I.mar" if $type !~ /blank/;
    _ "$sudo cp -f $modz/modules.dep $mnt/modules/";
    _ "$sudo umount $mnt";


# Workaround for vfat-loop bug (quite touchy)
    _ "gzip -9f $tmp";
    _ "cp -f $tmp.gz $img";
    _ "rm -f $tmp.gz";
#    _ "gzip -9 -c $tmp > $img";
#    _ "rm -f $tmp";
}

sub entries_append {
    my ($type) = @_;

    my $automatic = "";
    $automatic = "automatic=method:cdrom" if ($type eq "cdrom");
    $automatic = "automatic=method:disk" if ($type eq "hd");

    my @simple_entries = (
	linux => "$default_vga",
	vgalo => "vga=785",
	vgahi => "vga=791",
	vga16 => "vga16",
	text => "text",
	patch => "patch $default_vga",
	expert => "expert $default_vga",
	rescue => "rescue rw",
    );
    my @entries = (
        (map { $_->[0] => "$automatic $_->[1]" } group_by2(@simple_entries)),
	if_(member($type, "cdrom", "all"), oem => "automatic=method:cdrom rescue oem rw"),
        if_($type eq "all", all => "pcmcia $default_vga"),
    );

    map { [ $_->[0], "$default_append $_->[1]" ] }
      group_by2(@entries);
}

sub boot_img_i386 {
    my ($mnt, $img, $kernel) = @_;

    __ "$sudo umount $mnt 2>/dev/null";

    if ($type eq "hd") {
	_ "bunzip2 -c $instdir/init-data/msgboot.img.bz2 > $img";
    } elsif ($type eq "all") {
	_ "bunzip2 -c $instdir/init-data/msgboot-graphicallogo-2880.img.bz2 > $img";
    } elsif ($type eq "blank") {
	_ "bunzip2 -c $instdir/init-data/msgboot-blank.img.bz2 > $img";
    } else {
	_ "bunzip2 -c $instdir/init-data/msgboot-graphicallogo.img.bz2 > $img";
    }


    _ "$sudo mount -t vfat -o umask=0 $img $mnt -o loop";
    _ "cat $kernel > $mnt/vmlinuz" if $type !~ /blank/;

    my $rdz = $img; $rdz =~ s/\.img/.rdz/;
    initrd("${mnt}2", $rdz) if !-e $rdz;
    eval { _ "cp -f $rdz $mnt/$type.rdz" };
    if ($@) {
	unlink "$mnt/$type.rdz";
	my $avail = (split ' ', `df $mnt`)[-3];
	my $s = int((-s $rdz) / 1024);
	die sprintf("not enough room for $rdz: need %dKB (available %dKB < needed %dKB)\n", $s - $avail, $avail, $s);
    }

    my $timeout = 72;
    output "$mnt/syslinux.cfg",
"default linux
prompt 1
timeout $timeout
display boot.msg
F1 help.msg
F2 advanced.msg
F3 boot.msg
" . join('', map {
"label $_->[0]
  kernel vmlinuz
  append initrd=$type.rdz $_->[1]
" } entries_append($type));

    _ "sync";
    _ "df $mnt";
}

sub boot_img_alpha {
    my ($mnt, $img) = @_;

    __ "$sudo umount $mnt 2>/dev/null";
    _ "dd if=/dev/zero of=$img bs=1k count=1440";
    _ "$mke2fs $img";
    _ "/sbin/e2writeboot $img /boot/bootlx";
    _ "$sudo mount -t ext2 $img $mnt -o loop";
    _ "cp -f vmlinux.gz $mnt" if $type !~ /blank/;
    -f "$type.rdz" ? _ "cp -f $type.rdz $mnt" : initrd("${mnt}2", "$mnt/$type.rdz");

    mkdir "$mnt/etc", 0777;
    output("$mnt/etc/aboot.conf", 
"0:vmlinux.gz initrd=$type.rdz rw $default_append $type
1:vmlinux.gz initrd=$type.rdz rw $default_append text $type
");
    _ "sync";
    _ "df $mnt";
}

sub boot_img_ia64 {
    my ($mnt, $img, $kernel) = @_;
	my $rdz = $img; $rdz =~ s/\.img/.rdz/;

    __ "$sudo umount $mnt 2>/dev/null";
    _ "dd if=/dev/zero of=$img bs=1k count=16384";
    _ "mkdosfs $img";
    _ "$sudo mount -t vfat $img $mnt -o loop,umask=000";
    _ "$sudo cp -f $kernel $mnt/vmlinux";
    _ "cp -f $rdz $mnt/$type.rdz";
    _ "$sudo cp -f tools/ia64/elilo.efi $mnt";
	output("$mnt/elilo.conf", "
prompt
timeout=50

image=vmlinux
        label=linux
        root=/dev/ram3
        initrd=$type.rdz
        append=\" ramdisk_size=120000\"
        read-only

image=vmlinux
        label=rescue
        root=/dev/ram3
        initrd=$type.rdz
        append=\" rescue ramdisk_size=120000\"
");
    _ "sync";
    _ "df $mnt";

}

sub boot_img_sparc {
    my ($mnt, $img) = @_;
    if ($type =~ /^live(.*)/) {
	#- hack to produce directly into /export the needed file for cdrom boot.
	my $dir = "/export";
	my $boot = "boot"; #- non-absolute pathname only!

	_ "mkdir -p $dir/$boot";
	_ "cp -f /boot/cd.b /boot/second.b $dir/$boot";
	_ "cp -f vmlinux$1 $dir/$boot/vmlinux$1";
	-f "live$1.rdz" ? _ "cp -f live$1.rdz $dir/$boot" : initrd("${mnt}2", "$dir/$boot/live$1.rdz");

	output("$dir/$boot/silo.conf", "
partition=1
default=linux
timeout=100
read-write
message=/$boot/boot.msg
image=\"cat /$boot/boot.msg\"
  label=1
  single-key
image=\"cat /$boot/general.msg\"
  label=2
  single-key
image=\"cat /$boot/expert.msg\"
  label=3
  single-key
image=\"cat /$boot/rescue.msg\"
  label=4
  single-key
image=\"cat /$boot/kickit.msg\"
  label=5
  single-key
image=\"cat /$boot/param.msg\"
  label=6
  single-key
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=linux
  alias=install
  initrd=/$boot/live.rdz
  append=\"ramdisk_size=32000$corporate root=/dev/ram3\"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=text
  initrd=/$boot/live.rdz
  append=\"ramdisk_size=32000 text$corporate root=/dev/ram3\"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=expert
  initrd=/$boot/live.rdz
  append=\"ramdisk_size=32000 expert$corporate root=/dev/ram3\"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=ks
  initrd=/$boot/live.rdz
  append=\"ramdisk_size=32000 ks$corporate root=/dev/ram3\"
image[sun4c,sun4d,sun4m]=/$boot/vmlinux
  label=rescue
  initrd=/$boot/live.rdz
  append=\"ramdisk_size=32000 rescue rw root=/dev/ram3$corporate\"
image[sun4u]=/$boot/vmlinux64
  label=linux
  alias=install
  initrd=/$boot/live64.rdz
  append=\"ramdisk_size=32000$corporate root=/dev/ram3\"
image[sun4u]=/$boot/vmlinux64
  label=text
  initrd=/$boot/live64.rdz
  append=\"ramdisk_size=32000 text$corporate root=/dev/ram3\"
image[sun4u]=/$boot/vmlinux64
  label=expert
  initrd=/$boot/live64.rdz
  append=\"ramdisk_size=32000 expert$corporate root=/dev/ram3\"
image[sun4u]=/$boot/vmlinux64
  label=ks
  initrd=/$boot/live64.rdz
  append=\"ramdisk_size=32000 ks$corporate root=/dev/ram3\"
image[sun4u]=/$boot/vmlinux64
  label=rescue
  initrd=/$boot/live64.rdz
  append=\"ramdisk_size=32000 rescue rw root=/dev/ram3$corporate\"
");

	output("$dir/$boot/README", "
To Build a Bootable CD-ROM, try:
  mkisofs -R -o t.iso -s /$boot/silo.conf /export
");
    } elsif ($type =~ /^tftprd(.*)/) {
	my $dir = "/export";
	my $boot = "images";
	my $setarch = $1 ? "sparc64" : "sparc32";

	_ "mkdir -p $dir/$boot";
	-f "$type.rdz" or initrd("${mnt}2", "$type.rdz");
	_ "cp -f vmlinux$1.aout $dir/$boot/$type.img";
	_ "$setarch kernel$1/src/arch/sparc$1/boot/piggyback $dir/$boot/$type.img kernel$1/boot/System.map $type.rdz";
    } elsif ($type =~ /^tftp(.*)/) {
	my $dir = "/export";
	my $boot = "images";

	_ "mkdir -p $dir/$boot";
	_ "cp -f vmlinux$1.aout $dir/$boot/$type.img";
    } else {
	my $dir = "floppy";
	my ($ltype, $I) = $type =~ /(.*?)(64)/; $ltype ||= $type;

	__ "$sudo umount $mnt 2>/dev/null";
	_ "rm -rf $dir";
	_ "mkdir -p $dir";
	_ "cp -f /boot/fd.b /boot/second.b $dir";
	_ "cp -f vmlinuz$I $dir/vmlinux$I.gz" if $type !~ /blank/;
	-f "$type.rdz" ? _ "cp -f $type.rdz $dir" : initrd("${mnt}2", "$dir/$type.rdz");

	output("$dir/boot.msg", "
Welcome to Mandrake Linux 7.1

Press <Enter> to install or upgrade a system 7mMandrake Linux7m
");

	output("$dir/silo.conf", "
partition=1
default=linux
timeout=100
read-write
message=/boot.msg
image=/vmlinux$I.gz
  label=linux
  initrd=/$type.rdz
  append=\"ramdisk_size=32000 $ltype$corporate root=/dev/ram3\"
");
	_ "genromfs -d $dir -f /dev/ram -A 2048,/.. -a 512 -V \'DrakX boot disk\'";
	_ "$sudo mount -t romfs /dev/ram $mnt";
	_ "silo -r $mnt -F -i /fd.b -b /second.b -C /silo.conf";
	_ "$sudo umount $mnt";
	_ "dd if=/dev/ram of=$type.img bs=1440k count=1";
	_ "sync";
	_ "$sudo mount -t romfs /dev/ram $mnt";
	_ "df $mnt";
    }
}

sub boot_img_ppc {
    my ($mnt, $img, $kern, $modz) = @_;
    my $dir = "/export";
    my $boot = "boot"; #- non-absolute pathname only!
    my ($extension) = $modz =~ /.*\/([^\/]+)/;
    _ "mkdir -p $dir/$boot";
    _ "cp -f $kern $dir/$boot/vmlinux";
    _ "cp -f images/all.rdz$extension $dir/boot/all.gz";
    _ "cp -f tools/ppc/yaboot $dir/boot/yaboot";
	
	output("$dir/$boot/yaboot.conf", "
init-message = \"\\nWelcome to Mandrake Linux PPC!\\nHit <TAB> for boot options.\\n\\n\"
timeout = 150
default = install-novideo

image = cd:,\\\\\\\\vmlinux
    label = install-novideo
    root = /dev/ram3
    initrd = cd:,\\\\\\\\all.gz
    initrd-size = 32000
    append = \" video=ofonly\"
    
image = cd:,\\\\\\\\vmlinux
    label = install-atyfb
    root = /dev/ram3
    initrd = cd:,\\\\\\\\all.gz
    initrd-size = 32000
    append = \" video=atyfb:vmode:17\"
    
image = cd:,\\\\\\\\vmlinux
    label = install-aty128fb
    root = /dev/ram3
    initrd = cd:,\\\\\\\\all.gz
    initrd-size = 32000
    append = \" video=aty128fb:vmode:17\"

image = cd:,\\\\\\\\vmlinux
    label = install-text
    root = /dev/ram3
    initrd = cd:,\\\\\\\\all.gz
    initrd-size = 32000
    append = \" text video=ofonly\"

image = enet:0,vmlinux
    label = install-net
    root = /dev/ram3
    initrd = enet:0,all.gz
    initrd-size = 32000
    append = \" video=ofonly\"

image = enet:0,vmlinux
    label = install-net-text
    root = /dev/ram3
    initrd = enet:0,all.gz
    initrd-size = 32000
    append = \" text video=ofonly\"

image = cd:,\\\\\\\\vmlinux
    label = rescue
    root = /dev/ram3
    initrd = cd:,\\\\\\\\all.gz
    initrd-size = 32000
    append = \" rescue video=ofonly\"    

image = enet:0,vmlinux
    label = rescue-net
    root = /dev/ram3
    initrd = enet:0,all.gz
    initrd-size = 32000
    append = \" rescue video=ofonly\"    
");
	#- seem to need 2 yaboot.conf, one in the root, and one in boot
	_ "cp -f $dir/boot/yaboot.conf $dir/yaboot.conf";		

	output("$dir/$boot/README", "
To Build a Bootable CD-ROM, do:
cd /tools/ppc
./mkINSTALLCD /export ppc-cd.img
");

}

sub isolinux {
    my ($main, @kernels) = @_;
    @kernels = ($main, grep { $_ ne $main } @kernels);
    my $debug = 1 ? '-debug' : '';
    _ "rm -rf isolinux"; mkdir "isolinux", 0777;
    my $i = 0;
    foreach (@kernels) {
	mkdir "isolinux/alt$i", 0777;
	my ($kernel) = glob("all.kernels/$_/boot/vmlinu*");
	_ "cp $kernel isolinux/alt$i/vmlinuz";
	_ "cp images/all.rdz-$_ isolinux/alt$i/all.rdz";
	$i++;
    }
    _ "cp /usr/lib/syslinux/isolinux$debug.bin isolinux/isolinux.bin";
    output "isolinux/isolinux.cfg", "
default linux
prompt 1
timeout 150
display help.msg
" . join('', map { 
"label $_->[0]
  kernel alt0/vmlinuz
  append changedisk initrd=alt0/all.rdz $_->[1]
" } entries_append('all'))
  . join('', map_index { 
"label alt$::i
  kernel alt$::i/vmlinuz
  append changedisk initrd=alt$::i/all.rdz $default_append $default_vga
" } @kernels);

    output "isolinux/help.msg", 
"This is a special bootable CDROM giving you a choice between various kernels.

The default is kernel $main.
" . join('', map_index { $::i ? "\"alt$::i\" is kernel $_\n" : '' } @kernels);
}
