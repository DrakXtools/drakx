#!/usr/bin/perl

# drakupdate_fstab
# Copyright (C) 2002-2004 Mandrakesoft (pixel@mandrakesoft.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

use lib qw(/usr/lib/libDrakX);

use detect_devices;
use security::level;
use common;
use fsedit;
use lang;
use any;
use fs;

$::isStandalone = 1; #- not using standalone.pm which generates too many logs for drakupdate_fstab purpose

log::l("drakupdate_fstab called with @ARGV\n");

$::testing = $ARGV[0] eq '--test' && shift @ARGV;
$::auto = $ARGV[0] eq '--auto' && shift @ARGV;
my $no_flag = $ARGV[0] eq '--no-flag' && shift @ARGV;
my ($raw_action, $device_name) = @ARGV;
my ($action) = $raw_action =~ /^--(add|del)/;

@ARGV == 2 && $action or die "usage: drakupdate_fstab [--test] [--auto] [--no-flag] [--add | --del] <device>\n";

main($action, $device_name);


sub check_hard_drives {
    my ($name) = @_;

    #- do not do anything if there are many partitions
    #- otherwise we may add main extended partitions
    if ($name =~ s|/part\d+$||) {
	my @parts = grep { /part/ } all($name);
	@parts <= 1;
    } else {
	1;
    }
}

sub device_name_to_entry {
    my ($name) = @_;
    $name =~ s|/dev/||;
    $name =~ /fd[01]/ && !$::auto and return { device => $name };
    my @l = detect_devices::get();

    my $e;
    if (my ($devfs_prefix, $nb) = $name =~ m,(.*)/(?:cd|disc|part(\d+))$,) {
	$e = find { $_->{devfs_prefix} eq $devfs_prefix } @l;
	$e->{devfs_prefix} ||= $devfs_prefix;
	$e->{devfs_device} = $e->{devfs_prefix} . '/part' . $nb;
	if ($e->{devfs_device} eq $name) {
	    $e->{prefer_devfs_name} = 1;
	}
    } else {
	unless ($e = find { $name eq $_->{device} } @l) {
	    my ($prefix, $nb) = $name =~ m/^(.*?)(\d*)$/;
	    $e = find { $prefix eq ($_->{prefix} || $_->{device}) } @l;
	    $e->{device} = ($e->{prefix} || $e->{device}) . $nb;
	}
    }

    $e ||= {};
    unless ($e->{devfs_device} eq $name) {
	$e->{device} = $name; #- keeping the exact name given (often is the devfs name)
    }
    $e->{media_type} = 'fd' if $name =~ /fd[01]/;
    $e;
}

sub set_options {
    my ($part, $useSupermount) = @_;

    $part->{is_removable} = 1; #- force removable flag
    fs::mount_options::set_default($part, 
			    useSupermount => $useSupermount, 
			    security => security::level::get(), 
			    lang::fs_options(lang::read()));

    my ($options, $unknown) = fs::mount_options::unpack($part);
    $options->{kudzu} = 1 if !$no_flag;
    fs::mount_options::pack($part, $options, $unknown);
}

sub set_mount_point {
    my ($part, $fstab) = @_;

    my $mntpoint = detect_devices::suggest_mount_point($part) or return;
    $mntpoint = "/mnt/$mntpoint";

    foreach ('', 2 .. 10) {
	next if fs::get::mntpoint2part("$mntpoint$_", $fstab);
	$part->{mntpoint} = "$mntpoint$_";
	return 1;
    }
    0;
}

sub main {
    my ($action, $device_name) = @_;

    if ($::auto) {
	check_hard_drives($device_name) or return;
    }

    my $part = device_name_to_entry($device_name);
    my $fstab_file = '/etc/fstab';
    if (!$part) {
	print STDERR "Can't find device $device_name\n" if $::testing;
	return;
    } elsif ($::testing) {
	cp_af('/etc/fstab', $fstab_file = '/tmp/fstab');
    }

    my $fstab = [ fs::read_fstab('', '/etc/fstab', 'keep_freq_passno', 'keep_devfs_name', 'verbatim_credentials') ];
    my ($existing_fstab_entries, $fstab_) = partition { fsedit::is_same_hd($_, $part) } @$fstab;

    if ($action eq 'add') {
	if (@$existing_fstab_entries) {
	    print STDERR "Already in fstab\n" if $::testing;
	    return;
	}
	my $useSupermount = ${{ getVarsFromSh('/etc/sysconfig/dynamic') }}{SUPERMOUNT} eq 'no' ? '' : 'magicdev';
	set_options($part, $useSupermount);
	set_mount_point($part, $fstab) or return;
	
	my ($line) = fs::prepare_write_fstab([$part]);
	if ($line) {
	    append_to_file($fstab_file, $line);
	    system("mount $part->{mntpoint}") if !$::testing && $device_name =~ /^fd\d+/;
	}

	if ($::auto) {
	    print $part->{mntpoint}, " ", $useSupermount ? 'supermount' : 'user', "\n";
	}
    } else {
	if (!@$existing_fstab_entries) {
	    print STDERR "Not found in fstab\n" if $::testing;
	    return;
	}
	foreach (@$existing_fstab_entries) {
	    if (!$no_flag && $_->{options} !~ /\bkudzu\b/) {
		print STDERR "Not a 'kudzu'-flagged entry\n" if $::testing;
		return;
	    }
	}

	my ($s) = fs::prepare_write_fstab($fstab_, '', 'keep_smb_credentials');
	output($fstab_file, $s);

	if ($::auto) {
	    print "$_->{mntpoint}\n" foreach @$existing_fstab_entries;
	}
    }

    if ($::testing) {
	print "fstab would have changed:\n";
	system("diff -u /etc/fstab $fstab_file");
    }
}
