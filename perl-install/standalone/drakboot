#!/usr/bin/perl

# DrakBoot
# $Id$
# Copyright (C) 2001-2004 Mandrakesoft
# Yves Duret, Thierry Vignaud
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

use strict;
use diagnostics;
use lib qw(/usr/lib/libDrakX);

use standalone; #- warning, standalone must be loaded very first, for 'explanations'
use c;
use common;
use interactive;
use any;
use bootloader;
use detect_devices;
use fsedit;
use fs;
use Config;
use POSIX;
use Xconfig::various;
use log;

my $splash_working = any { /^--splash$/ } @ARGV;

my $in = 'interactive'->vnew('su');

my $all_hds = fsedit::get_hds();
fs::get_raw_hds('', $all_hds);
fs::get_info_from_fstab($all_hds, '');
my $fstab = [ fs::get::fstab($all_hds) ];
my $bootloader = bootloader::read($fstab);

if (!$in->isa('interactive::gtk') || any { /^--boot$/ } @ARGV) {
    $::isWizard = 1;
    lilo_choice();
    $in->exit(0);
}
require ugtk2;
ugtk2->import(qw(:helpers :wrappers :create));

my $no_bootsplash;
my $x_mode = Xconfig::various::runlevel() == 5;
my $auto_mode = any::get_autologin();
my $switch_theme = '/usr/share/bootsplash/scripts/switch-themes';
my $remove_theme = '/usr/share/bootsplash/scripts/remove-theme';

my $w = ugtk2->new($splash_working ? N("Graphical boot theme selection") : N("System mode"));
my $window = $w->{window};
$::main_window = $w->{rwindow} if !$::isEmbedded;

$window->signal_connect(delete_event => sub { ugtk2->exit(0) });
unless ($::isEmbedded) {
    $window->set_border_width(2);

    ### menus definition
    # the menus are not shown but they provides shiny shortcut like C-q
    my @menu_items = ([ N("/_File"), undef, undef, undef, '<Branch>' ],
                      [ N("/File/_Quit"), N("<control>Q"), sub { ugtk2->exit(0) }, undef, '<Item>' ],
                     );
    create_factory_menu($w->{rwindow}, @menu_items);
    ######### menus end
}

my $user_combo = Gtk2::ComboBox->new_with_strings([ sort(list_users()) ], $auto_mode->{autologin});
my $desktop_combo = Gtk2::ComboBox->new_with_strings([ sort(split(' ', `/usr/sbin/chksession -l`)) ], $auto_mode->{desktop});

my %themes = 	('path' => '/usr/share/bootsplash/themes/',
   	        'sysconfig' => '/etc/sysconfig/bootsplash',
                'default' => 'Mandrake',
                'def_thmb' => '/usr/share/libDrakX/pixmaps/nosplash_thumb.png',
                'lilo' => {'file' => '/lilo/message',
                           'thumb' => '/lilo/thumb.png' },
                'boot' => {'path' => '/images/',
                                #'thumb'=>'/images/thumb.png',
                          },
               );
my $kernel_release = `uname -r`;
chomp $kernel_release;

require Xconfig::resolution_and_depth;
my $cur_res;
if (my $x_res = Xconfig::resolution_and_depth::from_bios($bootloader->{default_vga})) {
    $cur_res = $x_res->{X} . 'x' . $x_res->{Y};
} else {
    $no_bootsplash = 1; #- we can't select any theme we're not in Framebuffer mode :-/
    $cur_res = '800x600'
}

$no_bootsplash = 0 if $::testing;

my $splash_mode = !$no_bootsplash;
my $keep_logo = 1;

if (-r $themes{sysconfig}) {
    local $_;
    foreach (cat_($themes{sysconfig})) {
	/^SPLASH=no/ and $splash_mode = 0;
	/^THEME=(.*)/ and  -f "$themes{path}$1$themes{boot}{path}bootsplash-$cur_res.jpg" and $themes{default} = $1;
	/^LOGO_CONSOLE=(.*)/ and $keep_logo = $1 ne 'no';
    }
}

my @boot_thms = if_(!$themes{default}, qw(default));
chdir($themes{path}); #- we must change directory for correct @boot_thms assignement
foreach (sort(all('.'))) {
    if (-d "$themes{path}$_" && m/^[^.]/) {
        -f "$themes{path}$_$themes{boot}{path}bootsplash-$cur_res.jpg" and push @boot_thms, $_;
    }
}
my %combo = ('thms' => '', 'lilo' => '');
foreach (keys(%combo)) {
    $combo{$_} = gtkset_size_request(Gtk2::ComboBox->new_text, 10, -1);
}

$combo{boot} = gtkset_size_request(Gtk2::ComboBox->new_with_strings(\@boot_thms, $themes{default}), 10, -1);;

my $boot_pic = gtkcreate_img($themes{def_thmb});
change_image($boot_pic, $themes{default});

my $_thm_button = Gtk2::Button->new(N("Install themes"));
my $_B_create = gtksignal_connect(Gtk2::Button->new(N("Create new theme")), clicked => sub { system('/usr/sbin/draksplash ') });

#- ******** action to take on changing combos values

$combo{boot}->entry->signal_connect(changed => sub { change_image($boot_pic, $combo{boot}->entry->get_text) });

my ($x_box, $splash_box);
my $boot_warn = 1;
gtkadd($window,
       gtkpack_(Gtk2::VBox->new(0,0),
                ($splash_working ?
                 (1, gtkpack_(gtkset_border_width(Gtk2::VBox->new(0, 5), 5),
                              0, gtksignal_connect(gtkset_active(Gtk2::CheckButton->new(N("Use graphical boot")), $splash_mode),
                                               clicked => sub {
                                                   $splash_mode = !$splash_mode;
        					   if ($boot_warn && $no_bootsplash && $splash_mode) {
						       if ($in->ask_yesorno(N("Warning"),
						   [ N("Your system bootloader is not in framebuffer mode. To activate graphical boot, select a graphic video mode from the bootloader configuration tool.") . "\n" .
                                                     N("Do you want to configure it now ?") ])) {
                                                           enable_framebuffer();
                                                           #- it would be nice to get available themes for new cur_res here
                                                       };
                                                       $boot_warn = 0
						    }
                                                   $splash_box->set_sensitive($splash_mode);
                                               }),
                              1, gtkpack(gtkset_sensitive($splash_box = Gtk2::HBox->new(0, 0), $splash_mode),
                                       gtkpack__(Gtk2::VBox->new(0, 5),
                                                 N("Theme"),
                                                 $combo{boot},
						 #gtksignal_connect(Gtk2::CheckButton->new(N("Display theme\nunder console")), clicked => sub { invbool(\$keep_logo) }),
						 gtksignal_connect(gtkset_active(Gtk2::CheckButton->new(N("Display theme\nunder console")), $keep_logo), clicked => sub { invbool(\$keep_logo) })
                                                ),
                                       Gtk2::VSeparator->new,
                                       gtkpack__(Gtk2::VBox->new(0, 5),
                                                 $boot_pic))
                            ),
                 )
                 :
                 (1, gtkpack__(Gtk2::VBox->new(0, 5),
                               gtksignal_connect(gtkset_active(Gtk2::CheckButton->new(N("Launch the graphical environment when your system starts")),
                                                               $x_mode),
                                                 clicked => sub {
                                                     $x_box->set_sensitive(!$x_mode);
                                                     $x_mode = !$x_mode;
                                                 }),
                               gtkpack__(gtkset_sensitive($x_box = Gtk2::VBox->new(0, 0), $x_mode),
                                         gtkpack__(Gtk2::VBox->new(0, 0),
                                                   my @auto_buttons = gtkradio((N("No, I don't want autologin")) x 2,
                                                                               N("Yes, I want autologin with this (user, desktop)")),
                                                  ),
                                         my $auto_box = create_packtable({ col_spacings => 5, row_spacings => 5, homogenous => 1 },
                                                                         [ Gtk2::Label->new(N("Default user")), $user_combo ],
                                                                         [ Gtk2::Label->new(N("Default desktop")), $desktop_combo ],
                                                                        ),
                                        )
                              )
                 ),
                 0, create_okcancel({
                                     cancel_clicked => sub { ugtk2->exit(0) },
                                     ok_clicked => sub {
                                         Xconfig::various::runlevel($x_mode ? 5 : 3);
                                         if ($splash_working) {
                                             $splash_mode and update_bootsplash($combo{boot}->entry->get_text, $splash_mode, $keep_logo);
                                         } else {
                                             updateAutologin();
                                         }
                                         ugtk2->exit(0);
                                     }
                                    },
                                   ),

                )
               )
      );

if (!$splash_working) {
    $auto_buttons[1]->signal_connect('toggled' => sub { $auto_box->set_sensitive($auto_buttons[1]->get_active) });
    $auto_buttons[0]->signal_connect('toggled' => sub { $auto_box->set_sensitive(!$auto_buttons[0]->get_active) });
    $auto_buttons[1]->set_active(1) if $auto_mode->{autologin};
    $auto_buttons[0]->set_active(1) if !$auto_mode->{autologin};
    $x_box->set_sensitive($x_mode);
    $auto_box->set_sensitive($auto_mode->{autologin} ? 1 : 0);
}

$window->show_all;
gtkflush();
$w->main;
$in->exit(0);


sub lilo_choice() {
  ask:
    my $before = fs::fstab_to_string($all_hds);
    any::setupBootloader($in, $bootloader, $all_hds, $fstab, $ENV{SECURE_LEVEL});
    if ($before ne fs::fstab_to_string($all_hds)) {
	#- for /tmp using tmpfs when "clean /tmp" is chosen
	fs::write_fstab($all_hds);
    }
    any::installBootloader($in, $bootloader, $all_hds) or goto ask;
}



#-------------------------------------------------------------
# launch autologin functions
#-------------------------------------------------------------

sub updateAutologin() {
    my ($usern, $deskt) = ($user_combo->entry->get_text, $desktop_combo->entry->get_text);
    $::testing and return;
    if ($auto_buttons[1]->get_active) {
        any::set_autologin($usern, $deskt);
    } else {
        any::set_autologin();
    }
}

sub update_bootsplash {
    my ($theme, $splash_mode, $keep_logo) = @_;
    #- theme scripts will update SPLASH value in sysconfig file
    if (-x $switch_theme) {
	my $logo_console = $keep_logo ? 'theme' : 'no';
	if ($::testing) {
	    if ($splash_mode) {
		print "substInFile { s/^LOGO_CONSOLE=.*/LOGO_CONSOLE=$logo_console/ } $themes{sysconfig}\n";
		print "system($switch_theme, $theme)\n";
	    } else {
		print "system($remove_theme, $theme)\n";
	    }
 	} else {
	    if ($splash_mode) {
		substInFile { s/^LOGO_CONSOLE=.*/LOGO_CONSOLE=$logo_console/ } $themes{sysconfig};
		system($switch_theme, $theme);
	    } else {
		system($remove_theme, $theme);
	    }
 	}
    }
}

sub change_image {
    my ($boot_pic, $val) = @_;
    my $img_file = $themes{path} . $val . $themes{boot}{path} . "bootsplash-$cur_res.jpg";
    -f $img_file or return;
    my $boot_pixbuf = gtkcreate_pixbuf($img_file);
    $boot_pixbuf = $boot_pixbuf->scale_simple(300, 200, 'nearest');
    $boot_pic->set_from_pixbuf($boot_pixbuf);
}
sub enable_framebuffer() {
    my $vga = Xconfig::resolution_and_depth::from_bios($bootloader->{default_vga});
    my ($current_entry) = cat_('/proc/cmdline') =~ /^BOOT_IMAGE=(\S+)/;
    my %entries = (
                   $current_entry => 1
                  );
    local $::isWizard = 1;
    local $::Wizard_no_previous = 1;
    local $::Wizard_finished = 1;
    $::Wizard_title = N("Boot Style Configuration");
    eval {
        $in->ask_from(N("Video mode"),
                      N("Please choose a video mode, it will be applied to each of the boot entries selected below.
Be sure your video card supports the mode you choose."),
                      [
                       { label => N("Video mode"), val => \$vga,
                         list => [ '', Xconfig::resolution_and_depth::bios_vga_modes() ],
                         format => \&Xconfig::resolution_and_depth::to_string
                       },
                       map {
                           { text => $_->{label}, val => \$entries{$_->{label}}, type => 'bool' }
                       } grep { $_->{label} !~ /failsafe|floppy|memtest/ } @{$bootloader->{entries}}
                      ]);
        if ($vga) {
            $vga = $vga->{bios} if ref($vga);
            while (my ($label, $e) = each %entries) {
                $e or next;
                my $entry = find { $_->{label} eq $label } @{$bootloader->{entries}};
                $entry->{vga} = $vga;
            }
            bootloader::install($bootloader, $all_hds);
        }
    };
    die if $@ && $@ !~ /^wizcancel/;
    $::WizardWindow->destroy;
    $vga;
}
