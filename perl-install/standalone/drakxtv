#!/usr/bin/perl
# DrakxTV
# $Id$

# Copyright (C) 2002 MandrakeSoft (tvignaud@mandrakesoft.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

use lib qw(/usr/lib/libDrakX);

use standalone;     #- warning, standalone must be loaded very first, for 'explanations'

use interactive;
use strict;
use detect_devices;
use lang;
use log;
use common;

("@ARGV" =~ /--help|-h/) and die "usage: drakxtv [-h] [--help] [--no-guess]\n";


my $in = 'interactive'->vnew();

sub scan4channels {
#    xawtv has been installed by DrakX when/if it's detected a
#    tv card.
#    In the future, we might try to install xawtv if it'sn't there
#    as we're just a, xawtv wraper
#    -x "/usr/bin/scantv" or $in->do_pkgs->install('xawtv');
#    -x "/usr/bin/scantv" or { 
#{	   exec {'consolehelper'} $0, ("urpmi", "xawtv") or die N("consolehelper missing");
#    };
    if (! -x "/usr/bin/scantv") {
#	standalone::explanations("package xawtv isn't installed");
	   $in->ask_warn("XawTV isn't installed!", 
				  formatAlaTeX(N("XawTV isn't installed!


If you do have a TV card but DrakX has neither detected it (no bttv nor saa7134
module in \"/etc/modules\") nor installed xawtv, please send the
results of \"lspcidrake -v -f\" to \"install\@mandrakesoft.com\"
with subject \"undetected TV card\".


You can install it by typing \"urpmi xawtv\" as root, in a console.")));
	   
    } else {
	   my ($ftable_id, $norm);

#   my %freqtables = map {$i=$_;$i =~ s/ (.*)/-\1/;_($_) => $i} (...)
#   this table must be checked on each xawtv release:
	   my %freqtables = 
		  ("us-bcast" => N("USA (broadcast)"), "us-cable" => N("USA (cable)"), "us-cable-hrc" => N("USA (cable-hrc)"), "canada-cable" => N("Canada (cable)"),
		   "japan-bcast" => N("Japan (broadcast)"), "japan-cable" => N("Japan (cable)"), "china-bcast" => N("China (broadcast)"),
		   "europe-west" => N("West Europe"), "europe-east" => N("East Europe"), "italy" => N("Italy"), "ireland" => N("Ireland"), "france" => N("France [SECAM]"),
		   "newzealand" => N("Newzealand"), "australia" => N("Australia"),
		   "southafrica" => N("South Africa"),
		   "argentina" => N("Argentina"),
		   "australia-optus" => N("Australian Optus cable TV"),
		   -1 =>N("All")
		   );
#   Info: HRC means "Harmonically Related Carrier"

	   # default to pal since most people use that
	   $norm = "PAL";
	   if ("@ARGV" !~ /--help|-h/) {
		  my %countries =
			 (
			  "ar" => [ "argentina" ],
			  "au" => [ "australia" ],
			  "(br|fr)" => ["france", "SECAM"],
			  "ca" => [ "canada-cable" ],
			  "(ga|ie)" => [ "ireland" ],
			  "it" => [ "italy" ],
			  "jp" => [ "japan-bcast", "NTSC-JP"],
			  "nz" => [ "newzealand" ],
			  "(at|be|ch|de|eu|gb|se)" => [ "europe-west" ],
			  "us" => [ "us-bcast", "NTSC" ],
			  "za" => [ "southafrica" ],
			  "(zh|TW|Big5|CN.GB2312|CN)" => [ "china-bcast" ]
			  );

		  ($_) = lang::read('', $>);
		  foreach my $i (keys %countries) {
			 if (/($i|$i.UTF-8)$/i) {
				my $tbl = $countries{$i};
				$ftable_id = $tbl->[0];
				$norm = $tbl->[1] if ($tbl->[1]);
			 }
		  }
		  log::l("[drakxtv] guess lang=>$_, norm=>$norm, area=>$ftable_id");
	   }

	   if ($in->ask_from("TVdrake", N("Please,\ntype in your tv norm and country"),
					 [
					  { label => N("TV norm:"), val => \$norm, list => ["NTSC", "NTSC-JP","PAL", "PAL-M", "PAL-N", "PAL-NC", "SECAM"], type => 'combo' },
					  { label => N("Area:"), val => \$ftable_id, list => [keys %freqtables], format => sub { $freqtables{$_[0]} }, sort => 1},
					  ]
					 ))
	   {   my $wait = $in->wait_message(N("Please wait"),
								 N("Scanning for TV channels in progress ..."));
#       we provide scantv a bogus table (france) which will
#       will be ignored since "All" is selected (because of -a)
		  $ftable_id = "france -a " if ($ftable_id eq -1);
		  # Note that this'll be broken if/when we implement interactive::qt
		  my $use_X = $in->isa('interactive::gtk') && -x "/usr/X11R6/bin/xvt";
		  my $home = $ENV{HOME};
		  my $i = system(($use_X ? "xvt -T '" . N("Scanning for TV channels") . " ...' -e " : "") . 
				 "scantv -n $norm -f $ftable_id -o $home/.xawtv". 
				 ($use_X ? "" : " &>$home/tmp/scantv.log;"));
		  if ($i) {
			 $in->ask_warn(N("There was an error while scanning for TV channels"),
				       N("XawTV isn't installed!")) }
		  else {
			 standalone::explanations("created file $home/.xawtv");
			   $in->ask_warn(N("Have a nice day!"),
					 N("Now, you can run xawtv (under X Window!) !\n")) if (! $use_X);
		    };
		  
	   };
    }
}

my @devices = grep { ($_->{media_type} eq 'MULTIMEDIA_VIDEO') || $_->{driver} eq 'usbvision' } detect_devices::probeall(1);
if (@devices) {
    # TODO: That need some work for multiples TV cards
    foreach (@devices) {
	   if (( $< == 0) && (grep { $_->{driver} =~ '(bttv|saa7134|usbvision)' } @devices)) {
		  require harddrake::v4l;
		  require modules;
		  no strict 'subs';
		  modules::read_conf;
		  harddrake::v4l::config($in, $_->{driver});
		  modules::write_conf;
	   }
	   scan4channels();
} else {
    $in->ask_warn(N("No TV Card detected!"), formatAlaTeX(
											   N("No TV Card has been detected on your machine. Please verify that a Linux-supported Video/TV Card is correctly plugged in.


You can visit our hardware database at:


http://www.linux-mandrake.com/en/hardware.php3")));
}
$in->exit(0) if defined $in;


# TODO:
# - offer to sort channels after
# - use Video-Capture-V4l-0.221 ?
# - configure kwintv and zapping ? => they've already wizards :-(
# - install xawtv if needed through consolhelper
