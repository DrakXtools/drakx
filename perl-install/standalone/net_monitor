#!/usr/bin/perl

# NetMonitor

# Copyright (C) 1999-2004 Mandrakesoft
# Damien "Dam's" Krotkine
# Thierry Vignaud <tvignaud@mandrakesoft.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

use lib qw(/usr/lib/libDrakX);

use strict;
use standalone;     #- warning, standalone must be loaded very first, for 'explanations'

use c;
use interactive;
use ugtk2 qw(:create :helpers :wrappers);
use common;
use network::netconnect;
use network::tools;
use MDK::Common::Globals "network", qw($in);
use POSIX;

if ("@ARGV" =~ /--status/) { print connected(); exit(0) }
my $force = "@ARGV" =~ /--force/;
my $quiet = "@ARGV" =~ /--quiet/;
my $connect = "@ARGV" =~ /--connect/;
my $disconnect = "@ARGV" =~ /--disconnect/;
my ($default_intf) = "@ARGV" =~ /--defaultintf (\w+)/;

if ($force) {
    $connect and start_connection();
    $disconnect and stop_connection();
    $connect = $disconnect = 0;
}
$quiet and exit(0);
my $in = 'interactive'->vnew;


my $window1 = ugtk2->new(N("Network Monitoring"));
$window1->{rwindow}->signal_connect(delete_event => sub { ugtk2->exit(0) });

unless ($::isEmbedded) {
    $window1->{rwindow}->set_position('center');
    $window1->{rwindow}->set_title(N("Network Monitoring"));
    $window1->{rwindow}->set_border_width(5);
}
#$::isEmbedded or $window1->{rwindow}->set_size_request(580, 320);

my $colorr = gtkcolor(50400, 655, 20000);
my $colort = gtkcolor(55400, 55400, 655);
my $colora = gtkcolor(655, 50400, 655);
my $isconnected = -1;
my @interfaces;
my $monitor = {};
my $netcnx = {};
my $netc = {};
my $intf = {};
my $c_time = 0;
my $ct_tag;

my ($pixmap, $darea);
my ($width, $height) = (300, 150);

my $left_border = 50;
my $grid_interval = 30;
my $arrow_space = 6;
my $arrow_size = 5;

my $use_same_scale = 1;

network::netconnect::load_conf($netcnx, $netc, $intf);
network::netconnect::read_net_conf('', $netcnx, $netc);
MDK::Common::Globals::init(in => $in);

gtkadd($window1->{window},
       gtkpack_(Gtk2::VBox->new(0,5),
                1, gtkpack_(Gtk2::HBox->new(0,5),
                            1, my $notebook = Gtk2::Notebook->new,
                            0, gtkpack_(Gtk2::VBox->new(0,5),
                                        0, gtkadd(gtkset_shadow_type(Gtk2::Frame->new(N("Settings")), 'etched_out'),
                                                  gtkpack__(gtkset_border_width(Gtk2::HBox->new(0,0),5),
                                                            N("Connection type: "), 
                                                            my $label_cnx_type = Gtk2::Label->new("")),
                                                 ),
                                        1, gtkadd(gtkset_shadow_type(Gtk2::Frame->new(N("Global statistics")), 'etched_out'),
                                                  gtkpack__(gtkset_border_width(Gtk2::VBox->new(0,0),5),
                                                            create_packtable({ col_spacings => 1, row_spacings => 5, homogeneous => 1 },
                                                                             [ "", N("Instantaneous") , N("Average") ],
                                                                             [ Gtk2::WrappedLabel->new(N("Sending\nspeed:")),   my $label_st = Gtk2::Label->new(""), my $label_sta = Gtk2::Label->new("na") ],
                                                                             [ Gtk2::WrappedLabel->new(N("Receiving\nspeed:")), my $label_sr = Gtk2::Label->new(""), my $label_sra = Gtk2::Label->new("na") ],
                                                                            ),
                                                            gtkpack__(gtkset_border_width(Gtk2::HBox->new(0,0),5),
                                                                      N("Connection\ntime: "), 
                                                                      my $label_ct = Gtk2::Label->new(""),
                                                                     ),
                                                           )
                                                 ),
                                       )
                           ),
                0, gtksignal_connect(gtkset_active(new Gtk2::CheckButton(N("Use same scale for received and transmitted")), $use_same_scale), clicked => sub { $use_same_scale = !$use_same_scale }),
                0, gtkpack(create_hbox('edge'),
                           gtksignal_connect(my $button_connect = gtkset_sensitive(Gtk2::Button->new(N("Wait please")), 0), clicked => \&connection),
                           gtksignal_connect(my $button_close = Gtk2::Button->new(N("Close")), clicked => sub { ugtk2->exit(0) }),
                          ),
                0, my $statusbar = Gtk2::Statusbar->new
               ),
      );
$window1->{rwindow}->show_all;
$window1->{rwindow}->realize;
my $gct = Gtk2::Gdk::GC->new($window1->{rwindow}->window);
$gct->set_foreground($colort);
my $gcr = Gtk2::Gdk::GC->new($window1->{rwindow}->window);
$gcr->set_foreground($colorr);
my $gca = Gtk2::Gdk::GC->new($window1->{rwindow}->window);
$gca->set_foreground($colora);
$statusbar->push(1, N("Wait please, testing your connection..."));
$window1->{rwindow}->show_all;

Glib::Timeout->add(1000, \&rescan);
my $time_tag2 = Glib::Timeout->add(1000, \&update);

update();
rescan();

gtkflush() while $isconnected == -2 || $isconnected == -1;

Glib::Source->remove($time_tag2);
$time_tag2 = Glib::Timeout->add(20000, \&update);

connection() if $connect && !$isconnected || $disconnect && $isconnected;

my $tool_pid;

$SIG{CHLD} = sub {
    my $child_pid;
    do { 
        $child_pid = waitpid(-1, POSIX::WNOHANG);
        if ($tool_pid eq $child_pid) {
            undef $tool_pid;
            $button_connect->set_sensitive(1);
            $button_close->set_sensitive(1);
        }
    } while $child_pid > 0;
};


$window1->main;
ugtk2->exit(0);

my $during_connection;
my $first;

sub bg_command_as_root {
    my $name = shift;
    run_program::raw({ detach => 1 }, [ 'consolehelper', $name ], @_);
}

sub start_connection() {
    $default_intf and bg_command_as_root('/sbin/ifup', $default_intf);
}

sub stop_connection() {
    $default_intf and bg_command_as_root('/sbin/ifdown', $default_intf);
}

sub connection() {
    $during_connection = 1;
    my $wasconnected = $isconnected;

    $button_connect->set_sensitive(0);
    $button_close->set_sensitive(0);
    $statusbar->pop(1);
    $statusbar->push(1, $wasconnected ? N("Disconnecting from Internet ") : N("Connecting to Internet "));
    if ($wasconnected == 1) {
	$c_time = time();
	$ct_tag = Glib::Timeout->add(1000, sub {
				       my ($sec, $min, $hour) = gmtime(time() - $c_time);
				       my $e = sprintf("%02d:%02d:%02d", $hour, $min, $sec);
				       $label_ct->set_label($e); 1 })
    } else { Glib::Source->remove($ct_tag) }
    my $nb_point = 1;
    $first = 1;

    my $_tag = Glib::Timeout->add(1000, sub {
				   $statusbar->pop(1);
				   $statusbar->push(1, ($wasconnected  == 1 ? N("Disconnecting from Internet ") : N("Connecting to Internet "))
						    . join('', map { "." } (1..$nb_point)));
				   $nb_point++;
				   if ($nb_point  < 4) { return 1 }
				   my $ret = 1;

				   my $isconnect = test_connected(0);

				   if ($nb_point < 20) {
                                       if ($first == 1)  { # first time
				           if ($isconnect == -2) { # wait for last test to finish
    				               test_connected(2); # not yet terminated, try to cancel it
				               return 1;
					   }
				           test_connected(1);  # initiates new connection test
				           $first = 0;
				           return 1;
				       }
				       if ($isconnect == -2) { return 1 } # no result yet, wait.
				       if ($isconnect == $wasconnected) {
				           # we got a test result; but the connection state did not change; retry.
                                           test_connected(1);
				           return 1;
				       }
				   }
                                   # either we got a result, or we timed out.
				   if ($isconnect != -2 || $nb_point > 20) {
				            $isconnected = $isconnect;
					    $ret = 0;
					    $statusbar->pop(1);
					    $statusbar->push(1, $wasconnected ? ($isconnected ?
									  N("Disconnection from Internet failed.") :
									  N("Disconnection from Internet complete.")) :
						     ($isconnected ?
						       N("Connection complete.") :
						       N("Connection failed.\nVerify your configuration in the Mandrake Control Center."))
						    );
				            my $delay = 1000;
					    # keep the message displayed longer if there is a problem.
				    	    if ($isconnected == $wasconnected) { $delay = 5000 }
				            my $_tag3 = Glib::Timeout->add($delay, sub {

						  $button_connect->set_sensitive(1);
				    		  $button_close->set_sensitive(1);
				    		  undef $during_connection;
						  update();
						  return 0;
                            });
                            }
                       return $ret;
                   });

    gtkflush();

    if ($wasconnected == 1) {
        $tool_pid = stop_connection();
    } else {
        $tool_pid = start_connection();
    }
}

sub graph_window_width() { $width - $left_border }

sub rescan() {
    get_val();
    foreach (@interfaces) {
	my $intf = $_;
	my $recv = $monitor->{$intf}{val}[0];
	my $transmit = $monitor->{$intf}{val}[8];
	my $refr = $monitor->{$intf}{referencer};
	my $reft = $monitor->{$intf}{referencet};
	$monitor->{sr} += $recv - $refr;
	$monitor->{st} += $transmit - $reft;

	$monitor->{$intf}{recva} += $recv - $refr;
	$monitor->{$intf}{recvan}++;
	if ($monitor->{$intf}{recvan} > 9) {
	    push(@{$monitor->{$intf}{stack_ra}}, $monitor->{$intf}{recva}/10);
	    $monitor->{$intf}{recva} = $monitor->{$intf}{recvan} = 0;
	} else { push(@{$monitor->{$intf}{stack_ra}}, -1) }
	shift @{$monitor->{$intf}{stack_ra}} if @{$monitor->{$intf}{stack_ra}} > graph_window_width();

	push(@{$monitor->{$intf}{stack_r}}, $recv - $refr);
	shift @{$monitor->{$intf}{stack_r}} if @{$monitor->{$intf}{stack_r}} > graph_window_width();
	$monitor->{$intf}{labelr}->set_label(formatXiB($recv - $monitor->{$intf}{initialr}));
	$monitor->{$intf}{referencer} = $recv;

	$monitor->{$intf}{transmita} += $transmit - $reft;
	$monitor->{$intf}{transmitan}++;
	if ($monitor->{$intf}{transmitan} > 9) {
	    push(@{$monitor->{$intf}{stack_ta}}, $monitor->{$intf}{transmita}/10);
	    $monitor->{$intf}{transmita} = $monitor->{$intf}{transmitan} = 0;
	} else { push(@{$monitor->{$intf}{stack_ta}}, -1) }
	shift @{$monitor->{$intf}{stack_ta}} if @{$monitor->{$intf}{stack_ta}} > graph_window_width();

	push(@{$monitor->{$intf}{stack_t}}, $transmit - $reft);
	shift @{$monitor->{$intf}{stack_t}} if @{$monitor->{$intf}{stack_t}} > graph_window_width();
	$monitor->{$intf}{labelt}->set_label(formatXiB($transmit - $monitor->{$intf}{initialt}));
	$monitor->{$intf}{referencet} = $transmit;

	draw_monitor($monitor->{$intf}, $intf);
    }
    $label_sr->set_label(formatXiB($monitor->{sr}) . "/s");
    $label_st->set_label(formatXiB($monitor->{st}) . "/s");
    $monitor->{sra} += $monitor->{sr};
    $monitor->{sta} += $monitor->{st};
    $monitor->{nba}++;
    if ($monitor->{nba} > 9) {
	$label_sra->set_label(formatXiB($monitor->{sra}/10) . "/s");
	$label_sta->set_label(formatXiB($monitor->{sta}/10) . "/s");
	$monitor->{sra} = 0;
	$monitor->{sta} = 0;
	$monitor->{nba} = 0;
    }
    $label_cnx_type->set_label($netcnx->{type});
    $monitor->{$_} = 0 foreach 'sr', 'st';
    1;
}

sub get_val() {
    my $a = cat_("/proc/net/dev");
    $a =~ s/^.*?\n.*?\n//;
    $a =~ s/^\s*lo:.*?\n//;
    my @line = split(/\n/, $a);
    my @interfaces = c::get_netdevices();
    map {
	s/\s*(\w*)://;
	my $intf = $1;
     if (member($intf, @interfaces)) {
         $monitor->{$intf}{val} = [ split() ];
         $monitor->{$intf}{intf} = $intf;
         $intf;
     } else { () }
    } @line;
}

sub change_color {
    my ($color) = @_;
    my $dialog = _create_dialog(N("Color configuration"));
    my $doit;
    $dialog->vbox->add(my $colorsel = Gtk2::ColorSelection->new);
    gtkpack($dialog->action_area,
            gtksignal_connect(Gtk2::Button->new(N("Cancel")), clicked => sub {
                                  $doit = 1;
                                  $dialog->destroy;
                              }),
            gtksignal_connect(Gtk2::Button->new(N("Ok")), clicked => sub { 
                                  $dialog->destroy;
                              }),
           );
    $colorsel->set_current_color($color);
    $dialog->show_all;
    $dialog->run;
    $doit ? $colorsel->get_current_color : $color;
}

my ($scale_r, $scale_t);
$scale_r = $scale_t = $height;

sub scale_tranmistted($) { $_[0] * $scale_t }
sub scale_received($) { $_[0] * $scale_r }

sub update() {
     if (!$during_connection) {
        my $isconnect = test_connected(0);
        if ($isconnect != -2) {
	    $isconnected = $isconnect; # save current state
	    $isconnect = test_connected(1); # start new test
       }
    };

    my @intfs = get_val(); # get values from /proc file system
    foreach (@intfs) {
	my $intf = $_;
	if (!member($intf,@interfaces)) {
	    $default_intf ||= $intf;
	    $monitor->{$intf}{initialr} = $monitor->{$intf}{val}[0];
	    $monitor->{$intf}{initialt} = $monitor->{$intf}{val}[8];
	    $darea->{$intf} = Gtk2::DrawingArea->new;
	    $darea->{$intf}->set_events(["pointer_motion_mask"]);
	    $notebook->append_page(gtkshow(my $page = gtkpack_(Gtk2::VBox->new(0,0),
					       0, gtkpack__(gtkset_border_width(Gtk2::HBox->new(0,0), 5),
							    gtksize($darea->{$intf}, $width, $height)),
					       0, gtkpack_(Gtk2::HBox->new(0,0),
							    1, gtkpack__(Gtk2::VBox->new(0,0),
								      gtkpack__(gtkset_border_width(Gtk2::HBox->new(0,5), 5),
										   gtksignal_connect(my $button_t = gtkset_relief(Gtk2::Button->new, 'none'), clicked => sub {
													 $colort = change_color($colort);
													 $gct->set_foreground($colort);
													 $_[0]->queue_draw;
												     }),
										   N("sent: "), $monitor->{$intf}{labelt} = Gtk2::Label->new("0")),
								      gtkpack__(gtkset_border_width(Gtk2::HBox->new(0,5), 5),
										   gtksignal_connect(my $button_r = gtkset_relief(Gtk2::Button->new, 'none'), clicked => sub {
													 $colorr = change_color($colorr);
													 $gcr->set_foreground($colorr);
													 $_[0]->queue_draw;
												     }),
										   N("received: "), $monitor->{$intf}{labelr} = Gtk2::Label->new("0")),
								      gtkpack__(gtkset_border_width(Gtk2::HBox->new(0,5), 5),
										   gtksignal_connect(my $button_a = gtkset_relief(Gtk2::Button->new, 'none'), clicked => sub {
													 $colora = change_color($colora);
													 $gca->set_foreground($colora);
													 $_[0]->queue_draw;
												     }),
										   N("average"))
								     ),
							    0, gtkpack__(gtkset_border_width(Gtk2::VBox->new(0,0), 5),
							      gtkadd(gtkset_shadow_type(Gtk2::Frame->new(N("Local measure")), 'etched_out'),
								     gtkpack__(gtkset_border_width(Gtk2::VBox->new(0,0), 5),
									       gtkpack__(Gtk2::HBox->new(0,0),
											 N("sent: "),
											 my $measure_t = Gtk2::Label->new("0")
											),
									       gtkpack__(Gtk2::HBox->new(0,0),
											 N("received: "),
											 my $measure_r = Gtk2::Label->new("0")
											)
									      )
									)
									)
							  )
					       )),
				   Gtk2::Label->new($intf));
	    foreach my $i ([$button_t, $gct], [$button_r, $gcr], [$button_a, $gca]) {
		$i->[0]->add(gtksignal_connect(gtkshow(gtksize(gtkset_size_request(Gtk2::DrawingArea->new, 10, 10), 10, 10)), expose_event => sub { $_[0]->window->draw_rectangle($i->[1], 1, 0, 0, 10, 10) }));
	    }
	    $monitor->{$intf}{page} = $notebook->page_num($page);
         $darea->{$intf}->realize;
         $pixmap->{$intf} = Gtk2::Gdk::Pixmap->new($darea->{$intf}->window, $width, $height, $darea->{$intf}->window->get_depth);
	    $monitor->{$intf}{referencer} = $monitor->{$intf}{val}[0];
	    $monitor->{$intf}{referencet} = $monitor->{$intf}{val}[8];
	    $pixmap->{$intf}->draw_rectangle($darea->{$intf}->style->black_gc, 1, 0, 0, $width, $height);
	    $darea->{$intf}->signal_connect(motion_notify_event => sub { 
                                    my (undef, $e) = @_;
                                    my $x = $e->x - 50;
                                    my $received    = $x >= 0 ? $monitor->{$intf}{stack_r}[$x] : 0;
                                    my $transmitted = $x >= 0 ? $monitor->{$intf}{stack_t}[$x] : 0;
                                    $measure_r->set_label(formatXiB($received));
                                    $measure_t->set_label(formatXiB($transmitted));
                                });
	    $darea->{$intf}->signal_connect(expose_event => sub {
                         $darea->{$intf}->window->draw_drawable($darea->{$intf}->style->bg_gc('normal'), $pixmap->{$intf}, 0, 0, 0, 0, $width, $height);
                     });
	}
    }
    foreach (@interfaces) {
	my $intf = $_;
     $notebook->remove_page($monitor->{$intf}{page}) unless member($intf,@intfs);
    }
    for (my $num_p = 0; $num_p < $notebook->get_n_pages; $num_p++) {
        if ($notebook->get_tab_label_text($notebook->get_nth_page($num_p)) eq $default_intf) {
            $notebook->set_current_page($num_p);
            last;
        }
    }
    @interfaces = @intfs;
	if ($isconnected != -2 && $isconnected != -1 && !$during_connection) {
	    if ($isconnected == 1 && !in_ifconfig($netcnx->{NET_INTERFACE})) {
		$isconnected = 0;
		$statusbar->pop(1);
		$statusbar->push(1, N("Warning, another internet connection has been detected, maybe using your network"));
	    } else {
		#- translators : $netcnx->{type} is the type of network connection (modem, adsl...)
		$statusbar->pop(1);
		$statusbar->push(1, $isconnected == 1 ? N("Connected") : N("Not connected"));
	    }
            $button_connect->set("label", $isconnected == 1 ? N("Disconnect %s", $netcnx->{type}) : N("Connect %s", $netcnx->{type}));
	    $button_connect->set_sensitive($default_intf || scalar(@interfaces));
	}
    if (!(-e $network::tools::connect_file && -e $network::tools::disconnect_file)) {
	$button_connect->set_sensitive(0);
	$button_connect->set("label", N("No internet connection configured"));
    }
    1;
}

sub in_ifconfig {
    my ($intf) = @_;
    -x '/sbin/ifconfig' or return 1;
    $intf eq '' and return 1;
    `/sbin/ifconfig` =~ /$intf/;
}

sub draw_monitor {
    my ($o, $intf) = @_;
    defined $darea->{$intf} or return;
    my $pixmap = $pixmap->{$intf};
    $pixmap->draw_rectangle($darea->{$intf}->style->black_gc, 1, 0, 0, $width, $height);
    my $maxr = 0;
    foreach (@{$o->{stack_r}}) { $maxr = $_ if $_ > $maxr }
    my $maxt = 0;
    foreach (@{$o->{stack_t}}) { $maxt = $_ if $_ > $maxt }

    my ($graph_maxr, $graph_maxt);
    if ($use_same_scale) {
        $graph_maxr = $graph_maxt = ($maxr + $maxt)/2;
    } else {
        $graph_maxr = $maxr;
        $graph_maxt = $maxt;
    }
    $scale_r = ($height/2) / max($graph_maxr, 1);
    $scale_t = ($height/2) / max($graph_maxt, 1);

    my $step = $left_border - 1;
    foreach (@{$o->{stack_t}}) {
	$pixmap->draw_rectangle($gct, 1, $step, 0, 1, scale_tranmistted($_));
	$step++;
    }
    $step = $left_border - 1;
    my ($av1, $av2, $last_a);
    foreach (@{$o->{stack_ta}}) {
	if ($_ != -1) {
	    if (!defined $av1) { $av1 = $_ } else { defined $av2 or $av2 = $_ }
	    if ($av1 && $av2) {
		$pixmap->draw_line($gca, $step-15, scale_tranmistted($av1), $step-5, scale_tranmistted($av2));
		$av1 = $av2;
		undef $av2;
		$last_a = $step - $left_border + 1;
	    }
	}
	$step++;
    }
    $step = $left_border - 1;
    foreach (@{$o->{stack_r}}) {
	$pixmap->draw_rectangle($gcr, 1, $step, $height-scale_received($_), 1, scale_received($_));
	$step++;
    }
    $step = $left_border - 1;
    $av1 = $av2 = undef;
    foreach (@{$o->{stack_ra}}) {
	if ($_ != -1) {
	    if (!defined $av1) { $av1 = $_ } else { defined $av2 or $av2 = $_ }
	    if (defined $av1 && defined $av2) {
		$pixmap->draw_line($gca, $step-15, $height-scale_received($av1), $step-5, $height-scale_received($av2));
		$av1 = $av2;
		undef $av2;
	    }
	}
	$step++;
    }

    my $gcl = Gtk2::Gdk::GC->new($darea->{$intf}->window);
    $gcl->set_foreground($darea->{$intf}->style->white);
    $gcl->set_line_attributes(1, 'on-off-dash', 'not-last', 'round');

    my ($pix_maxr, $pix_maxt);
    if ($last_a) {
        $pix_maxr = $height - scale_received(@{$o->{stack_ra}}[$last_a]);
        $pix_maxt = scale_tranmistted(@{$o->{stack_ta}}[$last_a]);
    } else {
        $pix_maxr = $height - scale_received(@{$o->{stack_r}}[@{$o->{stack_r}}-1]);
        $pix_maxt = scale_tranmistted(@{$o->{stack_t}}[@{$o->{stack_t}}-1]);
    }

    my $x_l = $arrow_size + 1;
    my $y_l;

    #- "transmitted" arrow
    $y_l = max($arrow_space, min($pix_maxt, $pix_maxr - 2*$arrow_size - $arrow_space));
    $pixmap->draw_line($gct, $x_l, 0, $x_l, $y_l);
    $pixmap->draw_line($gct, $x_l-1, 0, $x_l-1, $y_l);
    $pixmap->draw_line($gct, $x_l+1, 0, $x_l+1, $y_l);
    $pixmap->draw_polygon($gct, 1, $x_l-$arrow_size, $y_l, $x_l+$arrow_size, $y_l, $x_l, $y_l+$arrow_size);

    #- "received" arrow
    $y_l = min($height - $arrow_space, max($pix_maxr, $y_l + 2*$arrow_size + $arrow_space));
    $pixmap->draw_line($gcr, $x_l, $height, $x_l, $y_l);
    $pixmap->draw_line($gcr, $x_l-1, $height, $x_l-1, $y_l);
    $pixmap->draw_line($gcr, $x_l+1, $height, $x_l+1, $y_l);
    $pixmap->draw_polygon($gcr, 1, $x_l-$arrow_size, $y_l, $x_l+$arrow_size, $y_l, $x_l, $y_l-$arrow_size);

    for (my $i = $grid_interval; $i <= $height - $grid_interval; $i += $grid_interval) {
	$pixmap->draw_line($gcl, $left_border, $i, $width, $i);
	my ($gc2, $text);
        if ($i > max($grid_interval, $use_same_scale ? $pix_maxt : $height/2)) {
	    $text = formatXiB(($height-$i)/$scale_r);
	    $gc2 = $gcr;
        } else {
	    $text = formatXiB($i/$scale_t);
	    $gc2 = $gct;
        }
        $pixmap->draw_layout($gc2, 45-string_width($darea->{$intf}, $text), $i-5, $darea->{$intf}->create_pango_layout($text));
    }
    $darea->{$intf}->queue_draw;
}


sub test_connected {
    my ($arg) = @_;
    $::testing || network::tools::test_connected($arg);
}
