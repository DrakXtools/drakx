#!/usr/bin/perl

# DrakConnect

# Copyright (C) 1999-2002 MandrakeSoft (damien@mandrakesoft.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

use lib qw(/usr/lib/libDrakX);

use standalone;     #- warning, standalone must be loaded very first, for 'explanations'

use interactive;
use common;
use network::netconnect;
use network::ethernet;
use network::tools;
use network;
use c;
use MDK::Common;
use any;
use network::isdn;
use network::adsl;
use MDK::Common::Globals "network", qw($in $prefix $disconnect_file $connect_prog $connect_file $disconnect_file);

my $xpm_path = "/usr/share/libDrakX/pixmaps";
$::isWizard = "@ARGV" =~ /--wizard/;
$::expert = "@ARGV" =~ /--expert/;
local $_ = join '', @ARGV;

#/-h/ and die "usage: drakconnect[--xf3] [--beginner] [--expert] [--auto] [--noauto] [--skiptest] [--testing]\n";

my $netcnx = {};
my $netc = {};
my $intf = {};
my @conx_type = ('modem', 'isdn_internal', 'isdn_external', 'adsl', 'cable', 'lan');

#$::wizard_xpm = "/usr/share/pixmaps/internet.xpm";

my $in = 'interactive'->vnew('su', 'network');
!$::isEmbedded && $in->isa('interactive::gtk') and $::isWizard = 1;
$::Wizard_pix_up = "wiz_drakconnect.png";
$::Wizard_title = "Network & Internet Configuration";

MDK::Common::Globals::init(
	      in => $in,
	      prefix => '',
	      connect_file => "/etc/sysconfig/network-scripts/net_cnx_up",
	      disconnect_file => "/etc/sysconfig/network-scripts/net_cnx_down",
	      connect_prog => "/etc/sysconfig/network-scripts/net_cnx_pg"
	     );

$::isEmbedded && ref($in) =~ /gtk/ or goto dd;
require Gtk;
init Gtk;
require my_gtk;
import my_gtk qw(:helpers :wrappers);
my $expert_mode = 0;
network::netconnect::read_net_conf('', $netcnx, $netc);
any::load_category_no_message('net', undef);
my @all_cards = network::ethernet::conf_network_card_backend ($netc, $intf, undef, undef, undef, undef);
network::netconnect::load_conf($netcnx, $netc, $intf);

my $window1 = $::isEmbedded ? new Gtk::Plug ($::XID) : new Gtk::Window -toplevel;
$window1->signal_connect (delete_event => sub { Gtk->exit(0) });
$window1->set_position(1);
$window1->set_title(_("Network configuration (%d adapters)", @all_cards));
$window1->border_width(10);
$::isEmbedded or $window1->set_usize(500, 400);
my $vbox1 = new Gtk::VBox(0,10);
$window1->add($vbox1);
my $hbox1 = new Gtk::HBox(0,0);
$vbox1->pack_start($hbox1,0,0,0);
$hbox1->pack_start(new Gtk::Label(_("Profile: ")),0,0,0);

my $combo1 = new Gtk::Combo;
$combo1->set_popdown_strings (network::netconnect::get_profiles());
my $old_profile = $netcnx->{PROFILE};
$combo1->entry->set_text($netcnx->{PROFILE} ? $netcnx->{PROFILE} : "default");
$combo1->entry->set_editable(0);
$hbox1->pack_start($combo1,0,0,0);
my $button_del = new Gtk::Button(_("Del profile..."));
$button_del->signal_connect(clicked => sub {
				 my $dialog = new Gtk::Dialog();
				 $dialog->set_position(1);
				 $dialog->vbox->set_border_width(10);
				 $dialog->signal_connect (delete_event => sub { Gtk->main_quit() });
				 $dialog->vbox->pack_start(new Gtk::Label(_("Profile to delete:")),1,1,0);
 				 my $combo_dialog = new Gtk::Combo;
				 $combo_dialog->set_popdown_strings (grep { ! /default/ } network::netconnect::get_profiles());
				 $combo_dialog->entry->set_editable(0);
				 $dialog->vbox->pack_start($combo_dialog,1,1,0);
				 my $bbox_dialog = new Gtk::HButtonBox;
				 $dialog->action_area->add($bbox_dialog);
				 $bbox_dialog->set_layout(-end);
				 my $button_ok = new Gtk::Button _("OK");
				 $button_ok->signal_connect (clicked => sub {
								  network::netconnect::del_profile($netcnx, $combo_dialog->entry->get_text());
								  $netcnx->{PROFILE} eq $combo_dialog->entry->get_text() and $netcnx->{PROFILE} = "default";
								  Gtk->main_quit();
							      });
				 $bbox_dialog->add($button_ok);
				 my $button_cancel = new Gtk::Button _("Cancel");
				 $button_cancel->signal_connect (clicked => sub { Gtk->main_quit() });
				 $bbox_dialog->add($button_cancel);
				 $dialog->show_all;
				 $dialog->set_modal(1);
				 Gtk->main();
				 $dialog->destroy;
				 $combo1->entry->set_text((-e "/etc/sysconfig/network-scripts/drakconnect_conf." . $combo1->entry->get_text) ? $combo1->entry->get_text : "default");
				 $combo1->set_popdown_strings(network::netconnect::get_profiles());
				 apply();
			     });
$hbox1->pack_start($button_del,0,0,5);
$button_del->set_sensitive(network::netconnect::get_profiles() > 1);
my $button_new = new Gtk::Button(_("New profile..."));
$button_new->signal_connect(clicked => sub {
				 my $dialog = new Gtk::Dialog();
				 $dialog->set_position(1);
				 $dialog->vbox->set_border_width(10);
				 $dialog->signal_connect (delete_event => sub { Gtk->main_quit() });
				 $dialog->vbox->pack_start(new Gtk::Label(_("Name of the profile to create (the new profile is created as a copy of the current one) :")),1,1,0);
				 my $entry_dialog = new Gtk::Entry;
				 $dialog->vbox->pack_start($entry_dialog,1,1,0);
				 my $bbox_dialog = new Gtk::HButtonBox;
				 $dialog->action_area->add($bbox_dialog);
				 $bbox_dialog->set_layout(-end);
				 my $button_ok = new Gtk::Button _("OK");
				 $button_ok->signal_connect (clicked => sub {
								  network::netconnect::add_profile($netcnx, $entry_dialog->get_text());
								  $netcnx->{PROFILE} = $entry_dialog->get_text();
								  Gtk->main_quit();
							      });
				 $bbox_dialog->add($button_ok);
				 my $button_cancel = new Gtk::Button _("Cancel");
				 $button_cancel->signal_connect (clicked => sub { Gtk->main_quit() });
				 $bbox_dialog->add($button_cancel);
				 $dialog->show_all;
				 $dialog->set_modal(1);
				 Gtk->main();
				 $dialog->destroy;
				 $combo1->entry->set_text((-e "/etc/sysconfig/network-scripts/drakconnect_conf." . $netcnx->{PROFILE}) ? $netcnx->{PROFILE} : "default");
				 $combo1->set_popdown_strings(network::netconnect::get_profiles());
});
$hbox1->pack_start($button_new,0,0,5);
my $hbox2 = new Gtk::HBox(0,0);
$vbox1->pack_start($hbox2,0,0,0);
$hbox2->pack_start(new Gtk::Label(_("Hostname: ")),0,0,0);
my $hostname = chomp_(`hostname`);
my $label_host = new Gtk::Label($hostname);
$hbox2->pack_start($label_host,0,0,0);

#$vbox1->pack_start(new Gtk::HSeparator,1,1,5);

my $frame1 = new Gtk::Frame (_("Internet access"));
$vbox1->pack_start($frame1,1,1,0);
my $vbox_frame1 = new Gtk::VBox(0,0);
$vbox_frame1->set_border_width(5);
$frame1->add($vbox_frame1);
my $table1 = new Gtk::Table (3,3, 0);
$table1->set_border_width(5);
$table1->set_row_spacings(5);
$table1->set_col_spacings(5);
#$table1->border_width(10);
$vbox_frame1->pack_start($table1,1,1,0);
#attach (table, child, left_attach, right_attach, top_attach, bottom_attach, xoptions, yoptions, xpadding, ypadding)
#$table->attach($button[0], 0, 1, 0, 1, {expand=>1,fill=>1}, {expand=>1,fill=>1},0,0);
$table1->attach(new Gtk::Label(_("Type:")), 0, 1, 0, 1, 'fill', 'fill',0,0);
my $label4 = new Gtk::Label($netcnx->{type});
$table1->attach($label4, 1, 2, 0, 1, 'fill', 'fill',0,0);
my $label5 = new Gtk::Label($netcnx->{type} eq 'lan' ? _("Gateway:") : _("Interface:"));
$table1->attach($label5, 0, 1, 1, 2, 'fill', 'fill',0,0);
my $label6 = new Gtk::Label($netcnx->{type} eq 'lan' ? $netc->{GATEWAY} : $netcnx->{NET_INTERFACE});
$table1->attach($label6, 1, 2, 1, 2, 'fill', 'fill',0,0);
my $isconnected = -1;
#-sub connected_local {
#-    print "in connected local\n";
#-    my $w = $in->wait_message('', _("Testing your connection..."), 1);
#-    Gtk->main_iteration while Gtk->events_pending;
#-    $isconnected = connected();
#-}
my $label7 = new Gtk::Label(_("Status:"));
$table1->attach($label7, 0, 1, 2, 3, 'fill', 'fill',0,0);
my $label8 = new Gtk::Label(_("Testing your connection..."));
$table1->attach($label8, 1, 2, 2, 3, 'fill', 'fill',0,0);

my $warning_label1 = new Gtk::Label("");
$vbox_frame1->pack_start($warning_label1,0,0,0);
my $button2 = new Gtk::Button(_("Wait please"));
$button2->set_sensitive(0);
$button2->signal_connect(clicked => sub {
			     if (!$isconnected && cat_($connect_prog) =~ m|/usr/bin/kppp| && -e '/usr/bin/kppp') {
				 run_program::rooted($prefix, "/usr/bin/kppp &");
			     } elsif (!$isconnected) {
				 connect_backend();
			     } else {
				 disconnect_backend();
			     }
			     update2();
			 });

$table1->attach($button2, 2, 3, 2, 3, 'fill', 'fill',0,0);

#$table1->attach($button1, 2, 3, 1, 2, 'fill', 'fill',0,0);

my $hbox_frame1_button = new Gtk::HBox(0,0);
my $button1 = new Gtk::Button(_("Configure Internet Access..."));
$button1->signal_connect(clicked => [ \&configure_net, '', $netcnx, $netc, $intf]);
$hbox_frame1_button->pack_start($button1, 0, 0, 0);
$vbox_frame1->pack_start($hbox_frame1_button,0,0,0);

#$vbox1->pack_start(new Gtk::HSeparator,1,1,5);

my $frame2 = new Gtk::Frame (_("LAN configuration"));
$vbox1->pack_start($frame2,1,1,0);
my $vbox2 = new Gtk::VBox(0,0);
$vbox2->set_border_width(5);
$frame2->add($vbox2);
my $clist1 = new_with_titles Gtk::CList("", _("Interface"), _("IP address"), _("Protocol"), _("Driver"), _("State"));
$clist1->set_column_auto_resize($_,1) foreach (0..4);
$clist1->column_titles_passive();
$clist1->set_shadow_type('etched_out');
$vbox2->pack_start($clist1, 0, 0, 5);
#$scrolled1->add_with_viewport($table2);

my $ip_regexp = qr/(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/;

build_clist();

my $hbox3 = new Gtk::HBox(0,0);
my $button3 = new Gtk::Button(_("Configure Local Area Network..."));
$button3->signal_connect(clicked => [ \&configure_lan, '', $netcnx, $netc, $intf]);
$hbox3->pack_start($button3, 0, 0, 0);
$vbox2->pack_start($hbox3, 0, 0, 0);

#$vbox1->pack_start(new Gtk::HSeparator,0,0,5);

my $bbox0 = new Gtk::HButtonBox;
$vbox1->pack_start($bbox0,0,0,0);
$bbox0->set_layout(-end);


$bbox0->add(new Gtk::Label(_("Click here to launch the wizard ->")));
my $button_wizard = new Gtk::Button _("Wizard...");
$button_wizard->signal_connect(clicked => sub {
				     $::isWizard = 1;
				     system("drakconnect --wizard");
# netconnect::intro('', $netcnx, $in);
				     $combo1->entry->set_text((-e "/etc/sysconfig/network-scripts/drakconnect_conf." . $combo1->entry->get_text) ? $combo1->entry->get_text : "default");
				     network::netconnect::load_conf($netcnx, $netc, $intf);
				     update();
				 });
$bbox0->add($button_wizard);

$vbox1->pack_start(new Gtk::HSeparator,0,0,5);

my $bbox1 = new Gtk::HButtonBox;
$vbox1->pack_start($bbox1,0,0,0);
$bbox1->set_layout(-end);
#$bbox1->set_border_width(5);

my $button_expert = new Gtk::Button _("Expert Mode");
$button_expert->signal_connect (clicked => sub {
				     foreach ($button1, $button3) { $expert_mode ? $_->hide() : $_->show() }
				     $button_expert->child->set($expert_mode ? _("Expert Mode") : _("Normal Mode"));
				     $expert_mode = !$expert_mode;
				 });
$bbox1->add($button_expert);

my $button_apply = new Gtk::Button _("Apply");
$button_apply->signal_connect (clicked => sub {
				 apply();
			     });
$button_apply->set_sensitive(0);
$bbox1->add($button_apply);

my $button_cancel = new Gtk::Button _("Cancel");
$button_cancel->signal_connect (clicked => sub {
				     $combo1->entry->set_text($old_profile);
				     update();
				     quit_global();
				 });
$bbox1->add($button_cancel);
my $button_ok = new Gtk::Button _("OK");
$button_ok->signal_connect (clicked => sub {
				 my $dialog = new Gtk::Dialog();
				 $dialog->set_position(1);
				 $dialog->vbox->set_border_width(10);
				 my $label = new Gtk::Label(_("Please Wait... Applying the configuration"));
				 $dialog->signal_connect (delete_event => sub { Gtk->main_quit() });
				 $dialog->vbox->pack_start($label,1,1,20);
				 $dialog->show_all;
				 Gtk->main_iteration while Gtk->events_pending;
				 apply();
				 $dialog->destroy;
				 update();
				 quit_global();
			     });
$bbox1->add($button_ok);
$combo1->entry->signal_connect('changed', sub {
#				    connected() and disconnect_backend();
				    network::netconnect::set_profile($netcnx, $combo1->entry->get_text());
				    network::netconnect::load_conf($netcnx, $netc, $intf);
				    $netcnx->{$_} = $netc->{$_} foreach qw(NET_DEVICE NET_INTERFACE);
				    network::netconnect::set_net_conf($netcnx, $netc);
				    update();
				    $button_apply->set_sensitive(1);
				});

$window1->show_all();
$_->hide foreach ($button1, $button3);
Gtk->main_iteration while Gtk->events_pending;
$::isEmbedded and kill 'USR2', $::CCPID;
my $tag = Gtk->timeout_add(4000, \&update2);
Gtk->main;
Gtk->exit(0);

dd:
network::netconnect::intro('', $netcnx, $in);
$in->exit(0);

sub build_clist {
    foreach my $i (0..$#all_cards) {
	my $ip;
	if (-e "/sbin/ifconfig") {
	    local $_ = `LC_ALL=C LANG=C LANGUAGE=C LC_MESSAGES=C /sbin/ifconfig "eth$i"`;
	    /inet addr\:$ip_regexp/; $ip = if_($1 && $2 && $3, "$1.$2.$3.$4");
	    $_ = `LC_ALL=C LANG=C LANGUAGE=C LC_MESSAGES=C /sbin/ifconfig`;
	    $state = /eth$i/ ? "up" : "down";
	} else { $ip = $intf->{"eth$_"}{IPADDR}; $state = "n/a" }
	$clist1->append("", "eth$i", $ip , $intf->{"eth$i"}{BOOTPROTO}, $all_cards[$i]->[1], $state);
	$clist1->set_pixmap ($i, 0, gtkcreate_png("eth_card_mini2.png"));

	$clist1->set_selectable($i, 0);
    }
}

sub apply {
    $old_profile = $netcnx->{PROFILE} ? $netcnx->{PROFILE} : "default";
    network::netconnect::save_conf($netcnx, $netc, $intf);

    $netcnx->{type} eq 'modem' and any::pppConfig($in, $netcnx->{$netcnx->{type}}, '');
    $netcnx->{type} eq 'isdn_internal' and network::isdn::isdn_write_config_backend($netcnx->{$netcnx->{type}}, 1, $netc, $netcnx); #$light
    $netcnx->{type} eq 'isdn_external' and any::pppConfig($in, $netcnx->{$netcnx->{type}}, '');
    my $a = $netcnx->{type};
    $a =~ s/adsl_//;
    $netcnx->{type} =~ 'adsl' and network::adsl::adsl_conf_backend($netcnx->{$netcnx->{type}}, $netc, $a, $netcnx);

    $netcnx->{dhcp_client} and $netc->{dhcp_client} = $netcnx->{dhcp_client};
    network::configureNetwork2($in, $prefix, $netc, $intf);
    $netcnx->{type} =~ /adsl/ or system("/sbin/chkconfig --del adsl 2> /dev/null");
    $netcnx->{type} !~ /adsl_p/ and system("$prefix/etc/rc.d/init.d/network restart");
    $button_apply->set_sensitive(0);
}

sub ethisup { `LC_ALL=C LANG=C LANGUAGE=C LC_MESSAGES=C /sbin/ifconfig` =~ /eth$_[0]/ }

my $to_update;
sub update {
    my $h = chomp_(`hostname`);
    $label_host->set ($h);
    $label4->set($netcnx->{type});
    $label5->set($netcnx->{type} eq 'lan' ? _("Gateway:") : _("Interface:"));
    $label6->set($netcnx->{type} eq 'lan' ? $netc->{GATEWAY} : $netcnx->{NET_INTERFACE});
    $clist1->freeze();
    $clist1->clear();
    build_clist();
    $clist1->thaw();
    $button_del->set_sensitive(network::netconnect::get_profiles() > 1);
    $isconnected !=-1 or return 1;
    $label8->set($isconnected ? _("Connected") : _("Not connected"));
    $button2->child->set($isconnected ? _("Disconnect...") : _("Connect..."));
    $button2->set_sensitive(1);
    1;
}

sub in_ifconfig {
    my ($intf) = @_;
    -e '/sbin/ifconfig' or return 1;
    $intf eq '' and return 1;
    `/sbin/ifconfig` =~ /$intf/;
}

sub update2 {
    undef $to_update;
    connected_bg(\$to_update);
    if (defined $to_update) {
        $isconnected = $to_update;
        if ($isconnected != -1) {
            if ($isconnected && !in_ifconfig($netcnx->{NET_INTERFACE})) {
                $warning_label1->set(_("Warning, another Internet connection has been detected, maybe using your network"));
                $isconnected = 0;
            } else { $warning_label1->set("") }
            $label8->set($isconnected ? _("Connected") : _("Not connected"));
            $button2->child->set($isconnected ? _("Disconnect...") : _("Connect..."));
            $button2->set_sensitive(1);
        }
    }
    update();
    1;
}

sub quit_global {
    $::isEmbedded ? kill('USR1', $::CCPID) : Gtk->exit(0);
}

sub configure_lan {
    my (undef, $prefix, $netcnx, $netc, $intf) = @_;
    my $window = new Gtk::Window -toplevel;

    my @card_tab;

    if (@all_cards < 1) {
	my $dialog = new Gtk::Dialog();
	$dialog->set_position(1);
	$dialog->vbox->set_border_width(10);
	$dialog->signal_connect (delete_event => sub { Gtk->main_quit() });
	$dialog->vbox->pack_start(new Gtk::Label(_("You don't have any configured interface.
Configure them first by clicking on 'Configure'")),1,1,0);
	my $bbox_dialog = new Gtk::HButtonBox;
	$dialog->action_area->add($bbox_dialog);
	$bbox_dialog->set_layout(-end);
	my $button_ok = new Gtk::Button _("OK");
	$button_ok->signal_connect (clicked => sub { Gtk->main_quit() });
	$bbox_dialog->add($button_ok);
	$dialog->show_all;
	$dialog->set_modal(1);
	Gtk->main();
	$dialog->destroy;
	return;
    }

    $window->set_policy (1, 1, 1);
    $window->signal_connect (delete_event => sub { Gtk->main_quit });
    $window->set_position(1);
    $window->set_title(_("LAN configuration"));
    $window->border_width(10);
    my $vbox1 = new Gtk::VBox(0,0);
    $window->add($vbox1);
    $vbox1->pack_start(new Gtk::Label(_("LAN Configuration")),0,1,0);
    my $notebook = new Gtk::Notebook;
    $vbox1->pack_start($notebook,0,1,0);
    my @eth_data;
    foreach (0..$#all_cards) {
	my @infos;
	my @conf_data;
	$card_tab[2*$_] = \@infos;
	$card_tab[2*$_+1] = \@conf_data;
	my $vbox_local = new Gtk::VBox(0,0);
	$vbox_local->set_border_width(10);
	$vbox_local->pack_start(new Gtk::Label(_("Adapter %s: %s", $_+1 , "eth$_")),1,1,0);
	#	Eth${_}Hostname = $netc->{HOSTNAME}
	#       Eth${_}HostAlias = " . do { $netc->{HOSTNAME} =~ /([^\.]*)\./; $1 } . "
	#	Eth${_}Driver = $all_cards[$_]->[1]
        @conf_data = ([_("IP address"), \$intf->{"eth$_"}{IPADDR}],
			 [_("Netmask"), \$intf->{"eth$_"}{NETMASK}],
			 [_("Boot Protocol"), \$intf->{"eth$_"}{BOOTPROTO}, ["static", "dhcp", "bootp"]],
			 [_("Started on boot"), \$intf->{"eth$_"}{ONBOOT} , ["yes", "no"]],
			 [_("DHCP client"), \$netcnx->{dhcp_client}]
			);
	my $i = 0;
	foreach my $j (@conf_data) {
	    $infos[2*$i] = new Gtk::HBox(0,0);
	    my $l = new Gtk::Label($j->[0]);
	    $l->set_justify('left');
	    $infos[2*$i]->pack_start($l,1,1,0);
	    $vbox_local->pack_start($infos[2*$i],0,0,0);
	    if (defined $j->[2]) {
		my $c = new Gtk::Combo();
		$c->set_popdown_strings(@{$j->[2]});
		$infos[2*$i+1] = $c->entry;
		$infos[2*$i+1]->set_editable(0);
		$infos[2*$i]->pack_start($c,0,0,0);
	    } else {
		$infos[2*$i+1] = new Gtk::Entry();
		$infos[2*$i]->pack_start($infos[2*$i+1],0,0,0);
	    }
	    $infos[2*$i+1]->set_text(${$j->[1]});
	    $i++;
	}
	my $c = $_;
	my $widget_temp;
	if (-e "$prefix/etc/sysconfig/network-scripts/ifcfg-eth$c") {
	    $widget_temp = gtksignal_connect(new Gtk::Button(ethisup($c) ? _("deactivate now") : _("activate now")),
					     clicked => sub {
						 system("/sbin/if".(ethisup($c)?"down" : "up")." eth$c");
						 gtkbuttonset($_[0], ethisup($c)? _("deactivate now") : _("activate now"));
					     });
	} else {
	    $widget_temp = _("This interface has not been configured yet.\nLaunch the configuration wizard in the main window");
	}
	$vbox_local->pack_start(gtkpack__(new Gtk::HBox(0,0),
					  $widget_temp
					 ),0,0,0);
	#	$clist1->append($_+1, "eth$_", $intf->{"eth$_"}{IPADDR}, $intf->{"eth$_"}{BOOTPROTO}, $all_cards[$_]->[1]);
	#	$clist1->set_selectable($_, 0);
#	require Data::Dumper;
#	print "------------\n" . Data::Dumper->Dump([$b],['b']) . "\n";
	my $hbox_local = new Gtk::HBox(0,0);
	my $pix = gtkpng("/usr/share/libDrakX/pixmaps/eth_card_mini.png");
	$hbox_local->pack_start($pix,0,0,0);
	$hbox_local->pack_start(new Gtk::Label("eth$_"),0,0,0);
	$hbox_local->show_all;
	$notebook->append_page($vbox_local, $hbox_local);
    }
    my $bbox1 = new Gtk::HButtonBox;
    $vbox1->pack_start($bbox1,0,0,10);
    $bbox1->set_layout(-end);
    my $button_ok = new Gtk::Button(_("OK"));
    $button_ok->signal_connect (clicked => sub {
				     foreach (0..$#all_cards) {
					 my $i = 0;
					 my @infos = @{$card_tab[2*$_]};
					 my @conf_data = @{$card_tab[2*$_+1]};
					 foreach my $j (@conf_data) {
					     ${$j->[1]} = $infos[2*$i+1]->get_text();
					     $i++;
					 }
				     }
				     update();
				     $button_apply->set_sensitive(1);
				     $window->destroy(); Gtk->main_quit;
				 });
    $bbox1->add($button_ok);
    my $button_cancel = new Gtk::Button(_("Cancel"));
    $button_cancel->signal_connect (clicked => sub { $window->destroy(); Gtk->main_quit });
    $bbox1->add($button_cancel);

    $window->set_modal(1);
    $window->show_all();
    foreach (0..$#all_cards) {
	my @infos = @{$card_tab[2*$_]};
	$intf->{"eth$_"}{BOOTPROTO} eq "dhcp" or $infos[8]->hide;
    }
    $window->set_position('center_always');
    Gtk->main;
}


sub configure_net {
    my (undef, $prefix, $netcnx, $netc, $intf) = @_;
    if (!$netcnx->{type}) {
	my $dialog = new Gtk::Dialog();
	$dialog->set_position(1);
	$dialog->vbox->set_border_width(10);
	$dialog->signal_connect (delete_event => sub { Gtk->main_quit() });
	$dialog->vbox->pack_start(new Gtk::Label(_("You don't have any internet connection.
Create one first by clicking on 'Configure'")),1,1,0);
	my $bbox_dialog = new Gtk::HButtonBox;
	$dialog->action_area->add($bbox_dialog);
	$bbox_dialog->set_layout(-end);
	my $button_ok = new Gtk::Button _("OK");
	$button_ok->signal_connect (clicked => sub {
					 Gtk->main_quit();
				     });
	$bbox_dialog->add($button_ok);
	$dialog->show_all;
	$dialog->set_modal(1);
	Gtk->main();
	$dialog->destroy;
	return;
    }
    my $cnx = {};
    my @infos;
    $cnx = $netcnx->{$netcnx->{type}};
    my $auto_detect = {};
    my $window = new Gtk::Window -toplevel;
    $window->set_policy (1, 1, 1);
    $window->signal_connect (delete_event => sub { Gtk->main_quit });
    $window->set_position(1);
    $window->set_title(_("Internet connection configuration"));
    $window->border_width(10);
    my $vbox1 = new Gtk::VBox(0,0);
    $window->add($vbox1);
    $vbox1->pack_start(new Gtk::Label(_("Internet Connection Configuration")),0,1,0);

    $vbox1->pack_start(new Gtk::HSeparator,0,0,5);
    my $table1 = new Gtk::Table (2, 4, 0);
    $table1->set_row_spacings(5);
    $table1->set_col_spacings(5);
    $vbox1->pack_start($table1,0,0,0);
    $table1->attach(new Gtk::Label(_("Profile: ")), 0, 1, 0, 1, 'fill', 'fill',0,0);
    $table1->attach(new Gtk::Label(_($netcnx->{PROFILE})), 1, 2, 0, 1, 'fill', 'fill',0,0);
    $table1->attach(new Gtk::Label(_("Connection type: ")), 0, 1, 1, 2, 'fill', 'fill',0,0);
    $table1->attach(new Gtk::Label(_($netcnx->{type})), 1, 2, 1, 2, 'fill', 'fill',0,0);
#    my $button1 = new Gtk::Button(_("Reconfigure using wizard..."));
#    $table1->attach($button1, 2, 4, 0, 2, 'fill', 'fill',0,0);
    $vbox1->pack_start(new Gtk::HSeparator,0,0,5);

    my $frame1 = new Gtk::Frame (_("Parameters"));
    $vbox1->pack_start($frame1,1,1,0);
    my $vbox2 = new Gtk::VBox(0,0);
    $frame1->add($vbox2);
    my $i = 0;
    my @conf_data = ([_("Card IRQ"), \$cnx->{irq} ],
		     [_("Card mem (DMA)"), \$cnx->{mem} ],
		     [_("Card IO"), \$cnx->{io} ],
		     [_("Card IO_0"), \$cnx->{io0} ],
		     [_("Card IO_1"), \$cnx->{io1} ],
		     [_("Your personal phone number"), \$cnx->{phone_in} ],
		     [_("Provider name (ex provider.net)"), \$netc->{DOMAINNAME2}],
		     [_("Provider phone number"), \$cnx->{phone_out} ],
		     [_("Provider dns 1 (optional)"), \$netc->{dnsServer2}],
		     [_("Provider dns 2 (optional)"), \$netc->{dnsServer3}],
		     [_("Account Login (user name)"), \$cnx->{login} ],
		     [_("Account Password"), \$cnx->{passwd} ],
		     [_("Dialing mode"), \$cnx->{dialing_mode}, [ "auto", "manual"] ],
		     [_("Gateway"), \$netc->{GATEWAY}],
		     [_("Connection name"), \$cnx->{connection} ],
		     [_("Phone number"), \$cnx->{phone} ],
		     [_("Login ID"), \$cnx->{login} ],
		     [_("Password"), \$cnx->{passwd} ],
		     [_("Authentication"), \$cnx->{auth}, [ _("PAP"), _("Terminal-based"), _("Script-based"), __("CHAP") ] ],
		     [_("Domain name"), \$cnx->{domain} ],
		     [_("First DNS Server (optional)"), \$cnx->{dns1} ],
		     [_("Second DNS Server (optional)"), \$cnx->{dns2} ],
		     [_("Ethernet Card"), \$netc->{NET_DEVICE}, [ 'eth0', 'eth1', 'eth2', 'eth3', 'eth4', 'eth5','eth6', 'eth7', 'eth8', 'eth9' ]],
		     [_("DHCP Client"), \$netcnx->{dhcp_client}, ["dhcpcd", "dhcpxd", "dhcp-client"] ],
		     [_("Connection speed"), \$cnx->{speed}, ["64 Kb/s", "128 Kb/s"]],
		     [_("Connection timeout (in sec)"), \$cnx->{huptimeout} ]
);
    foreach (@conf_data) {
	$infos[2*$i] = new Gtk::HBox(0,0);
	my $l = new Gtk::Label($_->[0]);
	$l->set_justify('left');
	$infos[2*$i]->pack_start($l,1,1,0);
	$vbox2->pack_start($infos[2*$i],0,0,0);
  	if (defined $_->[2]) {
	    my $c = new Gtk::Combo();
	    $c->set_popdown_strings(@{$_->[2]});
	    $infos[2*$i+1] = $c->entry;
	    $infos[2*$i]->pack_start($c,0,0,0);
	} else {
	    $infos[2*$i+1] = new Gtk::Entry();
	    $infos[2*$i]->pack_start($infos[2*$i+1],0,0,0);
	    #hide password if Entry Password
	    if ($_->[0] eq _("Account Password") || $_->[0] eq _("Password")) { $infos[2*$i+1]->set_visibility(0) };
	}
	$infos[2*$i+1]->set_text(${$_->[1]});
  	$i++;
    }
    my @mask;
@mask = (0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0) if $netcnx->{type} eq 'lan';
@mask = (0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1) if $netcnx->{type} eq'isdn_internal'&& defined $cnx->{vendor} && defined $cnx->{id};
@mask = (1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1) if $netcnx->{type} eq'isdn_internal'&&(!defined $cnx->{vendor}||!defined $cnx->{id});
@mask = (0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0) if ($netcnx->{type} eq 'modem'||$netcnx->{type} eq 'isdn_external');
@mask = (0,0,0,0,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0) if $netcnx->{type} =~ 'adsl';
@mask = (0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0) if $netcnx->{type} eq 'cable';
    $vbox1->pack_start(new Gtk::HSeparator,0,0,5);


    my $bbox1 = new Gtk::HButtonBox;
    $vbox1->pack_start($bbox1,0,0,0);
    $bbox1->set_layout(-end);
    my $button_ok = new Gtk::Button _("OK");
    $button_ok->signal_connect (clicked => sub {
				     $i = 0;
				     foreach (@mask) {
					    ${$conf_data[$i]->[1]} = $infos[2*$i+1]->get_text() if ($_);
					    $i++;
				     }
				     update();
				     $button_apply->set_sensitive(1);
				     $window->destroy(); Gtk->main_quit;
				 });
    $bbox1->add($button_ok);
    my $button_cancel = new Gtk::Button _("Cancel");
    $button_cancel->signal_connect (clicked => sub { $window->destroy(); Gtk->main_quit });
    $bbox1->add($button_cancel);

    $window->set_modal(1);
    $window->show_all();
    $i = 0;
    foreach (@mask) {
	if ($_) { $infos[2*$i]->show }
	else { $infos[2*$i]->hide }
	$i++;
    }
    $window->set_position('center_always');
    Gtk->main;
}
