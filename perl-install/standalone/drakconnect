#!/usr/bin/perl

# DrakConnect

# Copyright (C) 1999-2002 MandrakeSoft (damien@mandrakesoft.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

use strict; 	 
use diagnostics;

use lib qw(/usr/lib/libDrakX);

use standalone;     #- warning, standalone must be loaded very first, for 'explanations'

use interactive;
use common;
use network::netconnect;
use network::ethernet;
use network::tools;
use network::modem;
use network::network;
use network;
use c;
use modules;
use network::isdn;
use network::adsl;
use MDK::Common::Globals "network", qw($in $prefix $disconnect_file $connect_prog $connect_file);
use POSIX ":sys_wait_h";

my $xpm_path = "/usr/share/libDrakX/pixmaps";
local $_ = join '', @ARGV;

my ($netcnx, $netc, $intf)  = ({}, {}, {});
my @conx_type = ('modem', 'isdn_internal', 'isdn_external', 'adsl', 'cable', 'lan');

my $in = 'interactive'->vnew('su');
!$::isEmbedded and $in->isa('interactive::gtk');
$::Wizard_pix_up = "wiz_drakconnect.png";
$::Wizard_title = N("Network & Internet Configuration");

my $activate_profile = 0; #- deactivated by default (in order to keep code)

MDK::Common::Globals::init(
	      in => $in,
	      prefix => '',
	      connect_file => "/etc/sysconfig/network-scripts/net_cnx_up",
	      disconnect_file => "/etc/sysconfig/network-scripts/net_cnx_down",
	      connect_prog => "/etc/sysconfig/network-scripts/net_cnx_pg"
	     );

($::isEmbedded || /--gui/) && ref($in) =~ /gtk/ or goto dd;

require ugtk2;
ugtk2->import(qw(:create :dialogs :helpers :wrappers));
network::netconnect::read_net_conf('', $netcnx, $netc);
modules::load_category('net');
my @all_cards = network::ethernet::conf_network_card_backend($netc, $intf);
network::netconnect::load_conf($netcnx, $netc, $intf);
network::network::probe_netcnx_type('', $netc, $intf, $netcnx);

my $window1 = ugtk2->new('drakconnect');
$window1->{rwindow}->signal_connect(delete_event => sub { ugtk2->exit(0) });
unless ($::isEmbedded) {
    $window1->{rwindow}->set_position('center');
    $window1->{rwindow}->set_title(N("Network configuration (%d adapters)", @all_cards));
    $window1->{rwindow}->set_size_request(500, 400);
}
$window1->{rwindow}->set_border_width(10);

my $combo1 = Gtk2::OptionMenu->new;
$combo1->set_popdown_strings(network::netconnect::get_profiles());
my $old_profile = $netcnx->{PROFILE};
$combo1->entry->set_text($netcnx->{PROFILE} || "default");
my $button_del = Gtk2::Button->new(N("Del profile..."));
$button_del->signal_connect(clicked => sub {
				my $dialog = _create_dialog(N("Delete profile"));
				gtkpack($dialog->vbox,
                            Gtk2::Label->new(N("Profile to delete:")),
                            my $combo_dialog = Gtk2::OptionMenu->new,
                           );
				$combo_dialog->set_popdown_strings(grep { ! /default/ } network::netconnect::get_profiles());
				gtkpack($dialog->action_area,
                            gtksignal_connect(Gtk2::Button->new(N("Cancel")), clicked => sub { Gtk2->main_quit }),
                            gtksignal_connect(Gtk2::Button->new(N("Ok")), clicked => sub {
                                                  network::netconnect::del_profile($netcnx, $combo_dialog->entry->get_text);
                                                  $netcnx->{PROFILE} eq $combo_dialog->entry->get_text and $netcnx->{PROFILE} = "default";
                                                  sensitive_buttons(1);
                                                  Gtk2->main_quit;
                                              }),
                            );
				$dialog->show_all;
				$dialog->run;
				$dialog->destroy;
				$combo1->entry->set_text(-e "/etc/sysconfig/network-scripts/drakconnect_conf." . $combo1->entry->get_text ? $combo1->entry->get_text : "default");
				$combo1->set_popdown_strings(network::netconnect::get_profiles());
				apply();
			    });
$button_del->set_sensitive(network::netconnect::get_profiles() > 1);
my $button_new = Gtk2::Button->new(N("New profile..."));
$button_new->signal_connect(clicked => sub {
				my $dialog = _create_dialog("New profile...");
				my $entry_dialog = Gtk2::Entry->new;
				gtkpack($dialog->vbox,
                            Gtk2::Label->new(N("Name of the profile to create (the new profile is created as a copy of the current one) :")),
                            $entry_dialog,
                           );
				gtkpack($dialog->action_area,
                            gtksignal_connect(Gtk2::Button->new(N("Ok")), clicked => sub {
                                                  network::netconnect::add_profile($netcnx, $entry_dialog->get_text);
                                                  $netcnx->{PROFILE} = $entry_dialog->get_text;
                                                  Gtk2->main_quit;
                                              }),
                            gtksignal_connect(Gtk2::Button->new(N("Cancel")), clicked => sub { Gtk2->main_quit }),
                            );
				$dialog->show_all;
				$dialog->run;
				$dialog->destroy;
				$combo1->entry->set_text(-e "/etc/sysconfig/network-scripts/drakconnect_conf." . $netcnx->{PROFILE} ? $netcnx->{PROFILE} : "default");
				$combo1->set_popdown_strings(network::netconnect::get_profiles());
			    });

my $hostname = chomp_(`hostname`);
my $type_label = Gtk2::Label->new($netcnx->{type});
my $int_label = Gtk2::Label->new($netcnx->{type} eq 'lan' ? N("Gateway:") : N("Interface:"));
my $interface_name = Gtk2::Label->new($netcnx->{type} eq 'lan' ? $netc->{GATEWAY} : $netcnx->{NET_INTERFACE});
my $isconnected = -1;
my $warning_label1 = Gtk2::Label->new("");
my $int_connect = Gtk2::Button->new(N("Wait please"));
$int_connect->set_sensitive(0);
$int_connect->signal_connect(clicked => sub {
    if (!$isconnected) {
        if (cat_($connect_prog) =~ m|/usr/bin/kppp| && -e '/usr/bin/kppp') {
            run_program::rooted($prefix, "/usr/bin/kppp &");
          } else {
              connect_backend();
          } 
    } else {
        disconnect_backend();
    }
    update2();
});

my $tree_model = Gtk2::TreeStore->new("Gtk2::Gdk::Pixbuf", map { "Glib::String" } 2..6);
my $list = Gtk2::TreeView->new_with_model($tree_model);
$list->append_column(Gtk2::TreeViewColumn->new_with_attributes(undef, Gtk2::CellRendererPixbuf->new, 'pixbuf' => 0));
each_index {
    $list->append_column(my $col = Gtk2::TreeViewColumn->new_with_attributes($_, Gtk2::CellRendererText->new, 'text' => $::i + 1));
    $col->set_sort_column_id($::i);
} (N("Interface"), N("IP address"), N("Protocol"), N("Driver"), N("State"));
my $wizard_pid;
$list->signal_connect(button_press_event => sub { 
                          my (undef, $event) = @_;
                          my (undef, $iter) = $list->get_selection->get_selected;
                          return unless $iter;
                          configure_lan() if $event->type eq '2button-press' && !$wizard_pid;
                      });


update_list();

my ($bbox0, $label_host, $int_state, $button_expert);

my ($lan_button, $wiz_button, $int_button, $host_button, $button_apply);

$window1->{window}->add(
                        gtkpack_(Gtk2::VBox->new(0,10),
                                 if_($activate_profile,
                                     0, gtkpack_(Gtk2::HBox->new(0,0),
                                                 0, Gtk2::Label->new(N("Profile: ")),
                                                 0, $combo1,
                                                 0, $button_del,
                                                 0, $button_new,
                                                ),
                                    ),
                                 0, gtkpack(Gtk2::HBox->new,
                                            Gtk2::Label->new(N("Hostname: ")),
                                            $label_host = Gtk2::Label->new($hostname),
                                            $host_button = gtksignal_connect(Gtk2::Button->new(N("Configure hostname...")),
                                                                             clicked => sub {
                                                                                 sensitive_buttons(0);
                                                                                 local ($::isWizard, $::Wizard_finished) = (1, 1);
                                                                                 eval { # For wizcancel
                                                                                     use Data::Dumper; print Dumper([ $intf, $netc ]);
                                                                                     configureNetworkNet($in, $netc, $intf, @all_cards);
                                                                                     use Data::Dumper; print Dumper([ $intf, $netc ]);
                                                                                     network::sethostname($intf);
                                                                                     $button_apply->set_sensitive(1);
                                                                                     update();
                                                                                 };
                                                                                 if ($@ =~ /wizcancel/) { } 
                                                                                 $::WizardWindow->destroy;
                                                                                 undef $::WizardWindow;
                                                                                 sensitive_buttons(1);
                                                                             }
                                                                            ),
                                           ),
                                 0, gtkadd(Gtk2::Frame->new(N("Internet access")),
                                           gtkpack_(gtkset_border_width(Gtk2::VBox->new(0,0), 5),
                                                    1, gtkset_border_width(create_packtable({ col_spacings => 5, row_spacings => 5 },
                                                                                            [ Gtk2::Label->new(N("Type:")), $type_label ],
                                                                                            [ $int_label, $interface_name ],
                                                                                            [ Gtk2::Label->new(N("Status:")), 
                                                                                              $int_state = Gtk2::Label->new(N("Testing your connection...")) ]
                                                                                           ),
                                                                           5),
                                                    0, $warning_label1,
                                                    0, gtkpack(Gtk2::HButtonBox->new,
                                                               $int_button = gtksignal_connect(Gtk2::Button->new(N("Configure Internet Access...")),
                                                                                               clicked => sub { configure_net('', $netcnx, $netc, $intf) }),
                                                               $int_connect,
                                                              ),
                                                   )
                                          ),
                                 1, gtkadd(Gtk2::Frame->new(N("LAN configuration")),
                                           gtkpack_(gtkset_border_width(Gtk2::VBox->new(0,0), 5),
                                                    0, $list,
                                                    0, Gtk2::HBox->new(0,0),
                                                    0, gtkpack_(Gtk2::HBox->new(0, 0),
                                                                0, $lan_button = gtksignal_connect(Gtk2::Button->new(N("Configure Local Area Network...")),
                                                                                                   clicked => \&configure_lan),
                                                               ),
                                                   )
                                          ),
                                 0, gtkadd(Gtk2::HButtonBox->new,
                                           $wiz_button = gtksignal_connect(Gtk2::Button->new(N("Launch the wizard")),
                                                                           clicked => sub {
                                                                               $wizard_pid = fork();
                                                                               if (defined $wizard_pid) {
                                                                                   # immediate exit, else forked gtk+ object destructors will badly catch up parent drakconnect
                                                                                   !$wizard_pid and do { exec("drakconnect") or POSIX::_exit(1) };
                                                                                   sensitive_buttons(0);
                                                                               } else {
                                                                                   err_dialog(N("Unable to fork: %s", "$!"));
                                                                               }
                                                                           }),
                                          ),
                                 0, Gtk2::HSeparator->new,
                                 0, $bbox0 = gtkpack(Gtk2::HButtonBox->new,
                                                     gtksignal_connect(Gtk2::Button->new(N("Help")), clicked => sub { 
                                                                           exec("drakhelp Drakxtools-Guide.html/internet-connection.html") unless fork() }),
                                                     $button_apply = gtksignal_connect(gtkset_sensitive(Gtk2::Button->new(N("Apply")), 0),
                                                                                          clicked => \&apply),
                                                     gtksignal_connect(Gtk2::Button->new(N("Cancel")), clicked => \&quit_global),
                                                     gtksignal_connect(Gtk2::Button->new(N("Ok")), clicked => sub {
                                                                           my $dialog = _create_dialog(N("Please wait"));
                                                                           gtkpack($dialog->vbox,
                                                                                   Gtk2::Label->new(N("Please Wait... Applying the configuration")));
                                                                           $dialog->show_all;
                                                                           gtkflush();
                                                                           apply();
                                                                           $dialog->destroy;
                                                                           update();
                                                                           quit_global();
                                                                       }),
                                                    ),
                                 ),
                        );


$combo1->signal_connect(realize => sub {
                            $combo1->entry->signal_connect(changed => sub {
                                                               #connected() and disconnect_backend();
                                                               network::netconnect::set_profile($netcnx, $combo1->entry->get_text);
                                                               network::netconnect::load_conf($netcnx, $netc, $intf);
                                                               $netcnx->{$_} = $netc->{$_} foreach qw(NET_DEVICE NET_INTERFACE);
                                                               update();
                                                               $button_apply->set_sensitive(1);
                                                           });
});

sub sensitive_buttons {
    my ($state) = @_;
    $_->set_sensitive($state) foreach $host_button, $lan_button, $wiz_button, $int_button;
}


$SIG{CHLD} = sub {
    my $child = waitpid(-1, POSIX::WNOHANG);
    return if !($wizard_pid && $child eq $wizard_pid);
    undef $wizard_pid;
    sensitive_buttons(1);
    #- reload everything...
    $netcnx = {}; $netc = {}; $intf = {};
    network::netconnect::read_net_conf('', $netcnx, $netc);
    modules::load_category('net');
    @all_cards = network::ethernet::conf_network_card_backend($netc, $intf);
    network::netconnect::load_conf($netcnx, $netc, $intf);
    network::network::probe_netcnx_type('', $netc, $intf, $netcnx);
    $combo1->entry->set_text(-e "/etc/sysconfig/network-scripts/drakconnect_conf." . ($combo1->entry->get_text || "default"));
    update();
};


$window1->{rwindow}->show_all;
gtkflush();
my $tag = Glib::Timeout->add(4000, \&update2);
$window1->main;
ugtk2->exit(0);

dd:
$::isWizard = 1;
network::netconnect::main('', $netcnx, $in);
$in->exit(0);

sub get_intf_ip {
    my ($interface) = @_;
    my ($ip, $state, $mask);
    if (-x "/sbin/ifconfig") {
	local $_ = `LC_ALL=C LANGUAGE=C /sbin/ifconfig $interface`;
	$ip = /inet addr:(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/mso ? $1 : N("No Ip");
	$mask = /Mask:(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/mso ? $1 : N("No Mask");
	$state = /inet/ ? "up" : "down";
    } else {
	$ip = $intf->{$interface}{IPADDR};
	$state = "n/a";
    }
    ($ip, $state, $mask);
}

my %intf;

sub update_list() {
    my %new_intf = map { @$_ } @all_cards;
    my @new_intf = sort keys %new_intf;
    foreach my $interface (@new_intf) {
        my ($ip, $state) = get_intf_ip($interface);
        $intf{$interface}{iter} ||= $tree_model->append(undef);
        $tree_model->set($intf{$interface}{iter}, map_index { $::i => $_ } (gtkcreate_pixbuf("eth_card_mini2.png"), $interface, $ip , $intf->{$interface}{BOOTPROTO}, $new_intf{$interface}, $state));
    }
    foreach my $i (difference2([ keys %intf ], \@new_intf)) {
        delete $intf{$i};
    }
}

sub apply() {
    $old_profile = $netcnx->{PROFILE} || "default";
    network::netconnect::save_conf($netcnx);

    $netcnx->{type} eq 'modem' and network::modem::ppp_configure($in, $netcnx->{$netcnx->{type}});
    $netcnx->{type} eq 'isdn_internal' and network::isdn::isdn_write_config_backend($netcnx->{$netcnx->{type}}, $netc, $netcnx); #$light
    $netcnx->{type} eq 'isdn_external' and network::modem::ppp_configure($in, $netcnx->{$netcnx->{type}});
    my $a = $netcnx->{type};
    $a =~ s/adsl_//;
    $netcnx->{type} =~ /adsl/ and network::adsl::adsl_conf_backend($netcnx->{$netcnx->{type}}, $netc, $a, $netcnx);

    $netcnx->{dhcp_client} and $netc->{dhcp_client} = $netcnx->{dhcp_client};
    network::configureNetwork2($in, $prefix, $netc, $intf);
    $netcnx->{type} =~ /adsl/ or system("/sbin/chkconfig --del adsl 2> /dev/null");
    $netcnx->{type} !~ /adsl_p/ and system("$prefix/etc/rc.d/init.d/network restart");
    $button_apply->set_sensitive(0);
}

sub ethisup { `LC_ALL=C LANGUAGE=C /sbin/ifconfig $_[0]` =~ /inet/ }

sub update_intbutt() {
    $int_state->set($isconnected ? N("Connected") : N("Not connected"));
    $int_connect->child->set($isconnected ? N("Disconnect...") : N("Connect..."));
    $int_connect->set_sensitive(1);
}

my $to_update;
sub update() {
    my $h = chomp_(`hostname`);
    $label_host->set_label($h);
    $type_label->set($netcnx->{type});
    $int_label->set($netcnx->{type} eq 'lan' ? N("Gateway:") : N("Interface:"));
    $interface_name->set($netcnx->{type} eq 'lan' ? $netc->{GATEWAY} : $netcnx->{NET_INTERFACE});
    update_list();
    $button_del->set_sensitive(network::netconnect::get_profiles() > 1);
    return 1 if $isconnected == -1;
    update_intbutt();
    1;
}

sub in_ifconfig {
    my ($intf) = @_;
    -e '/sbin/ifconfig' or return 1;
    $intf eq '' and return 1;
    `/sbin/ifconfig` =~ /$intf/;
}

sub update2() {
    undef $to_update;
    connected_bg(\$to_update);
    if (defined $to_update) {
        $isconnected = $to_update;
        if ($isconnected != -1) {
            if ($isconnected && !in_ifconfig($netcnx->{NET_INTERFACE})) {
                $warning_label1->set(N("Warning, another Internet connection has been detected, maybe using your network"));
                $isconnected = 0;
            } else { $warning_label1->set("") }
            update_intbutt();
        }
    }
    update();
    1;
}

sub quit_global() {
    ugtk2->exit(0);
}

sub get_intf_status {
    my ($c) = @_;
    ethisup($c) ? N("Deactivate now") : N("Activate now")
}

sub configure_lan() {
    sensitive_buttons(0);
    my $window = _create_dialog(N("LAN configuration"), { small => 1 });
    my @card_tab;

    if (@all_cards < 1) {
	$window->vbox->add(Gtk2::Label->new(N("You don't have any configured interface.
Configure them first by clicking on 'Configure'")));
	gtkpack(gtkset_layout($window->action_area, 'end'),
             gtksignal_connect(Gtk2::Button->new(N("Ok")),
                               clicked => sub { Gtk2->main_quit })
            );
	$window->show_all;
	$window->run;
	$window->destroy;
	return;
    }

    $window->set_border_width(10);
    gtkpack($window->vbox,
            Gtk2::Label->new(N("LAN Configuration")),
            my $notebook = Gtk2::Notebook->new,
            my $bbox8 = Gtk2::HButtonBox->new,
           );

    foreach (0..$#all_cards) {
	my @infos;
	my @conf_data;
	$card_tab[2*$_] = \@infos;
	$card_tab[2*$_+1] = \@conf_data;

	my $vbox_local = Gtk2::VBox->new(0,0);
	$vbox_local->set_border_width(10);
	$vbox_local->pack_start(Gtk2::Label->new(N("Adapter %s: %s", $_+1 , $all_cards[$_][0])),1,1,0);
	#	Eth${_}Hostname = $netc->{HOSTNAME}
	#       Eth${_}HostAlias = " . do { $netc->{HOSTNAME} =~ /([^\.]*)\./; $1 } . "
	#	Eth${_}Driver = $all_cards[$_]->[1]
	my $interface = $all_cards[$_][0];
	my ($ip, undef, $mask) = get_intf_ip($interface);
	$mask ||= $intf->{$interface}{NETMASK};
        @conf_data = ([ N("IP address"), \$ip ],
		      [ N("Netmask"), \$mask ],
		      [ N("Boot Protocol"), \$intf->{$interface}{BOOTPROTO}, ["static", "dhcp", "bootp"] ],
		      [ N("Started on boot"), \$intf->{$interface}{ONBOOT} , ["yes", "no"] ],
		      [ N("DHCP client"), \$netcnx->{dhcp_client} ]
		     );
	my $i = 0;
	my $size_group = Gtk2::SizeGroup->new('horizontal');

	foreach my $j (@conf_data) {
	    my $l = Gtk2::Label->new($j->[0]);
	    $l->set_justify('left');
	    $infos[2*$i] = gtkpack_(Gtk2::HBox->new,
				    1, $l);
	    $vbox_local->pack_start($infos[2*$i], 1, 1, 0);
	    my $c;
	    if (defined $j->[2]) {
		$c = Gtk2::OptionMenu->new;
		$c->set_popdown_strings(@{$j->[2]});
		$infos[2*$i+1] = $c->entry;
		$infos[2*$i]->pack_start($c,0,0,0);
	    } else {
		$infos[2*$i+1] = ($c = Gtk2::Entry->new);
		$infos[2*$i]->pack_start($infos[2*$i+1],0,0,0);
	    }
	    $size_group->add_widget($c);
	    $infos[2*$i+1]->set_text(${$j->[1]});
	    $i++;
	}

	my $widget_temp;
	if (-e "$::prefix/etc/sysconfig/network-scripts/ifcfg-$interface") {
         $widget_temp = gtksignal_connect(Gtk2::Button->new(get_intf_status($interface)),
                                          clicked => sub {
                                              system("/sbin/if" . (ethisup($interface) ? "down" : "up") . " $interface");
                                              $_[0]->set_label(get_intf_status($interface));
                                              update();
                                          });
	} else {
	    $widget_temp = N("This interface has not been configured yet.\nLaunch the configuration wizard in the main window");
	}
	$vbox_local->pack_start(gtkpack__(Gtk2::HBox->new(0,0),
					  $widget_temp
					 ),0,0,0);
	#	$list->append($_+1, $interface, $intf->{$interface}{IPADDR}, $intf->{$interface}{BOOTPROTO}, $all_cards[$_]->[1]);
	#	$list->set_selectable($_, 0);
	$notebook->append_page($vbox_local, Gtk2::Label->new($interface));
    }
    $bbox8->set_layout('end');

    my $exit_dialogsub = sub {
        sensitive_buttons(1);
        $window->destroy;
        Gtk2->main_quit;
    };

    gtkpack($window->action_area,
            gtksignal_connect(Gtk2::Button->new(N("Cancel")),
                              clicked => $exit_dialogsub),
            gtksignal_connect(Gtk2::Button->new(N("Ok")), clicked => sub {
                                  foreach (0..$#all_cards) {
                                      my @infos = @{$card_tab[2*$_]};
                                      each_index { ${$_->[1]} = $infos[2*$::i+1]->get_text } @{$card_tab[2*$_+1]};
                                      my $interface = $all_cards[$_][0];
                                      if ($intf->{$interface}{BOOTPROTO} ne "static") {
                                          delete @{$intf->{$interface}}{qw(IPADDR NETWORK NETMASK BROADCAST)};
                                      } else {
                                          if ($infos[1]->get_text ne "No ip") {
                                              $intf->{$interface}{IPADDR}  = $infos[1]->get_text;
                                              $intf->{$interface}{NETMASK} = $infos[3]->get_text;
                                          }
                                      }
                                  }
                                  update();
                                  $button_apply->set_sensitive(1);
                                  $exit_dialogsub->();
                              }),
          );
    
    $window->show_all;
    foreach (0..$#all_cards) {
	my @infos = @{$card_tab[2*$_]};
	$intf->{$all_cards[$_][0]}{BOOTPROTO} eq "dhcp" or $infos[8]->hide;
    }
    $window->run;
}


sub configure_net {
    my ($_prefix, $netcnx, $netc, $_intf) = @_;
    sensitive_buttons(0);
    my $dialog;
    my $exit_dialogsub = sub {
        sensitive_buttons(1);
        $dialog->destroy;
        Gtk2->main_quit;
    };
    if (!$netcnx->{type}) {
	$dialog = _create_dialog(N("LAN configuration"));
	$dialog->vbox->add(Gtk2::Label->new(N("You don't have an Internet connection.
Create one first by clicking on 'Configure'")));
	gtkpack($dialog->action_area,
             gtksignal_connect(Gtk2::Button->new(N("Ok")), clicked => $exit_dialogsub),
            );
	$dialog->show_all;
	$dialog->run;
	$dialog->destroy;
	return;
    }
    my $cnx = {};
    $cnx = $netcnx->{$netcnx->{type}};
    $dialog = _create_dialog(N("Internet connection configuration"), { small => 1 });
    $dialog->signal_connect(delete_event => $exit_dialogsub);
    $dialog->set_border_width(10);

    my $vbox2 = Gtk2::VBox->new(0,0);
    my $i = 0;
    my @mask;
@mask = (0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0) if $netcnx->{type} eq 'lan';
@mask = (0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1) if $netcnx->{type} eq 'isdn_internal' && defined $cnx->{vendor} && defined $cnx->{id};
@mask = (1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1) if $netcnx->{type} eq 'isdn_internal' && (!defined $cnx->{vendor} || !defined $cnx->{id});
@mask = (0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0) if $netcnx->{type} eq 'modem' || $netcnx->{type} eq 'isdn_external';
@mask = (0,0,0,0,0,0,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0) if $netcnx->{type} =~ /adsl/;
@mask = (0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0) if $netcnx->{type} eq 'cable';

    #- duplicated code (waiting for 9.1 to be out to merge everything correctly, avoid bug elsewhere).
    if ($netcnx->{type} =~ /adsl/) {
	require network::adsl;
	network::adsl::adsl_probe_info($cnx, $netc, $intf);
    }
    my @conf_data = ([ N("Card IRQ"), \$cnx->{irq} ],
		     [ N("Card mem (DMA)"), \$cnx->{mem} ],
		     [ N("Card IO"), \$cnx->{io} ],
		     [ N("Card IO_0"), \$cnx->{io0} ],
		     [ N("Card IO_1"), \$cnx->{io1} ],
		     [ N("Your personal phone number"), \$cnx->{phone_in} ],
		     [ N("Provider name (ex provider.net)"), \$netc->{DOMAINNAME2} ],
		     [ N("Provider phone number"), \$cnx->{phone_out} ],
		     [ N("Provider dns 1 (optional)"), \$netc->{dnsServer2} ],
		     [ N("Provider dns 2 (optional)"), \$netc->{dnsServer3} ],
		     [ N("Account Login (user name)"), \$cnx->{login} ],
		     [ N("Account Password"), \$cnx->{passwd} ],
		     [ N("Dialing mode"), \$cnx->{dialing_mode}, [ "auto", "manual" ] ],
		     [ N("Gateway"), \$netc->{GATEWAY} ],
		     [ N("Connection name"), \$cnx->{connection} ],
		     [ N("Phone number"), \$cnx->{phone} ],
		     [ N("Login ID"), \$cnx->{login} ],
		     [ N("Password"), \$cnx->{passwd} ],
		     [ N("Authentication"), \$cnx->{auth}, [ N("PAP"), N("Terminal-based"), N("Script-based"), N_("CHAP") ] ],
		     [ N("Domain name"), \$cnx->{domain} ],
		     [ N("First DNS Server (optional)"), \$cnx->{dns1} ],
		     [ N("Second DNS Server (optional)"), \$cnx->{dns2} ],
		     [ N("Ethernet Card"), \$netc->{NET_DEVICE}, [ 'eth0', 'eth1', 'eth2', 'eth3', 'eth4', 'eth5', 'eth6', 'eth7', 'eth8', 'eth9' ] ],
		     [ N("DHCP Client"), \$netcnx->{dhcp_client}, ["dhcp-client", "dhcpcd", "dhcpxd"] ],
		     [ N("Connection speed"), \$cnx->{speed}, ["64 Kb/s", "128 Kb/s"] ],
		     [ N("Connection timeout (in sec)"), \$cnx->{huptimeout} ]
);
    my @infos;
    foreach (@conf_data) {
        if (!$mask[$i]) {
            $i++;
            next;
        }
        $infos[2*$i] = Gtk2::HBox->new(0,0);
        my $l = Gtk2::Label->new($_->[0]);
        $l->set_justify('left');
        $infos[2*$i]->pack_start($l, 0, 0, 0);
        $vbox2->pack_start($infos[2*$i], 0, 0, 0);
        if (defined $_->[2]) {
            my $c = Gtk2::Combo->new;
            $c->set_popdown_strings(@{$_->[2]});
            $infos[2*$i+1] = $c->entry;
            $infos[2*$i]->pack_start($c,0 , 0, 0);
        } else {
            $infos[2*$i+1] = Gtk2::Entry->new;
            $infos[2*$i]->pack_start($infos[2*$i+1], 0, 0, 0);
            #hide password if Entry Password
            if ($_->[0] eq N("Account Password") || $_->[0] eq N("Password")) { $infos[2*$i+1]->set_visibility(0) };
        }
        $infos[2*$i+1]->set_text(${$_->[1]});
        $i++;
    }

    gtkpack(Gtk2::VBox->new(0, 0),
            Gtk2::Label->new(N("Internet Connection Configuration")),
            Gtk2::HSeparator->new,
            create_packtable({ col_spacings => 5, row_spacings => 5, homogenous => 1 },
                             [ Gtk2::Label->new(N("Profile: ")), 
                               Gtk2::Label->new(translate($netcnx->{PROFILE})) ],
                             [ Gtk2::Label->new(N("Connection type: ")), 
                               Gtk2::Label->new(translate($netcnx->{type})) ],
                            ),
            Gtk2::HSeparator->new,
            gtkadd(Gtk2::Frame->new(N("Parameters")), $vbox2),
           );
    gtkpack($dialog->action_area,
            gtksignal_connect(Gtk2::Button->new(N("Cancel")), clicked => $exit_dialogsub),
            gtksignal_connect(Gtk2::Button->new(N("Ok")), clicked => sub {
                                  each_index {
                                      ${$conf_data[$::i][1]} = $infos[2*$::i+1]->get_text if $_;
                                  } @mask;
                                  update();
                                  $button_apply->set_sensitive(1);
                                  $exit_dialogsub->();
                                  $dialog->destroy; Gtk2->main_quit;
                              }),
           );

    $dialog->show_all;
    $dialog->run;
}
