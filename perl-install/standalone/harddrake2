#!/usr/bin/perl
# -*- coding: utf-8 -*-

use utf8;
use strict;
use diagnostics;
use lib qw(/usr/lib/libDrakX);
use standalone;
use common;

# i18n: IMPORTANT: to get correct namespace (drakconf instead of only libDrakX)
BEGIN { unshift @::textdomains, 'drakconf' }

use mygtk2 qw(gtknew); #- do not import gtkadd which conflicts with ugtk2 version
use ugtk2 qw(:create :helpers :wrappers);
use interactive;
use harddrake::data;  #- needs to stay after use-ugtk2 as long as this module defines globals containing some N()
use fsedit;
use pkgs;
use POSIX qw(:sys_wait_h);


# { field => [ short_translation, full_description] }
my %fields = 
    (
     generic =>
     {
      "alternative_drivers" => [ N("Alternative drivers"),
                                 N("the list of alternative drivers for this sound card") ],
      "bus" => 
      [ N("Bus"), 
        N("this is the physical bus on which the device is plugged (eg: PCI, USB, ...)") ],
      "bus_id" => 
      [ N("Bus identification"), 
        N("- PCI and USB devices: this lists the vendor, device, subvendor and subdevice PCI/USB ids") ],
      "bus_location" => 
      [ N("Location on the bus"), 
        N("- pci devices: this gives the PCI slot, device and function of this card
- eide devices: the device is either a slave or a master device
- scsi devices: the scsi bus and the scsi device ids") ],
      "capacity" => [ N("Drive capacity"), N("special capacities of the driver (burning ability and or DVD support)") ],
      "description" => [ N("Description"), N("this field describes the device") ],
      "device" => [ N("Old device file"),
                    N("old static device name used in dev package") ],
      "driver" => [
                   #-PO: here "module" is the "jargon term" for a kernel driver
                   N("Module"), N("the module of the GNU/Linux kernel that handles the device") ],
      "extended_partitions" => [ N("Extended partitions"), N("the number of extended partitions") ],
      "geometry" => [ N("Geometry"), N("Cylinder/head/sectors geometry of the disk") ],
      "host" => [ N("Disk controller"), N("the disk controller on the host side") ],
      "info" => [ N("Identifier"), N("usually the device serial number") ],
      "media_type" => [ N("Media class"), N("class of hardware device") ],
      "Model" => [ N("Model"), N("hard disk model") ],
      "port" => [ N("Port"), N("network printer port") ],
      "primary_partitions" => [ N("Primary partitions"), N("the number of the primary partitions") ],
      "Vendor" => [ N("Vendor"), N("the vendor name of the device") ],
      "pci_domain" => [ N("PCI domain"), N("the PCI domain of the device") ],
      "pci_bus" => [ N("Bus PCI #"), N("the PCI bus on which the device is plugged") ],
      "pci_device" => [ N("PCI device #"), N("PCI device number") ],
      "pci_function" => [ N("PCI function #"), N("PCI function number") ],
      "vendor" => [ N("Vendor ID"), N("this is the standard numerical identifier of the vendor") ],
      "id" => [ N("Device ID"), N("this is the numerical identifier of the device") ],
      "subvendor" => [ N("Sub vendor ID"), N("this is the minor numerical identifier of the vendor") ],
      "subid" => [ N("Sub device ID"), N("this is the minor numerical identifier of the device") ],
      "usb_pci_device" =>, [ N("Device USB ID"), N("..") ],
     },
     CPU =>
     {
      "bogomips" => [ N("Bogomips"), N("the GNU/Linux kernel needs to run a calculation loop at boot time to initialize a timer counter.  Its result is stored as bogomips as a way to \"benchmark\" the cpu.") ],
      "cache size" => [ N("Cache size"), N("size of the (second level) cpu cache") ],
      "coma_bug" => [
                     #-PO: here "comas" is the medical coma, not the lexical coma!!
                     N("Coma bug"), N("whether this cpu has the Cyrix 6x86 Coma bug") ],
      "cpu family" => [ N("Cpuid family"), N("family of the cpu (eg: 6 for i686 class)") ],
      "cpuid level" => [ N("Cpuid level"), N("information level that can be obtained through the cpuid instruction") ],
      "cpu MHz" => [ N("Frequency (MHz)"), N("the CPU frequency in MHz (Megahertz which in first approximation may be coarsely assimilated to number of instructions the cpu is able to execute per second)") ],
      "flags" => [ N("Flags"), N("CPU flags reported by the kernel") ],
      "fdiv_bug" => [ N("Fdiv bug"), 
                      N("Early Intel Pentium chips manufactured have a bug in their floating point processor which did not achieve the required precision when performing a Floating point DIVision (FDIV)") ],
      "fpu" => [ N("Is FPU present"), N("yes means the processor has an arithmetic coprocessor") ],
      "fpu_exception" => [ N("Whether the FPU has an irq vector"), N("yes means the arithmetic coprocessor has an exception vector attached") ],
      "f00f_bug" => [ N("F00f bug"), N("early pentiums were buggy and freezed when decoding the F00F bytecode") ],
      "hlt_bug" => [ N("Halt bug"), 
                     N("Some of the early i486DX-100 chips cannot reliably return to operating mode after the \"halt\" instruction is used") ],
      "level" => [ N("Level"), N("sub generation of the cpu") ],
      "model" => [ N("Model"), N("generation of the cpu (eg: 8 for Pentium III, ...)") ],
      "model name" => [ N("Model name"), N("official vendor name of the cpu") ],
      "name" => [ N("Name"), N("the name of the CPU") ],
      "processor" => [ N("Processor ID"), N("the number of the processor") ],
      "stepping" => [ N("Model stepping"), N("stepping of the cpu (sub model (generation) number)") ],
      "vendor_id" => [ N("Vendor"), N("the vendor name of the processor") ],
      "wp" => [ N("Write protection"), N("the WP flag in the CR0 register of the cpu enforce write protection at the memory page level, thus enabling the processor to prevent unchecked kernel accesses to user memory (aka this is a bug guard)") ],
     },
     FLOPPY =>
     {
      info => [ N("Floppy format"), N("format of floppies supported by the drive") ],
     },
     HARDDISK =>
     {
      channel => [ N("Channel"), N("EIDE/SCSI channel") ],
      info => [ N("Disk identifier"), N("usually the disk serial number") ],
      lun => [ N("Logical unit number"), N("the SCSI target number (LUN). SCSI devices connected to a host are uniquely identified by a
channel number, a target id and a logical unit number") ],
     },
     MEMORY =>
     {
      'Installed Size' => [ 
          #-PO: here, "size" is the size of the ram chip (eg: 128Mo, 256Mo, ...)
          N("Installed size"), N("Installed size of the memory bank") ],
      'Enabled Size' => [ N("Enabled Size"), N("Enabled size of the memory bank") ],
      'name' => [ N("Type"), N("type of the memory device") ],
      'Current Speed' => [ N("Speed"), N("Speed of the memory bank") ],
      'Bank Connections' => [ N("Bank connections"), '' ],
      'Socket Designation' => [ N("Name"), N("Socket designation of the memory bank") ],
     },
     MOUSE =>
     {
      "device" => [ N("Device file"), N("the device file used to communicate with the kernel driver for the mouse") ],
      EmulateWheel => [ N("Emulated wheel"), N("whether the wheel is emulated or not") ],
      MOUSETYPE => [ N("Type"), N("the type of the mouse") ],
      name => [ N("Name"), N("the name of the mouse") ],
      nbuttons => [ N("Number of buttons"), N("the number of buttons the mouse has") ],
      type => [ N("Bus"), N("the type of bus on which the mouse is connected") ],
      Protocol => [ N("Mouse protocol used by X11"), N("the protocol that the graphical desktop use with the mouse") ],
     }
    );

my %groups = (
              generic =>
              {
               N("Identification") => [ qw(Vendor model description info media_type) ],
               N("Connection") => [ qw(bus pci_domain pci_bus pci_device pci_function vendor id subvendor subid) ],
              },
              AUDIO =>
              {
               N("Driver") => [ qw(driver alternative_drivers) ],
              },
              CPU =>
              {
               N("Identification") => [ qw(processor vendor_id), "model name", "cpu family", qw(model level stepping) ],
               N("Performances") => [ "cpu MHz", "cache size", "bogomips" ],
               N("Bugs") => [ qw(fdiv_bug coma_bug f00f_bug hlt_bug) ],
               N("FPU")  => [ qw(fpu fpu_exception) ],
              },
              HARDDISK =>
              {
               N("Identification") => [ qw(Vendor Model description info media_type) ],
               N("Connection") => [ qw(bus channel lun) ],
               N("Bus identification") => [ qw(vendor id subvendor subid) ],
               N("Device") => [ qw(device) ],
               N("Partitions") => [ qw(primary_partitions extended_partitions) ],
              },
              MOUSE =>
              {
               N("Identification") => [ qw(name type MOUSETYPE Protocol) ],
               N("Features") => [ qw(EmulateWheel nbuttons) ],
              },
             );

foreach my $class (qw(BURNER CDROM DVDROM)) {
    $groups{$class} = $groups{HARDDISK};
    $fields{$class} = $fields{HARDDISK};
}


my ($in, $pid, $w);

my (%options, %check_boxes);
my $conffile = "/etc/sysconfig/harddrake2/ui.conf";

my ($current_device, $current_class, $current_configurator);

my %sysh = distrib();
my $distro_name = $sysh{system};

my %menus = (
             'options' => 
             #-PO: please keep all "/" characters !!!
             N("/_Options"),
             'help' => N("/_Help")
             );

my %menu_options = (
                    'PRINTERS_DETECTION' => [ $menus{options}, N("/Autodetect _printers") ],
                    'MODEMS_DETECTION' => [ $menus{options}, N("/Autodetect _modems") ],
                    'JAZZ_DETECTION' => [ $menus{options}, N("/Autodetect _jaz drives") ],
                    'PARALLEL_ZIP_DETECTION' => [ $menus{options}, N("/Autodetect parallel _zip drives") ],
                    );

$ugtk2::wm_icon = "harddrake";
$w = ugtk2->new(N("Hardware Configuration"));
# fake diagnostics pragma:
local $::main_window = $w->{real_window};

my @menu_items = 
    (
     [ N("/_File"), undef, undef, undef, '<Branch>' ],
     [ N("/_File") . N("/_Quit"), N("<control>Q"), \&quit_global, undef, '<Item>' ],
     [ join('', @{$menu_options{PRINTERS_DETECTION}}), undef, 
       sub { $options{PRINTERS_DETECTION} = $check_boxes{PRINTERS_DETECTION}->get_active }, undef, '<CheckItem>' ],
     [ join('', @{$menu_options{MODEMS_DETECTION}}), undef,
       sub { $options{MODEMS_DETECTION} = $check_boxes{MODEMS_DETECTION}->get_active }, undef, '<CheckItem>' ],
     [ join('', @{$menu_options{JAZZ_DETECTION}}), undef,
       sub { $options{JAZZ_DETECTION} = $check_boxes{JAZZ_DETECTION}->get_active }, undef, '<CheckItem>' ],
     [ join('', @{$menu_options{PARALLEL_ZIP_DETECTION}}), undef,
       sub { $options{PARALLEL_ZIP_DETECTION} = $check_boxes{PARALLEL_ZIP_DETECTION}->get_active }, undef, '<CheckItem>' ],
     [ $menus{help}, undef, undef, undef, '<Branch>' ],
     if_(-x "/usr/sbin/drakhelp_inst",
	 [ $menus{help} . N("/_Help"), undef, sub { run_program::raw({ detach => 1 }, 'drakhelp', '--id', 'harddrake') }, undef, '<Item>' ],
	),
     [ $menus{help} . N("/_Fields description"), undef, sub {
           if ($current_device) {
               create_dialog(N("Harddrake help"), 
                             '<big><b>' . N("Description of the fields:\n\n") . '</b></big>'
                             . join("\n\n", map {
                                 my $info = lookup_field($_);
                                 if_($info->[0], formatAlaTeX(qq(<span foreground="royalblue3">$info->[0]:</span> $info->[1])));
                             } sort keys %$current_device),
                             { use_markup => 1, transient => $w->{real_window}, height => 400, scroll => 1 });

           } else {
               create_dialog(N("Select a device!"), N("Once you've selected a device, you'll be able to see the device information in fields displayed on the right frame (\"Information\")"), { transient => $w->{real_window} });
           }
       },
       undef, '<Item>'
     ],
     if_(!-e "/etc/sysconfig/oem",
	 [ $menus{help} . N("/_Report Bug"), undef, sub { run_program::raw({ detach => 1 }, 'drakbug', '--report', 'harddrake') }, undef, '<Item>' ],
	),
     [ $menus{help} . N("/_About..."), undef, sub {
         my $license = formatAlaTeX(translate($::license));
         $license =~ s/\n/\n\n/sg; # nicer formatting
         my $w = gtknew('AboutDialog', name => N("Harddrake"),
                        version => mandrake_release_info()->{version},
                        copyright => N("Copyright (C) %s by Mandriva", '2001-2008'),
                        license => $license, wrap_license => 1,
                        comments => N("This is HardDrake, a %s hardware configuration tool.", $distro_name),
                        website => 'http://mandrivalinux.com',
                        website_label => N("Mandriva Linux"),
                        authors => 'Thierry Vignaud <vignaud@mandriva.com>',
                        artists => 'Hélène Durosini <ln@mandriva.com>',
                        translator_credits =>
                          #-PO: put here name(s) and email(s) of translator(s) (eg: "John Smith <jsmith@nowhere.com>")
                          N("_: Translator(s) name(s) & email(s)\n"),
                        transient_for => $::main_window, modal => 1, position_policy => 'center-on-parent',
                    );
         $w->show_all;
         $w->run;
       }, undef, '<Item>'
     ]
    );

$in = 'interactive'->vnew('su'); #require_root_capability();

%options = getVarsFromSh($conffile);
$options{MDV_ONLINE} ||= [];

# Build the gui
add_icon_path('/usr/share/pixmaps/harddrake2/');
$::noborderWhenEmbedded = 1;


my ($menubar, $factory) = create_factory_menu($w->{real_window}, @menu_items);
$w->{window}->set_size_request(805, 550) if !$::isEmbedded;

my $tree_model = Gtk2::TreeStore->new("Gtk2::Gdk::Pixbuf", "Glib::String", "Glib::Int");
$w->{window}->add(gtkpack_(0, Gtk2::VBox->new(0, 0),
                           0, $menubar,
                           0, Gtk2::Banner->new("/usr/share/mcc/themes/default/harddrake-mdk.png", translate("Hardware")),
                           1, create_hpaned(gtkadd(Gtk2::Frame->new(N("Detected hardware")), 
                                                   create_scrolled_window(gtkset_size_request(my $tree = Gtk2::TreeView->new_with_model($tree_model), 350, -1), ['automatic', 'automatic'])),
                                            gtkpack_(0, Gtk2::VBox->new(0, 0),
                                                     1, gtkadd(my $frame = Gtk2::Frame->new(N("Information")),
                                                               create_scrolled_window(my $text = Gtk2::TextView->new)),
                                                     0, my $module_cfg_button = gtksignal_connect(Gtk2::Button->new(N("Set current driver options")),
                                                                                                  clicked => sub {
                                                                                                      local $SIG{CHLD} = undef;
                                                                                                      require modules::interactive;
                                                                                                      modules::interactive::config_window($in, $current_device);
                                                                                                      gtkset_mousecursor_normal();
                                                                                                  }),
                                                     0, my $config_button = gtksignal_connect(Gtk2::Button->new(N("Run config tool")),
                                                                                              # we've a configurator, let's add a button for it and show it
                                                                                              clicked => sub {
                                                                                                  return 1 if defined $pid;
                                                                                                  run_program::raw({ detach => 1 }, $current_configurator);
                                                                                              })
                                                     ),
                                            ),
                          )
                 );

$text->set_wrap_mode('word');
$frame->set_size_request(300, 450) unless $::isEmbedded;
#    $tree->set_column_auto_resize(0, 1);
my (@data, @configurators);
$tree->append_column(my $textcolumn = Gtk2::TreeViewColumn->new_with_attributes(undef, Gtk2::MDV::CellRendererPixWithLabel->new, 'pixbuf' => 0, label => 1));
$tree->set_headers_visible(0);

sub fill_default_text {
    my ($text) = @_;
    $text->get_buffer->set_text(N("Click on a device in the left tree in order to display its information here."));
}

$tree->get_selection->signal_connect('changed' => sub {
    my ($select) = @_;
    my ($model, $iter) = $select->get_selected;
    if ($model) {
        my $idx = $model->get($iter, 2);
        ($current_device, $current_class) = @{$data[$idx]};
        
        if ($idx ne -1) {
            use Gtk2::Pango;
            my %device_fields = map {
                # The U+200E character is to force LTR display, as what what follows the colon is always in LTR (device names, paths, etc),
                # this ensures proper displaying of names like /dev/fd0 (otherwise it gets 'dev/fd0/').
                # it must come *after* the space, as the space must follow the colon following the direction of writting.
                my $field = lookup_field($_);
                if_($_ && $field->[0], $_ =>
                   [
                    [ $field->[0] . ": \x{200e}", { 'foreground' => 'royalblue3', 'weight' => Gtk2::Pango->PANGO_WEIGHT_BOLD } ],
                    [ ($current_device->{$_} =~ /^(unknown)/ ? N("unknown") :
                       $current_device->{$_} =~ /^(Unknown)/ ? N("Unknown") : 
                       $current_device->{$_} eq 'yes' ? N("Yes") : 
                       $current_device->{$_} eq 'no'  ? N("No") : 
                       $current_device->{$_}) . "\n\n", if_($_ eq 'driver' && $current_device->{$_} =~ /^unknown|^Bad:/, { foreground => 'indian red' }) ]
                   ]);
            } sort keys %$current_device;
            my %groups = map { if_(ref $groups{$_}, %{$groups{$_}}) } 'generic', $current_class;
            my ($grouped, $ungrouped) = partition {
                my $field = $_;
                member($field, map { @$_ } values %groups);
            } keys %device_fields;
            my @formated;
            foreach my $group (N("Identification"), grep { $_ ne N("Identification") } keys %groups) {
                my @fields = @{$groups{$group}};
                # have we at least a member in that group?
                next unless any { member($_, @fields) } @$grouped;
                
                push @formated, titleFormat($group);
                push @formated, map { if_(ref $_, @$_) } @device_fields{@fields};
            }
            push @formated, if_(@formated && @$ungrouped, titleFormat(N("Misc"))), map { @{$device_fields{$_}} } @$ungrouped;
            gtktext_insert($text, \@formated);

            foreach (keys %$current_device) {
                print qq(Warning: skip "$_" field => "$current_device->{$_}"\n\n) unless (lookup_field($_))[0];
            }
            
            # if we've valid driver, let's offer to configure it, else hide buttons 
            show_hide(defined($current_device->{driver}) && $current_device->{driver} !~ /^unknown|^Bad|^Card|^Hsf|^kbd|^Mouse:USB|^mouse\d|^Removable:|\|/, $module_cfg_button);
            
            $current_configurator = $configurators[$idx];
            show_hide($current_configurator && -x first(split /\s+/, $current_configurator), $config_button);  # strip arguments for -x test
            return 1;
        }
    }
    # No device is selected:
    fill_default_text($text);
    undef $current_device;
    $config_button->hide;
    $module_cfg_button->hide;
});

# show the main window earlier (so that sub dialogs can use main
# window's icon and so that no Gtk+ critical message got displayed):
$w->{rwindow}->show_all;
my $flush_guard = Gtk2::GUI_Update_Guard->new;
$_->hide foreach $module_cfg_button, $config_button; # hide buttons while no device
my $wait = $in->wait_message(N("Please wait"), N("Detection in progress"));
gtkflush() if !$::isEmbedded;


my $index = 0;

my @classes;

# Fill the graphic devices tree with a "tree branch" widget per device category
foreach my $hw_class (@harddrake::data::tree) {
    my ($Ident, $title, $icon, $configurator, $detector) = @$hw_class{qw(class string icon configurator detector)};
    next if ref($detector) ne "CODE"; #skip class witouth detector
    next if $Ident =~ /(MODEM|PRINTER)/ && $::testing;
    next if $Ident =~ /JAZZ/ && !$options{JAZZ_DETECTION};
    next if $Ident =~ /MODEM/ && !$options{MODEMS_DETECTION};
    next if $Ident =~ /PRINTER/ && !$options{PRINTERS_DETECTION};

    my @devices = $detector->(\%options);
    next unless @devices; # Skip empty class (no devices)
    push @classes, [ $Ident, $title, $icon, $configurator, @devices ];
}

# Fill the graphic devices tree with a "tree branch" widget per device category
foreach (@classes) {
    my ($Ident, $title, $icon, $configurator, @devices) = @$_;

    my $parent_iter = $tree_model->append_set(undef, [ 0 => gtkcreate_pixbuf($icon), 1 => $title, 2 => -1 ]);

    my $all_hds;
    $all_hds = fsedit::get_hds() if $Ident eq "HARDDISK";

    # Fill the graphic tree with a "tree leaf" widget per device
    foreach (@devices) {
        # we really should test for $title there:
        if ($_->{bus} && $_->{bus} eq "PCI") {
            # do not display unknown driver for system bridges that're managed by kernel core:
            delete $_->{driver} if $_->{driver} eq "unknown" && ($Ident =~ /^ATA_STORAGE|BRIDGE|SMB_CONTROLLER|MEMORY_OTHER $/ || $_->{description} =~ /3Com.*5610/);
        }
        rename_field($_, 'usb_description', 'description');
        # split description into manufacturer/description
        ($_->{Vendor}, $_->{description}) = split(/\|/, $_->{description}) if $_->{description};

        if ($_->{val}) { # Scanner ?
            my $val = $_->{val};
            ($_->{Vendor}, $_->{description}) = split(/\|/, $val->{DESCRIPTION});
        }
        # EIDE detection incoherency:
        if ($_->{bus} && $_->{bus} eq 'ide') {
            $_->{channel} = $_->{channel} ? N("secondary") : N("primary");
            delete $_->{info} if $_->{Vendor};
        }
        if (defined $_->{capacity}) {
            my ($burner, $dvd) = (N("burner"), N("DVD"));
            $_->{capacity} =~ s/burner/$burner/;
            $_->{capacity} =~ s/DVD/$dvd/;
        }
        $configurator .= harddrake::data::set_removable_configurator($Ident, $_);
        if ($Ident eq "AUDIO") {
            require harddrake::sound;
            my @alter = harddrake::sound::get_alternative($_->{driver});
            if (my $alternative_drivers = join(', ', @alter)) {
		$_->{alternative_drivers} = $alternative_drivers;
	    }
        }
        if ($Ident eq "HARDDISK") {
            my $hd = $_;
            my $info = find { $_->{device} eq $hd->{device} } @{$all_hds->{hds}};
            $hd->{geometry} = join('/', map { $info->{geom}{$_} } qw(cylinders heads sectors)) . " (CHS)";
            $hd->{primary_partitions} = @{$info->{primary}{normal}} if $info->{primary}{normal};
            $hd->{extended_partitions} = @{$info->{extended}} if $info->{extended};
            $hd->{primary_partitions} .= " (" . join(', ', map { $_->{device} }@{$info->{primary}{normal}}) . ")" if $hd->{primary_partitions};
            if ($hd->{extended_partitions}) {
                $hd->{extended_partitions} .= " (" . join(', ', map { $_->{normal}{device} }@{$info->{extended}}) . ")";
            } else {
                delete $hd->{extended_partitions} if $hd->{extended_partitions} eq '0';
            }
        }
        $_->{EmulateWheel} = bool2yesno($_->{EmulateWheel}) if $Ident eq "MOUSE";
        rename_field($_, 'usb_bus', 'bus');
        rename_field($_, 'usb_driver', 'driver');
        rename_field($_, 'usb_id', 'id');
        rename_field($_, 'usb_media_type', 'media_type');
        if ($_->{nice_media_type}) {
            delete $_->{media_type};
            rename_field($_, 'nice_media_type', 'media_type');
        }
        rename_field($_, 'usb_pci_bus', 'bus');
        rename_field($_, 'usb_vendor', 'vendor');
        rename_field($_, 'vendor_name', 'Vendor');

        foreach my $i (qw(synaptics unsafe val wacom)) { delete $_->{$i} }

        my $custom_id = harddrake::data::custom_id($_, $title);
        foreach my $field (qw(device)) {
            $_->{$field} = "/dev/$_->{$field}" if $_->{$field};
        }
        foreach my $field (qw(vendor id subvendor subid)) {
            $_->{$field} = sprintf("0x%04x", $_->{$field});
            delete $_->{$field} if $_->{$field} eq "0xffff";  # 0xffff equals to '*'
        }
        $tree_model->append_set($parent_iter, [ 1 => $custom_id, 2 => $index++ ]);
        push @data, [ $_, $Ident ];
        push @configurators, $configurator;
    }
    $tree->expand_row($tree_model->get_path($parent_iter), 1) unless $title eq N("Unknown/Others");
}

undef $flush_guard;

sub reap_children() {
    # reap zombies
    my $child_pid;
    do { $child_pid = waitpid(-1, POSIX::WNOHANG); undef $pid if $pid == $child_pid } until $child_pid > 0;
}

$SIG{CHLD} = \&reap_children;

$w->{rwindow}->signal_connect(delete_event => \&quit_global);
$w->{rwindow}->set_position('center') unless $::isEmbedded;

foreach (keys %menu_options) {
    my $title = strip_first_underscore(@{$menu_options{$_}});
    $options{$_} = 0 unless defined($options{$_}); # force detection by default
    $check_boxes{$_} = $factory->get_widget("<main>" . $title);
    $check_boxes{$_}->set_active($options{$_});    # restore saved values
}

$textcolumn->set_min_width(350);
#$textcolumn->set_minmax_width(400);
$textcolumn->set_sizing('GTK_TREE_VIEW_COLUMN_AUTOSIZE');#GROW_ONLY
#$tree->columns_autosize();
$tree->signal_connect(realize => sub { $tree->get_selection->select_path(Gtk2::TreePath->new_first) });

{
    $SIG{CHLD} = undef;
    #local $SIG{CHLD} = sub {};

    if (my @packages = difference2([ pkgs::list_hardware_packages() ], [ qw(ati.2 dmraid gnome-alsamixer mdadm xmms-alsa) ])) {
        @packages = grep { !$in->do_pkgs->is_installed($_) } @packages;

        # workarounding do_pkgs->is_available() destroying $_:
        my (@packages2install) = (grep { $in->do_pkgs->is_available($_) } @packages);

        undef $wait;
        gtkset_mousecursor_normal();
        
        if (@packages2install && $in->ask_yesorno(N("Warning"), N("The following packages need to be installed:\n") . join(', ', @packages2install))) {
            $in->do_pkgs->install(@packages2install);
        }
    }
}
$SIG{CHLD} = \&reap_children;
undef $wait;
gtkset_mousecursor_normal();

# fill in default right text since no device is selected on startup:
fill_default_text($text);

$w->main;


sub quit_global() {
    kill(15, $pid) if $pid;
    setVarsInSh($conffile, \%options) if !$::testing;
    ugtk2->exit(0);
}

sub show_hide {
    my ($bool, $button) = @_;
    if ($bool) { $button->show } else { $button->hide }
}


sub strip_first_underscore {
    join '', map { s/_//; $_ } @_;
}

sub lookup_field {
    my ($field) = @_;
    my $class = find { defined $fields{$_} && defined $fields{$_}{$field} } ($current_class, 'generic');
    $fields{$class}{$field};
}

sub titleFormat {
    my ($title) = @_;
    [ $title . "\n", { 'weight' => Gtk2::Pango->PANGO_WEIGHT_BOLD, scale => Gtk2::Pango->PANGO_SCALE_LARGE } ];
}

sub rename_field {
    my ($dev, $field, $new_field) = @_;
    if ($dev->{$field}) {
        if ($dev->{$new_field}) {
            $dev->{$new_field} .= " ($dev->{$field})";
        } else {
            $dev->{$new_field} = $dev->{$field};
        }
        delete $dev->{$field};
    }
}

sub popup_menu {
    my ($menu) = @_;
    sub { my (undef, $event) = @_;
          if ($event->type eq 'button-press') {
              $menu->popup(undef, undef, undef, undef, $event->button, $event->time);
              # Tell calling code that we have handled this event; the buck stops here.
              return 1;
          }
          # Tell calling code that we have not handled this event; pass it on.
          return 0;
      };
}
