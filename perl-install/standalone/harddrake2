#!/usr/bin/perl

use strict;
use diagnostics;
use lib qw(/usr/lib/libDrakX);
use standalone;
use common;

use ugtk2 qw(:create :helpers :wrappers);
use interactive;
use harddrake::data;  #- needs to stay after use-ugtk2 as long as this module defines globals containing some N()
use POSIX qw(:sys_wait_h);


# { field => [ short_translation, full_description] }
my %fields = 
    (
     generic =>
     {
      "alternative_drivers" => [ N("Alternative drivers"),
                                 N("the list of alternative drivers for this sound card") ],
      "bus" => 
      [ N("Bus"), 
        N("this is the physical bus on which the device is plugged (eg: PCI, USB, ...)") ],
      "bus_id" => 
      [ N("Bus identification"), 
        N("- PCI and USB devices: this lists the vendor, device, subvendor and subdevice PCI/USB ids") ],
      "bus_location" => 
      [ N("Location on the bus"), 
        N("- pci devices: this gives the PCI slot, device and function of this card
- eide devices: the device is either a slave or a master device
- scsi devices: the scsi bus and the scsi device ids") ],
      "capacity" => [ N("Drive capacity"), N("special capacities of the driver (burning ability and or DVD support)") ],
      "description" => [ N("Description"), N("this field describes the device") ],
      "device" => [ N("Old device file"),
                    N("old static device name used in dev package") ],
      "devfs_device" => [ N("New devfs device"),  
                          N("new dynamic device name generated by core kernel devfs") ],
      "driver" => [
                   #-PO: here "module" is the "jargon term" for a kernel driver
                   N("Module"), N("the module of the GNU/Linux kernel that handles the device") ],
      "extended_partitions" => [ N("Extended partitions"), N("the number of extended partitions") ],
      "geometry" => [ N("Geometry"), N("Cylinder/head/sectors geometry of the disk") ],
      "host" => [ N("Disk controller"), N("the disk controller on the host side") ],
      "media_type" => [ N("Media class"), N("class of hardware device") ],
      "Model" => [ N("Model"), N("hard disk model") ],
      "port" => [ N("Port"), N("network printer port") ],
      "primary_partitions" => [ N("Primary partitions"), N("the number of the primary partitions") ],
      "Vendor" => [ N("Vendor"), N("the vendor name of the device") ],
      "pci_bus" => [ N("Bus PCI #"), N("the PCI bus on which the device is plugged") ],
      "pci_device" => [ N("PCI device #"), N("PCI device number") ],
      "pci_function" => [ N("PCI function #"), N("PCI function number") ],
      "vendor" => [ N("Vendor ID"), N("this is the standard numerical identifiant of the vendor") ],
      "id" => [ N("Device ID"), N("this is the numerical identifiant of the device") ],
      "subvendor" => [ N("Sub vendor ID"), N("this is the minor numerical identifiant of the vendor") ],
      "subid" => [ N("Sub device ID"), N("this is the minor numerical identifiant of the device") ],
      "usb_pci_device" =>, [ N("Device USB ID"), N("..") ],
     },
     CPU =>
     {
      "bogomips" => [ N("Bogomips"), N("the GNU/Linux kernel needs to run a calculation loop at boot time to initialize a timer counter.  Its result is stored as bogomips as a way to \"benchmark\" the cpu.") ],
      "cache size" => [ N("Cache size"), N("size of the (second level) cpu cache") ],
      "coma_bug" => [
                     #-PO: here "comas" is the medical coma, not the lexical coma!!
                     N("Coma bug"), N("whether this cpu has the Cyrix 6x86 Coma bug") ],
      "cpu family" => [ N("Cpuid family"), N("family of the cpu (eg: 6 for i686 class)") ],
      "cpuid level" => [ N("Cpuid level"), N("information level that can be obtained through the cpuid instruction") ],
      "cpu MHz" => [ N("Frequency (MHz)"), N("the CPU frequency in MHz (Megahertz which in first approximation may be coarsely assimilated to number of instructions the cpu is able to execute per second)") ],
      "flags" => [ N("Flags"), N("CPU flags reported by the kernel") ],
      "fdiv_bug" => [ N("Fdiv bug"), 
                      N("Early Intel Pentium chips manufactured have a bug in their floating point processor which did not achieve the required precision when performing a Floating point DIVision (FDIV)") ],
      "fpu" => [ N("Is FPU present"), N("yes means the processor has an arithmetic coprocessor") ],
      "fpu_exception" => [ N("Whether the FPU has an irq vector"), N("yes means the arithmetic coprocessor has an exception vector attached") ],
      "f00f_bug" => [ N("F00f bug"), N("early pentiums were buggy and freezed when decoding the F00F bytecode") ],
      "hlt_bug" => [ N("Halt bug"), 
                     N("Some of the early i486DX-100 chips cannot reliably return to operating mode after the \"halt\" instruction is used") ],
      "level" => [ N("Level"), N("sub generation of the cpu") ],
      "model" => [ N("Model"), N("generation of the cpu (eg: 8 for PentiumIII, ...)") ],
      "model name" => [ N("Model name"), N("official vendor name of the cpu") ],
      "name" => [ N("Name"), N("the name of the CPU") ],
      "processor" => [ N("Processor ID"), N("the number of the processor") ],
      "stepping" => [ N("Model stepping"), N("stepping of the cpu (sub model (generation) number)") ],
      "vendor_id" => [ N("Vendor"), N("the vendor name of the processor") ],
      "wp" => [ N("Write protection"), N("the WP flag in the CR0 register of the cpu enforce write proctection at the memory page level, thus enabling the processor to prevent unchecked kernel accesses to user memory (aka this is a bug guard)") ],
     },
     FLOPPY =>
     {
      info => [ N("Floppy format"), N("format of floppies supported by the drive") ],
     },
     HARDDISK =>
     {
      channel => [ N("Channel"), N("EIDE/SCSI channel") ],
      info => [ N("Disk identifier"), N("usually the disk serial number") ],
      lun => [ N("Logical unit number"), N("the SCSI target number (LUN). SCSI devices connected to a host are uniquely identified by a
channel number, a target id and a logical unit number") ],
     },
     MOUSE =>
     {
      "device" => [ N("Device file"), N("the device file used to communicate with the kernel driver for the mouse") ],
      EMULATEWHEEL => [ N("Emulated wheel"), N("whether the wheel is emulated or not") ],
      MOUSETYPE => [ N("Type"), N("the type of the mouse") ],
      name => [ N("Name"), N("the name of the mouse") ],
      nbuttons => [ N("Number of buttons"), N("the number of buttons the mouse has") ],
      type => [ N("Bus"), N("the type of bus on which the mouse is connected") ],
      XMOUSETYPE => [ N("Mouse protocol used by X11"), N("the protocol that the graphical desktop use with the mouse") ],
     }
    );

my %groups = (
              generic =>
              {
               N("Identification") => [ qw(Vendor model description info media_type) ],
               N("Connection") => [ qw(bus pci_bus pci_device pci_function vendor id subvendor subid) ],
              },
              AUDIO =>
              {
               N("Driver") => [ qw(driver alternative_drivers) ],
              },
              CPU =>
              {
               N("Identification") => [ qw(processor vendor_id), "model name", "cpu family", qw(model level stepping) ],
               N("Performances") => [ "cpu MHz", "cache size", "bogomips" ],
               N("Bugs") => [ qw(fdiv_bug coma_bug f00f_bug hlt_bug) ],
               N("FPU")  => [ qw(fpu fpu_exception) ],
              },
              HARDDISK =>
              {
               N("Identification") => [ qw(Vendor Model description info media_type) ],
               N("Connection") => [ qw(bus channel lun) ],
               N("Bus identification") => [ qw(vendor id subvendor subid) ],
               N("Device") => [ qw(device devfs_device) ],
               N("Partitions") => [ qw(primary_partitions extended_partitions) ],
              },
              MOUSE =>
              {
               N("Identification") => [ qw(name type MOUSETYPE XMOUSETYPE) ],
               N("Features") => [ qw(EMULATEWHEEL nbuttons) ],
              },
             );

foreach my $class (qw(BURNER CDROM DVDROM)) {
    $groups{$class} = $groups{HARDDISK};
    $fields{$class} = $fields{HARDDISK};
}


my ($in, $pid, $w);

my (%options, %check_boxes);
my $conffile = "/etc/sysconfig/harddrake2/ui.conf";

my ($current_device, $current_class, $current_configurator);


my %menus = (
             'options' => 
             #-PO: please keep all "/" charaters !!!
             N("/_Options"),
             'help' => N("/_Help")
             );

my %menu_options = (
                    'PRINTERS_DETECTION' => [ $menus{options}, N("/Autodetect _printers") ],
                    'MODEMS_DETECTION' => [ $menus{options}, N("/Autodetect _modems") ],
                    'JAZZ_DETECTION' => [ $menus{options}, N("/Autodetect _jaz drives") ],
                    );


my @menu_items = 
    (
     [ N("/_File"), undef, undef, undef, '<Branch>' ],
     [ N("/_File").N("/_Quit"), N("<control>Q"), \&quit_global, undef, '<StockItem>', 'gtk-quit' ],
     [ join('', @{$menu_options{PRINTERS_DETECTION}}), undef, 
       sub { $options{PRINTERS_DETECTION} = $check_boxes{PRINTERS_DETECTION}->get_active }, undef, '<CheckItem>' ],
     [ join('', @{$menu_options{MODEMS_DETECTION}}), undef,
       sub { $options{MODEMS_DETECTION} = $check_boxes{MODEMS_DETECTION}->get_active }, undef, '<CheckItem>' ],
     [ join('', @{$menu_options{JAZZ_DETECTION}}), undef,
       sub { $options{JAZZ_DETECTION} = $check_boxes{JAZZ_DETECTION}->get_active }, undef, '<CheckItem>' ],
     [ $menus{help}, undef, undef, undef, '<Branch>' ],
     [ $menus{help}.N("/_Help"), undef, sub { unless (fork()) { exec("drakhelp --id harddrake") } }, undef, '<Item>' ],
     [ $menus{help}.N("/_Fields description"), undef, sub {
           if ($current_device) {
               create_dialog(N("Harddrake help"), 
                             N("Description of the fields:\n\n")
                             . join("\n\n", map {
                                 my $info = lookup_field($_);
                                 if_($info->[0], formatAlaTeX(qq(<span foreground="royalblue3">$info->[0]:</span> $info->[1])))
                             } sort keys %$current_device),
                             { use_markup => 1, if_(!$::isEmbedded, transient => $w->{window}), height => 400, scroll => 1 })

           } else {
               create_dialog(N("Select a device !"), N("Once you've selected a device, you'll be able to see the device information in fields displayed on the right frame (\"Information\")"), { if_(!$::isEmbedded, transient => $w->{window}) })
           }
       },
       undef, '<Item>'
     ],
     [ $menus{help}.N("/_Report Bug"), undef, sub { unless (fork()) { exec("drakbug --report harddrake2 &") } }, undef, '<Item>' ],
     [ $menus{help}.N("/_About..."), undef, sub {
           create_dialog(N("About Harddrake"), 
#-PO: Do not alter the <span ..> and </span> tags
                         N("This is HardDrake, a Mandrake hardware configuration tool.\n<span foreground=\"royalblue3\">Version:</span> %s
<span foreground=\"royalblue3\">Author:</span> Thierry Vignaud &lt;tvignaud\@mandrakesoft.com&gt;\n\n", $harddrake::data::version) . "\n" .
                         formatAlaTeX($::license), { use_markup => 1, if_(!$::isEmbedded, transient => $w->{window}) });
       }, undef, '<Item>'
     ]
    );

$ugtk2::wm_icon = "harddrake";
$in = 'interactive'->vnew('su'); #require_root_capability();

my $wait = $in->wait_message(N("Please wait"), N("Detection in progress"));
gtkflush();

%options = getVarsFromSh($conffile);

# Build the gui
add_icon_path('/usr/share/pixmaps/harddrake2/');
$w = ugtk2->new(N("Harddrake2 version %s", $harddrake::data::version));
local $::main_window;   # fake diagnostics pragma
my ($menubar, $factory, $opt_menu, $help_menu);
if ($::isEmbedded) {
    ($menubar, $factory) = create_factory_popup_menu($::Plug, @menu_items);
    $opt_menu = $factory->get_widget("<main>" . strip_first_underscore($menus{options}));
    $help_menu = $factory->get_widget("<main>" . strip_first_underscore($menus{help}));
} else {
    $::main_window = $w->{rwindow};
    ($menubar, $factory) = create_factory_menu($w->{rwindow}, @menu_items);
    $w->{window}->set_size_request(805, 550);
}

my $tree_model = Gtk2::TreeStore->new("Gtk2::Gdk::Pixbuf", "Glib::String", "Glib::Int");
$w->{window}->add(gtkpack_(0, Gtk2::VBox->new(0, 0),
                           if_(!$::isEmbedded, 0, $menubar),
                           1, create_hpaned(gtkadd(Gtk2::Frame->new(N("Detected hardware")), 
                                                   create_scrolled_window(gtkset_size_request(my $tree = Gtk2::TreeView->new_with_model($tree_model), $::isEmbedded ? 250 : 350, -1), ['automatic', 'automatic'])),
                                            gtkpack_(0, Gtk2::VBox->new(0, 0),
                                                     1, gtkadd(my $frame = Gtk2::Frame->new(N("Information")),
                                                               create_scrolled_window(my $text = Gtk2::TextView->new)),
                                                     0, my $module_cfg_button = gtksignal_connect(Gtk2::Button->new(N("Configure module")),
                                                                                                  clicked => sub {
                                                                                                      local $SIG{CHLD} = undef;
                                                                                                      require modules::interactive;
                                                                                                      modules::interactive::config_window($in, $current_device);
                                                                                                      gtkset_mousecursor_normal();
                                                                                                  }),
                                                     0, my $config_button = gtksignal_connect(Gtk2::Button->new(N("Run config tool")),
                                                                                              # we've a configurator, let's add a button for it and show it
                                                                                              clicked => sub {
                                                                                                  return 1 if defined $pid;
                                                                                                  if ($pid = fork()) {
                                                                                                  } else {
                                                                                                      exec($current_configurator) or die "$current_configurator missing\n";
                                                                                                  }
                                                                                              })
                                                     ),
                                            ),
                           if_($::isEmbedded, 
                               0, 
                               gtkpack(Gtk2::HBox->new,
                                       gtkpack(create_hbox('start'),
                                               gtksignal_connect(Gtk2::Button->new(N("Help")), event => popup_menu($help_menu), $menubar),
                                               gtksignal_connect(Gtk2::Button->new(N("Options")), event => popup_menu($opt_menu), $menubar),
                                              ),
                                       gtkpack(create_hbox('end'),
                                               gtksignal_connect(Gtk2::Button->new(N("Quit")), clicked => \&quit_global),
                                              ),
                                      ),
                              )
                          )
                 );

$text->set_wrap_mode('word');
$frame->set_size_request(300, 450) unless $::isEmbedded;
#    $tree->set_column_auto_resize(0, 1);
my (@data, @configurators);
$tree->append_column(Gtk2::TreeViewColumn->new_with_attributes(undef, Gtk2::CellRendererPixbuf->new, 'pixbuf' => 0));
$tree->append_column(my $textcolumn = Gtk2::TreeViewColumn->new_with_attributes(undef, Gtk2::CellRendererText->new, 'text' => 1));
$tree->set_headers_visible(0);
$tree->get_selection->signal_connect('changed' => sub {
    my ($select) = @_;
    my ($model, $iter) = $select->get_selected;
    if ($model) {
        my $idx = $model->get($iter, 2);
        ($current_device, $current_class) = @{$data[$idx]};
        
        if ($idx ne -1) {
            use Gtk2::Pango;
            my %device_fields = map {
                # The U+200E character is to force LTR display, as what what follows the colon is always in LTR (device names, paths, etc),
                # this ensures proper displaying of names like /dev/fd0 (otherwise it gets 'dev/fd0/').
                # it must come *after* the space, as the space must follow the colon following the direction of writting.
                my $field = lookup_field($_);
                if_($_ && $field->[0], $_ =>
                   [
                    [ $field->[0] . ": \x{200e}", { 'foreground' => 'royalblue3', 'weight' => Gtk2::Pango->PANGO_WEIGHT_BOLD } ],
                    [ ($current_device->{$_} =~ /^(unknown)/ ? N("unknown") :
                       $current_device->{$_} =~ /^(Unknown)/ ? N("Unknown") : 
                       $current_device->{$_} eq 'yes' ? N("Yes") : 
                       $current_device->{$_} eq 'no'  ? N("No") : 
                       $current_device->{$_}) . "\n\n", if_($_ eq 'driver' && $current_device->{$_} =~ /^unknown|^Bad:/, { foreground => 'indian red' }) ]
                   ])
            } sort keys %$current_device;
            my %groups = map { if_(ref $groups{$_}, %{$groups{$_}}) } 'generic', $current_class;
            my ($grouped, $ungrouped) = partition {
                my $field = $_;
                member($field, map { @$_ } values %groups);
            } keys %device_fields;
            my @formated;
            foreach my $group (N("Identification"), grep { $_ ne N("Identification") } keys %groups) {
                my @fields = @{$groups{$group}};
                # have we at least a member in that group?
                next unless any { member($_, @fields) } @$grouped;
                
                push @formated, titleFormat($group);
                push @formated, map { if_(ref $_, @$_) } @device_fields{@fields};
            };
            push @formated, if_(@formated && @$ungrouped, titleFormat(N("Misc"))), map { @{$device_fields{$_}} } @$ungrouped;
            gtktext_insert($text, \@formated);

            foreach (keys %$current_device) {
                print qq(Warning: skip "$_" field => "$current_device->{$_}"\n\n) unless (lookup_field($_))[0];
            };
            
            # if we've valid driver, let's offer to configure it, else hide buttons 
            show_hide(defined($current_device->{driver}) && $current_device->{driver} !~ /^unknown|^Bad|^Card|^Hsf|^Removable:|\|/, $module_cfg_button);
            
            $current_configurator = $configurators[$idx];
            show_hide($current_configurator && -x first(split /\s+/, $current_configurator), $config_button);  # strip arguments for -x test
            return 1;
        }
    }
    $text->get_buffer->set_text(N("Click on a device in the left tree in order to display its information here."));
    undef $current_device;
    $config_button->hide;
    $module_cfg_button->hide;
});

my $index = 0;

my @classes;

# Fill the graphic devices tree with a "tree branch" widget per device category
foreach my $hw_class (@harddrake::data::tree) {
    my ($Ident, $title, $icon, $configurator, $detector) = @$hw_class{qw(class string icon configurator detector)};
    next if ref($detector) ne "CODE"; #skip class witouth detector
    # blacklist agp controllers b/c string is not yet translated:
    next if $Ident eq 'AGP';
    next if $Ident =~ /(MODEM|PRINTER)/ && $::testing;
    next if $Ident =~ /JAZZ/ && !$options{JAZZ_DETECTION};
    next if $Ident =~ /MODEM/ && !$options{MODEMS_DETECTION};
    next if $Ident =~ /PRINTER/ && !$options{PRINTERS_DETECTION};

    my @devices = &$detector;
    next unless @devices; # Skip empty class (no devices)
    push @classes, [ $Ident, $title, $icon, $configurator, @devices ];
}

# Fill the graphic devices tree with a "tree branch" widget per device category
foreach (@classes) {
    my ($Ident, $title, $icon, $configurator, @devices) = @$_;

    my $parent_iter = $tree_model->append_set(undef, [ 0 => gtkcreate_pixbuf($icon), 1 => $title, 2 => -1 ]);

    my $all_hds;
    $all_hds = fsedit::get_hds() if $Ident eq "HARDDISK";

    # Fill the graphic tree with a "tree leaf" widget per device
    foreach (@devices) {
        # we really should test for $title there:
        if ($_->{bus} && $_->{bus} eq "PCI") {
            # do not display unknown driver for system bridges that're managed by kernel core:
            delete $_->{driver} if $_->{driver} eq "unknown" && ($Ident =~ /^ATA_STORAGE|BRIDGE|SMB_CONTROLLER$/ || $_->{description} =~ /3Com.*5610/);
        }
        rename_field($_, 'usb_description', 'description');
        # split description into manufacturer/description
        ($_->{Vendor}, $_->{description}) = split(/\|/, $_->{description}) if $_->{description};

        if ($_->{val}) { # Scanner ?
            my $val = $_->{val};
            ($_->{Vendor}, $_->{description}) = split(/\|/, $val->{DESCRIPTION});
        }
        # EIDE detection incoherency:
        if ($_->{bus} && $_->{bus} eq 'ide') {
            $_->{channel} = $_->{channel} ? N("secondary") : N("primary");
            delete $_->{info} if $_->{Vendor};
        }
        if (defined $_->{capacity}) {
            my ($burner, $dvd) = (N("burner"), N("DVD"));
            $_->{capacity} =~ s/burner/$burner/;
            $_->{capacity} =~ s/DVD/$dvd/;
        }
        $configurator .= harddrake::data::set_removable_configurator($Ident, $_);
        if ($Ident eq "AUDIO") {
            require harddrake::sound;
            my $alter = harddrake::sound::get_alternative($_->{driver});
            my $alternative_drivers = join(':', @$alter) if $alter->[0] ne 'unknown';
            $_->{alternative_drivers} = $alternative_drivers if $alternative_drivers;
        }
        if ($Ident eq "HARDDISK") {
            my $hd = $_;
            my $info = find { $_->{device} eq $hd->{device} } @{$all_hds->{hds}};
            $hd->{geometry} = join('/', map { $info->{geom}{$_} } qw(cylinders heads sectors)) . " (CHS)";
            $hd->{primary_partitions} = @{$info->{primary}{normal}};
            $hd->{extended_partitions} = @{$info->{extended}};
            $hd->{primary_partitions} .= " (" . join(', ', map { $_->{device} }@{$info->{primary}{normal}}) . ")" if $hd->{primary_partitions};
            if ($hd->{extended_partitions}) {
                $hd->{extended_partitions} .= " (" . join(', ', map { $_->{normal}{device} }@{$info->{extended}}) . ")";
            } else {
                delete $hd->{extended_partitions} if $hd->{extended_partitions} eq '0';
            }
        }
        $_->{EMULATEWHEEL} = bool2yesno($_->{EMULATEWHEEL}) if $Ident eq "MOUSE";
        rename_field($_, 'usb_bus', 'bus');
        rename_field($_, 'usb_driver', 'driver');
        rename_field($_, 'usb_id', 'id');
        rename_field($_, 'usb_media_type', 'media_type');
        rename_field($_, 'usb_pci_bus', 'bus');
        rename_field($_, 'usb_vendor', 'vendor');
        rename_field($_, 'vendor_name', 'Vendor');

        foreach my $i (qw(auxmouse devfs_prefix unsafe val wacom)) { delete $_->{$i} };

        my $custom_id = harddrake::data::custom_id($_, $title);
        foreach my $field (qw(devfs_device device)) {
            $_->{$field} = '/dev/'.$_->{$field} if $_->{$field};
        }
        $tree_model->append_set($parent_iter, [ 1 => $custom_id, 2 => $index++ ]);
        push @data, [ $_, $Ident ];
        push @configurators, $configurator;
    }
    $tree->expand_row($tree_model->get_path($parent_iter), 1) unless $title eq N("Unknown/Others");
}

$SIG{CHLD} = sub {
    undef $pid;
    # reap zombies
    my $child_pid;
    do { $child_pid = waitpid(-1, POSIX::WNOHANG) } until $child_pid > 0;
};

$w->{rwindow}->signal_connect(delete_event => \&quit_global);
$w->{rwindow}->set_position('center') unless $::isEmbedded;

foreach (keys %menu_options) {
    my $title = strip_first_underscore(@{$menu_options{$_}});
    $options{$_} = 0 unless defined($options{$_}); # force detection by default
    $check_boxes{$_} = $factory->get_widget("<main>" . $title);
    $check_boxes{$_}->set_active($options{$_});    # restore saved values
}

$textcolumn->set_min_width(350);
#$textcolumn->set_minmax_width(400);
$textcolumn->set_sizing('GTK_TREE_VIEW_COLUMN_AUTOSIZE');#GROW_ONLY
#$tree->columns_autosize();
$tree->signal_connect(realize => sub { $tree->get_selection->select_path(Gtk2::TreePath->new_first) });
$w->{rwindow}->show_all;
undef $wait;
gtkset_mousecursor_normal();
$_->hide foreach $module_cfg_button, $config_button; # hide buttons while no device
$w->main;


sub quit_global() {
    kill(15, $pid) if $pid;
    setVarsInSh($conffile, \%options) if !$::testing;
    ugtk2->exit(0);
}

sub show_hide {
    my ($bool, $button) = @_;
    if ($bool) { $button->show } else { $button->hide }
}


sub strip_first_underscore {
    join '', map { s/_//; $_ } @_;
}

sub lookup_field {
    my ($field) = @_;
    my $class = find { defined $fields{$_} && defined $fields{$_}{$field} } ($current_class, 'generic');
    $fields{$class}{$field};
}

sub titleFormat {
    my ($title) = @_;
    [ $title . "\n", { 'weight' => Gtk2::Pango->PANGO_WEIGHT_BOLD, size => 14 * Gtk2::Pango->PANGO_SCALE } ];
}

sub rename_field {
    my ($dev, $field, $new_field) = @_;
    if ($dev->{$field}) {
        if ($dev->{$new_field}) {
            $dev->{$new_field} .= " ($dev->{$field})";
        } else {
            $dev->{$new_field} = $dev->{$field};
        }
        delete $dev->{$field};
    }
}

sub popup_menu {
    my ($menu) = @_;
    sub { my (undef, $event) = @_;
          if ($event->type eq 'button-press') {
              $menu->popup(undef, undef, undef, undef, $event->button, $event->time);
              # Tell calling code that we have handled this event; the buck stops here.
              return 1;
          }
          # Tell calling code that we have not handled this event; pass it on.
          return 0;
      }
}
