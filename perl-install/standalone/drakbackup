#!/usr/bin/perl
#
#  Copyright (C) 2001 MandrakeSoft by Sebastien DUPONT <dupont_s@epita.fr>
#  Updated 2002 by Stew Benedict <sbenedict@mandrakesoft.com>
#  Redistribution of this file is permitted under the terms of the GNU
#  Public License (GPL)
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2, or (at your option)
#  any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#________________________________________________________________
#
#  Description:
#
#   Drakbackup is used to backup your system.
#   During the configuration you can select 
# 	- System files, 
# 	- Users files, 
# 	- Other files.
# 	or All your system ...  and Other (like windows Partitions)
#
#   Drakbackup allows you to backup your system on:
# 	- Harddrive.
# 	- NFS.
# 	- CDROM (CDRW), DVDROM (with autoboot, rescue and autoinstall.).
# 	- FTP.
# 	- Rsync.
# 	- Webdav.
# 	- Tape.
#
#   Drakbackup allows you to Restore your system on
#   choosen directory.
#
#   Per default all backup will be stored on your
#   /var/lib/drakbackup directory
#
#   Configuration file:
# 	/etc/drakconf/drakbackup/drakbakup.conf
#
#________________________________________________________________
#
#  Backup files formats:
#	
#	no incremental backup:
#			backup_sys_date_hour.tar.*
#			backup_user_toto_date_hour.tar.*
#			backup_other_date_hour.tar.*
#
#	first incremental backup: (if backup_base* does not exist )
#
#			backup_base_sys_date_hour.tar.*
#			backup_base_user_toto_date_hour.tar.*
#			backup_base_other_date_hour.tar.*
#			
#	other incremental backup: (if backup_base* already exist )
#
#			backup_incr_sys_date_hour.tar.*
#			backup_incr_user_toto_date_hour.tar.*
#			backup_incr_other_date_hour.tar.*
#
#________________________________________________________________
# 
# REQUIRE:      cron if daemon
#               cdrecord & mkisofs
#		perl Net::FTP
#		ssh-askpass
#		sitecopy - for webdav
#		rsync
#		
# BUGS :
#DONE		restore->other_media->next->previous => crash ...
#DONE		selection des sources a inclure dans le backup cd. 
#DONE		help -> ok after install_rpm
#    	sort of fixed - doesn't always land where you would expect
#		but at least it doesn't die
#           
# TODO:
#		1 - print ftp problem for user. 
#	    2 - calcul disk space.
#		   use quota.
#       3 - ssh & rsync -> expect or .identity.pub/authorized_keys 
#WHY? - Apple can read Joliet - would you really be restoring on MacOS?		
#		4 - write on cd --> ! change Joliet to HFS for Apple
#		5 - cd writer detection  -> cdrw: /sys/dev/cdrom/info  /scsi/host0/bus0/target4/lun0 
#			/proc/sys/dev/cdrom/
#		6 - total backup.( all partitions wanted, windows partitions for example!)
#		    dump use for total backup.
#		7 - custom deamon
#		8 - placer README dans $save_path -> prevenir des danger de supprimer la premier version
#		    explain configuration file variables (mainly for non X users)
#DONE		9 - webdav
#	    10- backend : --resore_all, --restore_sys, --restore_users
#			  --build_cd_autoinst 	
#--default does this NOW			  
#			  --backup_now --backup_default_now
#DONE		11- tape device support		 
#		12- cpio use !!
#		13- boot floppy disk (with dialog)
#		14- build autoboot with backup and install cd 
#		15- use .backupignore like on CVS
#		16- afficher les modif dans un fichier texte du meme nom 
#			pour afficher durant le restore.
#		17- futur: could be possible to restore a specific file 
#			or directory at specific date. 
#		18- possible all files each time from directory.
#		               
# DONE TODAY:
#________________________________________________________________

use Gtk;
use lib qw(/usr/lib/libDrakX );

use standalone;     #- warning, standalone must be loaded very first, for 'explanations'

use interactive;
use my_gtk qw(:helpers :wrappers);
use common;
use strict;
use Time::localtime;


my $in = 'interactive'->vnew('', 'default');
$::isEmbedded = ($::XID, $::CCPID) = "@ARGV" =~ /--embedded (\w+) (\w+)/;

if ("@ARGV" =~ /--help|-h/) {
    print q(Backup and Restore application

--default             : save default directories.
--debug		      : show all debug messages.
--show-conf           : list of files or directories to backup.
--daemon              : use daemon configuration. 
--help                : show this message.
--version             : show version name.
);
    exit(0);
}

if ("@ARGV" =~ /--version/) {
    print "Drakbackup Version 1.2\n";
    exit(0);
}

# Backend Options.
# make this global for status screen      
my $window1;
my $central_widget;
my $previous_widget;
my $current_widget;
my $interactive;
my $up_box;
my $advanced_box;
my $box2;
my $cfg_file_exist = 0;
my @all_user_list;
my $list_other;
my $DEBUG = 0;
my $restore_sys = 1; 
my $restore_user = 1; 
my $restore_other = 1; 
my $restore_step_sys_date = "";
my @user_backuped = ();
my @sys_backuped = ();
my $sys_backuped = 0;
my $other_backuped = 0;
my @user_list_to_restore= ();
my @sys_list_to_restore = ();
my $cd_device_entry;
my $custom_help;
my $button_box;
my $button_box_tmp;
my $next_widget;
my $sav_next_widget;
my $system_state;
my $restore_state;
my $save_path_entry;
my $restore_find_path_entry;
my $pbar;
my $pbar1;
my $pbar2;
my $pbar3;
my $the_time;
my @user_list_to_restore2 = ();
my @data_backuped = ();
my $label_tail;
my @list_to_build_on_cd = (); 
my $restore_path = "/";
my $restore_other_path = 0;
my $restore_other_src;
my $path_to_find_restore;
my $other_media_hd;
my $backup_bef_restore = 0;
my $table;
my @user_list_backuped = ();
my @files_corrupted = ();
my $remove_user_before_restore = 1;
my @file_list_to_send_by_ftp = ();
my $results;
my @net_methods = ("ftp", "rsync", "ssh", "webdav");
my @media_types = ("cd", "hd", "tape");
my %cd_devices;
my $cd_drives;

# config. FILES -> Default PATH  & Global variables.
my @sys_files = ("/etc");
my @user_list;
my @list_other = () ;
my $cfg_dir = "/etc/drakxtools/drakbackup/";
my $cfg_file = $cfg_dir . "drakbackup.conf";
my $save_path = "/var/lib/drakbackup";
my $log_file = "/var/log/drakbackup.log";
my $comp_mode = 0;
my $backup_sys = 1;
my $backup_user = 1;
my $backup_daemon = 1;
my $backup_sys_versions = 1;
my $backup_user_versions = 1;
my $backup_other_versions = 0;
my $what_no_browser = 1;
my $cdrw = 0;
my $net_proto= '';
my $host_path = '';
my $login_user = '';
my $daemon = 0;
my $backend_only = 0;
my $daemon_media = '';
my $ssh_daemon = 0;
my $ftp_daemon = 0;
my $hd_daemon = 0;
my $cd_daemon = 0;
my $tape_daemon = 0;
my $webdav_daemon = 0;
my $rsync_daemon = 0;
my $hd_quota = 0;
#my $where_net_ftp = 0;

#- 7/4/2002 SB - consolidate net methods
my $where_use_net = 0;

#my $where_net_ssh = 0;
my $where_net = 0;
my $where_hd = 1;
my $where_cd = 0;
my $where_tape = 0;
my $cd_time = 650;
my $when_space;
my $cd_with_install_boot = 0;
my $cd_device = '';
my $host_name = '';
my $backupignore = 0; 
my $auth_choice = 0;
my $remember_pass = 0;
my $passwd_user= '';
my $tape_device = ();
my $media_erase = 0;
my $no_critical_sys = 1;
my $send_mail = 0;
my $user_mail;

foreach (@ARGV) {
    /--default/ and backend_mode();
    /--daemon/ and daemon_mode();
    /--show-conf/ and show_conf();
	/--cd-info/ and get_cd_info(), exit(0);
    /--debug/ and $DEBUG = 1, next;
}

sub show_conf {
    print "DrakBackup configuration:\n\n";
    read_conf_file();
    system_state();
    print $system_state . "\n";
    exit(0);
}

sub backend_mode {
	$backend_only = 1;
    build_backup_files();
    exit(0);
}

sub daemon_mode {
    $daemon = 1;
    build_backup_files();
    exit(0);
}

interactive_mode();

sub all_user_list {
    my ($username) = @_;
    my $passwdfile = "/etc/passwd";
    my $user;
    my $uid;
    @all_user_list = ();

    open (PASSWD, $passwdfile) or exit 1; 
    while (defined(my $line = <PASSWD>)) {
		chomp($line);
		($user, $uid) = (split(/:/, $line))[0, 2];
		if ($uid >= 500 || $uid == 0 ) {
	    	push @all_user_list, $user;
		}
    }
    close (PASSWD);
    if ($DEBUG) {
		print "/--  User list  --/ \n";
		print " -> $_\n" foreach (@all_user_list);
		print "\n";
    }
}

sub the_time {
    $the_time = "_";
    $the_time .= localtime->year() + 1900;
    if (localtime->mon() < 9 ) { $the_time .= "0"; }
    $the_time .= localtime->mon() +1;
    if (localtime->mday() < 10 ) { $the_time .= "0"; }
    $the_time .= localtime->mday();
    $the_time .= "_";
    if (localtime->hour() < 10 ) { $the_time .= "0"; }
    $the_time .= localtime->hour();
    if (localtime->min() < 10 ) { $the_time .= "0"; }
    $the_time .= localtime->min();
    if (localtime->sec() < 10 ) { $the_time .= "0"; }
    $the_time .= localtime->sec();    
}

sub get_cd_info {
	my @cd_info = cat_("/proc/sys/dev/cdrom/info");
	my @line_data = ();
	my @drive_names = ();
	my $i;
	my $key;
	my $info;
	
	#- kind of ugly - I'm sure Pixel could improve this, but it works
	#- parse /proc/sys/dev/cdrom/info and get all the cd device capabilities
	foreach (@cd_info) {
		@line_data = split(/[:\t]+/, $_);
		if ($line_data[0] =~ "drive name") {
			$cd_drives = @line_data-1;
			chop($line_data[$cd_drives]);
			@drive_names = @line_data;
			print "drives: $cd_drives\n" if (!$interactive);
		}
		chop($line_data[$cd_drives]) if $cd_drives;
		if ($line_data[0] eq "drive speed") {
			for($i=1;$i<=$cd_drives;$i++) {
				$cd_devices{$drive_names[$i]}->{speed} = $line_data[$i];
			}
		}
		if ($line_data[0] eq "Can change speed") {
			for($i=1;$i<=$cd_drives;$i++) {
				$cd_devices{$drive_names[$i]}->{chg_speed} = $line_data[$i];
			}
		}
		if ($line_data[0] eq "Can read multisession") {
			for($i=1;$i<=$cd_drives;$i++) {
				$cd_devices{$drive_names[$i]}->{multisession} = $line_data[$i];
			}
		}
		if ($line_data[0] eq "Can write CD-R") {
			for($i=1;$i<=$cd_drives;$i++) {
				$cd_devices{$drive_names[$i]}->{cdr} = $line_data[$i];
			}
		}
		if ($line_data[0] eq "Can write CD-RW") {
			for($i=1;$i<=$cd_drives;$i++) {
				$cd_devices{$drive_names[$i]}->{cdrw} = $line_data[$i];
			}
		}
		if ($line_data[0] eq "Can write DVD-R") {
			for($i=1;$i<=$cd_drives;$i++) {
				$cd_devices{$drive_names[$i]}->{dvdr} = $line_data[$i];
			}
		}
		if ($line_data[0] eq "Can write DVD-RAM") {
			for($i=1;$i<=$cd_drives;$i++) {
				$cd_devices{$drive_names[$i]}->{dvdram} = $line_data[$i];
			}
		}
	}
	
	#- now we know all the capabilities, we need the cdrecord device id
	#- this is scsi-channel, id, lun from /dev/scsi/host*
	#- oops - can't count on devfs - use dmesg

	system("dmesg | grep sr[0-9] > /tmp/dmesg");
	my $info = "/tmp/dmesg";
	open(INFO, $info) || warn("Can't open $info\n");
	while(<INFO>) {
		if (/sr[0-9] at/) {
			@line_data=split(/[ \t,]+/, $_);
			chop($line_data[11]);
			$line_data[5] =~ s/scsi//;
			$cd_devices{$line_data[3]}->{rec_dev} = $line_data[5] . "," . $line_data[9] . "," . $line_data[11];
		}
    }
    close(INFO);
    unlink("/tmp/dmesg");

	#- now just report the data if we called --cd-info from the command line
	if (!$interactive) {
		foreach $key (keys %cd_devices) {
			print "\n{$key}->{rec_dev} = $cd_devices{$key}->{rec_dev}\n"; 
			print "{$key}->{speed} = $cd_devices{$key}->{speed}\n";
			print "{$key}->{chg_speed} = $cd_devices{$key}->{chg_speed}\n";
			print "{$key}->{multisession} = $cd_devices{$key}->{multisession}\n";
			print "{$key}->{cdr} = $cd_devices{$key}->{cdr}\n";
			print "{$key}->{cdrw} = $cd_devices{$key}->{cdrw}\n";
			print "{$key}->{dvdr} = $cd_devices{$key}->{dvdr}\n";
			print "{$key}->{dvdram} = $cd_devices{$key}->{dvdram}\n"; 
		}
	}
}

sub save_conf_file {

	write_sitecopyrc() if ($net_proto eq 'webdav');
	write_password_file() if (($net_proto eq 'rsync') && ($passwd_user ne ''));	
	
    my @cfg_list = ( "SYS_FILES=@sys_files\n",
		     "HOME_FILES=@user_list\n", 
		     "OTHER_FILES=@list_other\n",
		     "PATH_TO_SAVE=$save_path\n",
		     "HOST_PATH=$host_path\n",
		     "NET_PROTO=$net_proto\n",
		     "CD_TIME=$cd_time\n",
		     "USER_MAIL=$user_mail\n",		     
		     "DAEMON_TIME_SPACE=$when_space\n",
		     "CD_DEVICE=$cd_device\n",
		     "LOGIN=$login_user\n",
		     "TAPE_DEVICE=$tape_device\n",
		     "HOST_NAME=$host_name\n"
		     );
    $no_critical_sys and push @cfg_list, "NO_CRITICAL_SYS\n" ; 
    $no_critical_sys or push @cfg_list, "CRITICAL_SYS\n" ; 
    $send_mail and push @cfg_list, "SEND_MAIL\n";
    $backup_sys_versions and push @cfg_list, "SYS_INCREMENTAL_BACKUPS\n" ; 
    $backup_user_versions and push @cfg_list, "USER_INCREMENTAL_BACKUPS\n" ; 
    $backup_other_versions  and push @cfg_list, "OTHER_INCREMENTAL_BACKUPS\n" ; 
    $media_erase and push @cfg_list, "MEDIA_ERASE\n" ; 
    $where_net and ($net_proto eq 'ftp') and push @cfg_list, "USE_NET_FTP\n" ; 
#    $where_net_ssh and push @cfg_list, "USE_NET_SSH\n" ; 
    $remember_pass and push @cfg_list, "LOGIN=$login_user\n" ; 
    $remember_pass and push @cfg_list, "PASSWD=$passwd_user\n" ;
    $remember_pass and push @cfg_list, "REMEMBER_PASS\n" ;
    $auth_choice or push @cfg_list, "AUTH_CHOICE=0\n" ;
    if ($auth_choice == 1) { push @cfg_list, "AUTH_CHOICE=1\n" ;}
    if ($auth_choice == 2) { push @cfg_list, "AUTH_CHOICE=2\n" ;}
    $cd_with_install_boot and push @cfg_list, "CD_WITH_INSTALL_BOOT\n" ;
    $ssh_daemon and push @cfg_list, "SSH_DAEMON\n" ;
    $ftp_daemon and push @cfg_list, "FTP_DAEMON\n" ;
    $hd_daemon and push @cfg_list, "HD_DAEMON\n" ;
    $cd_daemon and push @cfg_list, "CD_DAEMON\n" ;
	$tape_daemon and push @cfg_list, "TAPE_DAEMON\n" ;
	$webdav_daemon and push @cfg_list, "WEBDAV_DAEMON\n" ;
	$rsync_daemon and push @cfg_list, "RSYNC_DAEMON\n" ;
    $hd_quota and  push @cfg_list, "HD_QUOTA\n" ;
    $where_hd and  push @cfg_list, "USE_HD\n" ;
    $where_cd and  push @cfg_list, "USE_CD\n" ;
	$where_tape and push @cfg_list, "USE_TAPE\n" ;
    $where_net and  push @cfg_list, "USE_NET\n" ;
    $cdrw and push @cfg_list, "CDRW\n"; 
    $what_no_browser or push @cfg_list, "BROWSER_CACHE\n" ;
    $backup_sys or push @cfg_list,  "NO_SYS_FILES\n";
    if ($comp_mode) {
    	push @cfg_list, "OPTION_COMP=TAR.BZ2\n";
    } else { 
    	push @cfg_list, "OPTION_COMP=TAR.GZ\n";   
    }
    output_p($cfg_file, @cfg_list);
    chmod(0600, "$cfg_file");
    save_cron_files();
}

sub read_cron_files {
    my $daemon_found = 0;
    foreach (qw(hourly daily weekly monthly)) {
		if (-f "/etc/cron.$_/drakbackup") {
	    	$when_space = $_;	    
	    	$daemon_found = 1;
	    	last;
		}
    }
    !$daemon_found and $backup_daemon = 0; 
}

sub save_cron_files {
    my @cron_file = ("#!/bin/sh\n", "export TERM=xterm\n", "/usr/sbin/drakbackup --daemon > /dev/null 2>&1\n" );

    if ($backup_daemon) {
		foreach (qw(hourly daily weekly monthly)) {
	    	-f "/etc/cron.$_/drakbackup" and rm_rf("/etc/cron.$_/drakbackup");
		}
		output_p("/etc/cron.$when_space/drakbackup",  @cron_file );
		system("chmod +x /etc/cron.$when_space/drakbackup");
    } else {
		foreach (qw(hourly daily weekly monthly)) {
	    	-f "/etc/cron.$_/drakbackup" and rm_rf("/etc/cron.$_/drakbackup");
		}
    }
}

sub read_conf_file {
    if (-e $cfg_file) {
        open ( CONF_FILE, "<"."$cfg_file") || print "You must be root to read configuration file. \n" ;
        while (<CONF_FILE>) {
	    	next unless /\S/;
	    	next if /^#/;
	    	chomp;
	    	if (/^SYS_FILES/)		{ s/^SYS_FILES=//gi;    @sys_files = split(' ', $_ );	}
	    	if (/^HOME_FILES/)		{ s/^HOME_FILES=//gi;   @user_list = split(' ', $_ );	}
	    	if (/^OTHER_FILES/)		{ s/^OTHER_FILES=//gi;  @list_other = split(' ', $_ );	}
	    	if (/^PATH_TO_SAVE/)	{ s/^PATH_TO_SAVE=//gi; $save_path = $_;	}
	    	if (/^NO_SYS_FILES/)   { $backup_sys = 0;}
	    	if (/^NO_USER_FILES/)  { $backup_user = 0;}
	    	if (/^OPTION_COMP/)    { s/^OPTION_COMP=//gi; /TAR.GZ/ and  $comp_mode = 0; /TAR.BZ2/ and $comp_mode = 1; }
	    	if (/^BROWSER_CACHE/)  { $what_no_browser = 0; }
	    	if (/^CDRW/)           { $cdrw = 1; }
	    	if (/^NET_PROTO/)      { s/^NET_PROTO=//gi; $net_proto = $_; }
	    	if (/^HOST_PATH/)      { s/^HOST_PATH=//gi; $host_path = $_; } 
	    	if (/^SSH_DAEMON/)	   { $ssh_daemon = 1; $daemon_media = 'ssh'; }
	    	if (/^FTP_DAEMON/)	   { $ftp_daemon = 1; $daemon_media = 'ftp'; }
	    	if (/^HD_DAEMON/)	   { $hd_daemon = 1; }
	    	if (/^CD_DAEMON/)	   { $cd_daemon = 1; $daemon_media = 'cd'; }
			if (/^TAPE_DAEMON/)		{ $tape_daemon = 1; $daemon_media = 'tape'; }
	    	if (/^WEBDAV_DAEMON/)	   { $webdav_daemon = 1; $daemon_media = 'webdav'; }
	    	if (/^RSYNC_DAEMON/)	   { $rsync_daemon = 1; $daemon_media = 'rsync'; }
	    	if (/^HD_QUOTA/)       { $hd_quota = 1;  }
	    	if (/^USE_HD/)         { $where_hd = 1;  }
	    	if (/^USE_CD/)         { $where_cd = 1;  }
	    	if (/^USE_NET/)        { $where_net = 1; }
	    	if (/^USE_TAPE/)       { $where_tape = 1; }
	    	if (/^CD_TIME/)        { s/^CD_TIME=//gi; $cd_time = $_; }
	    	if (/^DAEMON_TIME_SPACE/) { s/^DAEMON_TIME_SPACE=//gi; $when_space = $_; }
	    	if (/^CD_WITH_INSTALL_BOOT/) { $cd_with_install_boot = 1; }
	    	if (/^CD_DEVICE/)    { s/^CD_DEVICE=//gi; $cd_device = $_;}
	    	if (/^HOST_NAME/)      { s/^HOST_NAME=//gi; $host_name = $_;} 
	    	if (/^AUTH_CHOICE/)    { s/^AUTH_CHOICE=//gi; $auth_choice = $_; }
	    	if (/^REMEMBER_PASS/)  { $remember_pass = 1; }
	    	if (/^LOGIN/)          { s/^LOGIN=//gi;  $login_user  = $_; $remember_pass = 1; }
	    	if (/^PASSWD/)         { s/^PASSWD=//gi; $passwd_user = $_; $remember_pass = 1; }
	    	if (/^USER_MAIL/)      { s/^USER_MAIL=//gi; $user_mail= $_; }		     
#	    	if (/^USE_NET_FTP/)    { $where_net_ftp = 1;  }
	    	if (/^SEND_MAIL/)      { $send_mail = 1;  }
#	    	if (/^USE_NET_SSH/)    { $where_net_ssh = 1;  }
	    	if (/^TAPE_DEVICE/)    { s/TAPE_DEVICE=//gi; $tape_device = $_;}
	    	if (/^MEDIA_ERASE/)     { $media_erase = 1;}
	    	if (/^SYS_INCREMENTAL_BACKUPS/)   { $backup_sys_versions = 1;}
	    	if (/^USER_INCREMENTAL_BACKUPS/)  { $backup_user_versions = 1;}
	    	if (/^OTHER_INCREMENTAL_BACKUPS/) { $backup_other_versions = 1;}
	    	if (/^NO_CRITICAL_SYS/)  { $no_critical_sys = 1;}
	    	if (/^CRITICAL_SYS/)  { $no_critical_sys = 0;}
		}
		read_cron_files();
		$cfg_file_exist = 1;
    } else { 
    	$cfg_file_exist = 0; 
    }
    close CONF_FILE;    
}

sub write_sitecopyrc {
	#- FIXME - how to deal with existing sitecopyrc - also /root hardcoded!!
    my @cfg_list = ( "site drakbackup\n",
		     "\tserver $host_name\n",
		     "\tremote $host_path\n",
		     "\tlocal $save_path\n",
		     "\tusername $login_user\n",
		     "\tpassword $passwd_user\n",
		     "\tprotocol webdav\n"
			);
    output_p("/root/.sitecopyrc", @cfg_list);
    chmod(0600, "/root/.sitecopyrc");
    -d "/root/.sitecopy" or mkdir_p("/root/.sitecopy");
    chmod(0700, "/root/.sitecopy");
}

sub write_password_file {
	output_p("$cfg_dir/rsync.user", "$passwd_user\n");
	chmod(0600, "$cfg_dir/rsync_user");
}
	
sub complete_results {
    system_state();
    $results .=  "***********************************************************************\n\n";
    $daemon or $results .=  _("\n                      DrakBackup Report \n\n");
    $daemon and $results .= _("\n                      DrakBackup Daemon Report\n\n\n");
    $results .=  "***********************************************************************\n\n";
    $results .= $system_state;
    $results .=  "\n\n***********************************************************************\n\n";
    $results .=             _("\n                    DrakBackup Report Details\n\n\n");
    $results .=  "***********************************************************************\n\n";
}


sub ftp_client {
    use Net::FTP; 
    my $ftp;

    $DEBUG and print "file list to send : $_\n "  foreach @file_list_to_send_by_ftp;
    if ($DEBUG && $interactive) { $ftp = Net::FTP->new("$host_name", Debug => 1) or return(1);  }
    elsif ($interactive)  {  $ftp = Net::FTP->new("$host_name", Debug => 0) or return(1); }
    else {  $ftp = Net::FTP->new("$host_name", Debug => 0) or return(1); }
    $ftp->login("$login_user","$passwd_user");
    $ftp->cwd("$host_path"); 
    foreach (@file_list_to_send_by_ftp) {
		$interactive and $pbar->set_value(0);
		$interactive and progress($pbar, 0.5, $_);
		$interactive and $pbar->set_show_text( $_ );
		$ftp->put("$_");
		$interactive and progress($pbar, 0.5, $_);
		$interactive and $pbar->set_show_text( $_ );
		$interactive and progress($pbar3, 1/@file_list_to_send_by_ftp, _("total progess"));
    }
    $ftp->quit; 
    return(0);
}

sub ssh_client {
#    system("scp @file_list_to_send_by_ftp root\@petra:.");
    $DEBUG and print "file list to send : $_\n "  foreach @file_list_to_send_by_ftp;
    foreach (@file_list_to_send_by_ftp) {
		$interactive and $pbar->set_value(0);
		$interactive and progress($pbar, 0.5, $_);
		$interactive and $pbar->set_show_text( $_ );
		system("scp $_ $login_user\@$host_name");
		$interactive and progress($pbar, 0.5, $_);
		$interactive and $pbar->set_show_text( $_ );
		$interactive and progress($pbar3, 1/@file_list_to_send_by_ftp, _("total progess"));
    }
    return(0);
}

sub webdav_client {
    $DEBUG and print "file list to send : $_\n "  foreach @file_list_to_send_by_ftp;
	system("sitecopy -u drakbackup > $log_file");
	return(0);
}

sub rsync_client {
    $DEBUG and print "file list to send : $_\n "  foreach @file_list_to_send_by_ftp;
	my $rsync_cmd = "rsync -tv $save_path/* ";
	$rsync_cmd = $rsync_cmd . "--password-file=$cfg_dir/rsync.user " if ($passwd_user ne '');
	$rsync_cmd = $rsync_cmd . "$login_user\@" if ($login_user ne '');
	$rsync_cmd = $rsync_cmd . "$host_name\:\:$host_path";
	system("$rsync_cmd > $log_file");
	return(0);
}

sub write_on_cd {
print "burning cd...\n";
	if ($media_erase) {
		system("cdrecord -v dev=$cd_device blank=fast -data $save_path/drakbackup.iso >> $log_file 2>&1"); 
	} else {
		system("cdrecord -v dev=$cd_device -data $save_path/drakbackup.iso >> $log_file 2>&1"); 
	}
	unlink("$save_path/drakbackup.iso");
}

sub build_iso {
    system("mkisofs -r -J -T -v -V 'Drakbackup' -o $save_path/drakbackup.iso $save_path > $log_file 2>&1");
}

sub build_cd {
    build_iso();
	write_on_cd();
}

sub build_tape {
	unlink("$log_file");
	#- do we have a tape?
	
	#- try to roll to the end of the data if we're not erasing
	system("mt -f $tape_device eod >> $log_file 2>&1") if (!$media_erase);
	
	#- do the backup
	system("tar -cvf $tape_device $save_path >> $log_file 2>&1");
	
	#- eject the tape?
	system("mt -f $tape_device rewoff >> $log_file 2>&1");
}
	
sub send_mail {
    my ($result) = @_;
    my $datem = `date`;

    open F, "|/usr/sbin/sendmail -f$user_mail $user_mail" or return(1);
    print F "From: drakbackup\n";
    print F "To: $user_mail \n";
    print F "Subject: DrakBackup report on $datem \n";
    print F "\n";
    print F "$result\n";
    close F or  return(1);
    return(0);
}

sub build_backup_files {
    my $path_name;
    my $tar_cmd;
    my $more_recent;
    my $tar_cmd_sys;
    my $tar_cmd_user;
    my $tar_cmd_other;
    my $tar_ext;
    my $vartemp;
    my $base_sys_exist = 0;
    my $base_user_exist = 0;
    my $base_other_exist = 0;
    my @list_temp = ();
    my @list_other_;
    my @dir_content = ();
    my $file_date;
    $results = "";
	$interactive and cursor_wait();
    read_conf_file();
    the_time();    
    $send_mail and complete_results();
    -d  $save_path or mkdir_p($save_path);
    if ($comp_mode) { 
		$DEBUG and $tar_cmd = "tar cv --use-compress-program /usr/bin/bzip2 ";
		$DEBUG or $tar_cmd = "tar c --use-compress-program /usr/bin/bzip2 "; 
		$tar_ext = "tar.bz2" ;
    } else { 
		$DEBUG and $tar_cmd = "tar cvpz "; 
		$DEBUG or $tar_cmd = "tar cpz "; 
		$tar_ext = "tar.gz"
	}
    $tar_cmd_sys = $tar_cmd;
    $tar_cmd_user = $tar_cmd;
    $tar_cmd_other = $tar_cmd;
    $no_critical_sys and $tar_cmd_sys .= "--exclude passwd --exclude fstab --exclude group --exclude mtab";
    $what_no_browser and $tar_cmd_user .= "--exclude NewCache --exclude Cache --exclude cache";

    -d $save_path and @dir_content = all($save_path);
    grep (/^backup\_base\_sys/, @dir_content) and $base_sys_exist = 1;

    if (($where_hd && !$daemon) || ($daemon && $hd_daemon)) {
	  $interactive and progress($pbar, 0.5, _("Backup system files..."));
	  if ($backup_sys) { 
	    if ($backup_sys_versions) {
 		if (grep /^backup\_incr\_sys/, @dir_content) { 
		    my @more_recent = grep /^backup\_incr\_sys/, sort @dir_content; 
		    $more_recent = pop @more_recent;
		    $DEBUG and print "more recent file: $more_recent\n";
 		   system("find @sys_files -cnewer $save_path/$more_recent \! -type d -print > $save_path/list_incr_sys$the_time.txt");
		    if (!cat_("$save_path/list_incr_sys$the_time.txt")) {
				system("rm $save_path/list_incr_sys$the_time.txt");
		    } else {
				system("$tar_cmd_sys -f $save_path/backup_incr_sys$the_time.$tar_ext -T $save_path/list_incr_sys$the_time.txt");
				push @file_list_to_send_by_ftp, "$save_path/backup_incr_sys$the_time.$tar_ext";
				push @file_list_to_send_by_ftp, "$save_path/list_incr_sys$the_time.txt";
				$results .= "\nfile: $save_path/backup_incr_sys$the_time.$tar_ext\n";
				$results .= cat_("$save_path/list_incr_sys$the_time.txt");
		    }
		} elsif (grep /^backup\_base\_sys/,  @dir_content) { 
		    my @more_recent = grep /^backup\_base\_sys/, sort @dir_content; 
		    $more_recent = pop @more_recent;
		    $DEBUG and print "more recent file: $more_recent\n";
  		  	system("find @sys_files -cnewer $save_path/$more_recent \! -type d -print > $save_path/list_incr_sys$the_time.txt");
		    if (!cat_("$save_path/list_incr_sys$the_time.txt")) {
				system("rm $save_path/list_incr_sys$the_time.txt");
		    } else {
				system("$tar_cmd_sys -f $save_path/backup_incr_sys$the_time.$tar_ext -T $save_path/list_incr_sys$the_time.txt");
				push @file_list_to_send_by_ftp, "$save_path/backup_incr_sys$the_time.$tar_ext";
				push @file_list_to_send_by_ftp, "$save_path/list_incr_sys$the_time.txt";
				$results .= "\nfile: $save_path/backup_incr_sys$the_time.$tar_ext\n";
				$results .= cat_("$save_path/list_incr_sys$the_time.txt");
		    }
		} else { 
			system("$tar_cmd_sys -f $save_path/backup_base_sys$the_time.$tar_ext @sys_files"); 
			push @file_list_to_send_by_ftp, "$save_path/backup_base_sys$the_time.$tar_ext";
			$results .= "\nfile: $save_path/backup_base_sys$the_time.$tar_ext\n";
		}
	  } else {
		#  system("cd $save_path && rm -f backup_sys* backup_base_sys* backup_incr_sys*");
		system("$tar_cmd_sys -f $save_path/backup_sys$the_time.$tar_ext @sys_files");
		push @file_list_to_send_by_ftp, "$save_path/backup_sys$the_time.$tar_ext";
		$results .= "\nfile: $save_path/backup_sys$the_time.$tar_ext\n";
	  }
	}
	
	$interactive and progress($pbar, 0.5, _("Backup system files..."));
	$interactive and progress($pbar3, 0.3, _("Hard Disk Backup files..."));

	if (@list_other) {
		system("cd $save_path && rm -f backup_other* ");
		system("$tar_cmd_other -f $save_path/backup_other$the_time.$tar_ext @list_other");
		push @file_list_to_send_by_ftp, "$save_path/backup_other$the_time.$tar_ext";
		$results .= "\nfile: $save_path/backup_other$the_time.$tar_ext\n";
		#old	    foreach (@list_other) { push @list_other_, $_ . "\n"; }
	    @list_other_ = map { "$_\n" } @list_other;
	    output_p( $save_path . '/list_other', @list_other_);    
	}
	
	$interactive and progress($pbar1, 1, _("Backup User files..."));
	$interactive and progress($pbar3, 0.3, _("Hard Disk Backup Progress..."));
	
	if ($backup_user) {
	    foreach (@user_list) {
		my $user = $_;
		$path_name = return_path($user);
		if ($backup_user_versions) {
		    if (grep(/^backup\_incr\_user\_$user\_/, @dir_content)) { 
				my @more_recent = grep /^backup\_incr\_user\_$user\_/, sort @dir_content; 
				$more_recent = pop @more_recent;
				$DEBUG and print "more recent file: $more_recent\n";
				system("find $path_name -cnewer $save_path/$more_recent \! -type d -print > $save_path/list_incr_user_$user$the_time.txt");
				if (!cat_("$save_path/list_incr_user_$user$the_time.txt")) {
			    	system("rm $save_path/list_incr_user_$user$the_time.txt");
				} else {
					system("$tar_cmd_user -f $save_path/backup_incr_user_$user$the_time.$tar_ext -T $save_path/list_incr_user_$user$the_time.txt");
					push @file_list_to_send_by_ftp, "$save_path/backup_incr_user_$user$the_time.$tar_ext";
					push @file_list_to_send_by_ftp, "$save_path/list_incr_user_$user$the_time.txt";
					$results .= " \nfile: $save_path/backup_incr_user_$user$the_time.$tar_ext\n";
					$results .= cat_("$save_path/list_incr_user_$user$the_time.txt");
				}
		    } elsif (grep /^backup\_base\_user\_$user\_/, @dir_content) { 
				my @more_recent = grep /^backup\_base\_user\_$user\_/, sort @dir_content; 
				$more_recent = pop @more_recent;			
				$DEBUG and print "more recent file: $more_recent\n";
				system("find $path_name -cnewer $save_path/$more_recent \! -type d -print > $save_path/list_incr_user_$user$the_time.txt");
				if (!cat_("$save_path/list_incr_user_$user$the_time.txt")) {
			    	system("rm $save_path/list_incr_user_$user$the_time.txt");
				} else {
					system("$tar_cmd_user -f $save_path/backup_incr_user_$user$the_time.$tar_ext -T $save_path/list_incr_user_$user$the_time.txt");
					push @file_list_to_send_by_ftp, "$save_path/backup_incr_user_$user$the_time.$tar_ext";
					push @file_list_to_send_by_ftp, "$save_path/list_incr_user_$user$the_time.txt";
					$results .= "\nfile: $save_path/backup_incr_user_$user$the_time.$tar_ext\n";
					$results .= cat_("$save_path/list_incr_user_$user$the_time.txt");
				}
		    } else {
				system("$tar_cmd_user -f $save_path/backup_base_user_$user$the_time.$tar_ext $path_name");
				push @file_list_to_send_by_ftp, "$save_path/backup_base_user_$user$the_time.$tar_ext";
				$results .= "\nfile: $save_path/backup_base_user_$user$the_time.$tar_ext\n";
		    }
		} else {
		    system("cd $save_path && rm -f backup_user_$_* backup_base_user_$_* backup_incr_user_$_*");
		    system("$tar_cmd_user -f $save_path/backup_user_$_$the_time.$tar_ext $path_name");
		    push @file_list_to_send_by_ftp, "$save_path/backup_user_$_$the_time.$tar_ext";
		    $results .= "\nfile: $save_path/backup_user_$user$the_time.$tar_ext\n";
		}
	  }
	}
	$interactive and progress($pbar2, 1, _("Backup Other files..."));
	$interactive and progress($pbar3, 0.4, _("Hard Disk Backup files..."));
    }

	#- rework to use $net_proto and then call the appropriate client app
	#- still think this needs to be cleaned up more
	#- should hit this block if running daemon mode only
	if ($daemon && ($daemon_media ne '')) {
#		ftp_client() if $ftp_daemon;
		rsync_client() if $rsync_daemon;
		ssh_client() if $ssh_daemon;
		webdav_client() if $webdav_daemon;
		build_cd() if $cd_daemon;
		build_tape() if $tape_daemon;
		$results .= _("\nDrakbackup activities via $daemon_media:\n\n");
		$results .= cat_("$log_file");			
#-maybe keep this???
#-		unlink("$log_file");
	}
	
	#- leave this one alone for now - works well
	#- integrate with other methods later
    if (($where_net && !$daemon && ($net_proto eq 'ftp')) || ($daemon && $ftp_daemon)) {
		$results .= _("file list sent by FTP : %s\n ", $_)  foreach @file_list_to_send_by_ftp;
		$interactive and build_backup_ftp_status();
		if (ftp_client()) { 
	    	$results .= _("\n FTP connection problem: It was not possible to send your backup files by FTP.\n");
	    	$interactive and client_ftp_pb();
		} 
    }
	
	#- consolidate all the other methods under here - interactive and --default should land here
	if (!$daemon) {
	
		if ($where_net && ($net_proto ne '')) {
			rsync_client() if ($net_proto eq 'rsync');
			ssh_client() if ($net_proto eq 'ssh');
			webdav_client() if ($net_proto eq 'webdav');
			$results .= _("\nDrakbackup activities via $net_proto:\n\n");
		}
		
		if ($where_cd) {
			build_cd();
			$results .= _("\nDrakbackup activities via CD:\n\n");
		}
	
		if ($where_tape) {
			build_tape();
			$results .= _("\nDrakbackup activities via tape:\n\n");
		}
		$results .= cat_("$log_file");
	
	}
	
    if ($send_mail) { 
		if (send_mail("$results")) { 
	    	$interactive and send_mail_pb();
	    	$interactive or print _(" Error during mail sending. \n");
		} 
    }
	$interactive and cursor_norm();
	$interactive and show_status();
}

my @list_of_rpm_to_install;
sub require_rpm {
    my $all_rpms_found = 1;
    my $res;
    my @file_cache =  cat_("/var/log/rpmpkgs");
    @list_of_rpm_to_install = ();
#- reverted to old method - /var/log/rpmpkgs is not always accurate
#    my($pkg) = @_;
    foreach my $pkg (@_) {
#	   $res = grep /$pkg/, @file_cache;
		$res = system("rpm -qa | grep $pkg > /dev/null");
		if ($res == 256) { 
			$all_rpms_found = 0; 
			push @list_of_rpm_to_install, $pkg;
		}
    }
    return($all_rpms_found);
}

sub check_pkg_needs {
	my $extra_pkg = '';
	if ($where_net) {
		$extra_pkg = 'rsync' if ($net_proto eq 'rsync');
		$extra_pkg = 'sitecopy' if ($net_proto eq 'webdav');
	}
	$extra_pkg = 'mt-st' if ($where_tape);
	if ($extra_pkg ne '') {
		if(require_rpm($extra_pkg)) {
			return(0);
		} else {
			#- this isn't entirely good, but it's the only way we get here currently
			#- was getting strange return behavior before
			#- still a problem, we can also get here from the cron screen
			install_rpm(\&advanced_where);
			return(1);
		}		
	}	
}

sub cursor_wait {
	# turn the cursor to a watch
	$window1->window->set_cursor( new Gtk::Gdk::Cursor( 150 ) );    
	Gtk->main_iteration while Gtk->events_pending;
}

sub cursor_norm {
	# restore normal cursor
	$window1->window->set_cursor( new Gtk::Gdk::Cursor( 68 ) );
	Gtk->main_iteration while Gtk->events_pending;
}

sub show_status {
	#- just a generic routine to display an array of text in the GUI screen
	my @buff = cat_("$log_file");
	
	my $text = new Gtk::Text(undef, undef);
	
    $box2->destroy();
    
    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::VBox(0,10),
			1, gtkpack_(new Gtk::HBox(0,0),
        		1, gtktext_insert(gtkset_editable($text, 0), "@buff"),
			),
		),
	);
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub list_remove {
    my($widget, $list) = @_;
    my @to_remove;
    push @to_remove, $list->child_position($_) foreach($list->selection);
    splice @list_other, $_, 1 foreach(reverse sort @to_remove);
    $list->remove_items($list->selection);
}

sub file_ok_sel { 
    my ( $widget, $file_selection ) = @_;     
    my $file_name = $file_selection->get_filename();
    if(!member($file_name, @list_other)) {
	push(@list_other, $file_name);
	$list_other->add(gtkshow(new Gtk::ListItem($file_name)));
    }
}

sub filedialog_where_hd {
    my $file_dialog;

    $file_dialog = gtksignal_connect(new Gtk::FileSelection(_("File Selection")), destroy => sub { $file_dialog->destroy(); } );
    $file_dialog->ok_button->signal_connect(clicked => sub { 
	$save_path_entry->set_text($file_dialog->get_filename()); 
	$file_dialog->destroy() });
    $file_dialog->cancel_button->signal_connect(clicked => sub { $file_dialog->destroy() });
    $file_dialog->show();
}

sub filedialog_restore_find_path {
    my $file_dialog;

    $file_dialog = gtksignal_connect(new Gtk::FileSelection(_("File Selection")), destroy => sub { $file_dialog->destroy(); } );
    $file_dialog->ok_button->signal_connect(clicked => sub { 
	$restore_find_path_entry->set_text($file_dialog->get_filename()); 
	$file_dialog->destroy() });
    $file_dialog->cancel_button->signal_connect(clicked => sub { $file_dialog->destroy() });
    $file_dialog->show();
}

sub filedialog {
    my $file_dialog;

    $file_dialog = gtksignal_connect(new Gtk::FileSelection(_("File Selection")), destroy => sub { $file_dialog->destroy(); } );
    $file_dialog->ok_button->signal_connect(clicked => \&file_ok_sel, $file_dialog);
    $file_dialog->ok_button->child->set(_("Add"));
    $file_dialog->cancel_button->signal_connect(clicked => sub { $file_dialog->destroy() });
    $file_dialog->cancel_button->child->set(_("Close"));
    $file_dialog->set_filename(_("Select the files or directories and click on 'Add'"));
    $file_dialog->show();
}

################################################  ADVANCED  ################################################  

sub check_list {
    foreach (@_) {
	my $ref = $_->[1];
	gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => sub { invbool $ref })
	}
}

sub fonction_env {
    ($central_widget, $current_widget, $previous_widget, $custom_help, $next_widget) = @_;
	if ($DEBUG) {
		print "central_widget = $central_widget\ncurrent_widget = $current_widget\n";
		print "previous_widget = $previous_widget\ncustom_help = $custom_help\n";
		print "next_widget = $next_widget\n"; 
	}
}

# sub redraw_during_check {
#     my ($tmp1, $tmp2) = @_;
#     gtksignal_connect(gtkset_active($tmp1, $tmp2), toggled => sub { 
# #	invbool \$tmp2;
# 	print "tmp2 bef = $tmp2\n";
# 	$tmp2 = $tmp2 ? 0 : 1;
# 	${$central_widget}->destroy();
# 	print "tmp2 after = $tmp2\n";
# 	$current_widget->();
# 	return ($tmp2);
#     });
# }

sub advanced_what_sys {
    my $box_what_sys;
    
    gtkpack($advanced_box,
	    $box_what_sys =  gtkpack_(new Gtk::VBox(0, 15),
		     1, _("\nPlease check all options that you need.\n"),
		     1, _("These options can backup and restore all files in your /etc directory.\n"),
		     0, my $check_what_sys = new Gtk::CheckButton( _("Backup your System files. ( /etc directory )")),
		     0, my $check_what_versions = new Gtk::CheckButton( _("Use incremental backup  (do not replace old backups)") ),
		     0, my $check_what_critical = new Gtk::CheckButton( _("Do not include critical files (passwd, group, fstab)") ),
		     0, _("With this option you will be able to restore any version\n of your /etc directory."),
		     1, new Gtk::VBox(0, 15),
		     ),
	    );
    check_list([$check_what_sys, \$backup_sys], [$check_what_critical, \$no_critical_sys], [$check_what_versions, \$backup_sys_versions]);
    fonction_env(\$box_what_sys, \&advanced_what_sys, \&advanced_what, "what");
    $up_box->show_all();
}

sub advanced_what_user {
    my ($previous_function) = @_,
    my $box_what_user;
    my %check_what_user;
    
    all_user_list();
    gtkpack($advanced_box,
	    $box_what_user = gtkpack_(new Gtk::VBox(0, 15),
				      0, _("Please check all users that you want to include in your backup."),
				      0, new Gtk::HSeparator,
				      1, createScrolledWindow( 
						gtkpack__(new Gtk::VBox(0,0),
							map { my $name = $_;
							      my @user_list_tmp;
							      my $b = new Gtk::CheckButton($name); 
							      if (grep /^$name$/, @user_list) {
								  $check_what_user{$_}[1] = 1;
								  gtkset_active($b, 1);
							      } else {
								  $check_what_user{$_}[1] = 0;
								  gtkset_active($b, 0);
							      }
							      $b->signal_connect(toggled => sub { 
								  if ($check_what_user{$name}[1] ) {
								      $check_what_user{$name}[1] = 0;
								      @user_list_tmp = grep(!/^$name$/, @user_list);
								      @user_list = @user_list_tmp;
								  } else { 
								      $check_what_user{$name}[1] = 1;
								      if (!member($name, @user_list) ) {push @user_list, $name;}
								  }
							      });
							      $b } (@all_user_list) 
							),
							       ),
				      0, my $check_what_browser = new Gtk::CheckButton( _("Do not include the browser cache") ),
	    0, my $check_what_user_versions = new Gtk::CheckButton( _("Use Incremental Backups  (do not replace old backups)") ),
				      ),
	    );
    check_list([$check_what_browser, \$what_no_browser], [$check_what_user_versions, \$backup_user_versions]);
    if ($previous_function) { fonction_env(\$box_what_user, \&advanced_what_user, \&$previous_function, "what", \&$previous_function);}
    else { fonction_env(\$box_what_user, \&advanced_what_user, \&advanced_what, "what");}
    $up_box->show_all();
}

sub advanced_what_other {
    my $box_what_other;
    $list_other = new Gtk::List();
    $list_other->set_selection_mode(-extended);
    $list_other->add(gtkshow(new Gtk::ListItem($_))) foreach (@list_other);
    
    gtkpack($advanced_box,
	    $box_what_other = gtkpack_(new Gtk::VBox(0, 15),
		     1, gtkpack_(new Gtk::HBox(0,4),
				 1, createScrolledWindow($list_other),
				 ),
		     0, gtkadd(gtkset_layout(new Gtk::HButtonBox, -spread),
			       gtksignal_connect(new Gtk::Button(_("Add")), clicked => sub {filedialog()  }),
			       gtksignal_connect(new Gtk::Button(_("Remove Selected")), clicked => \&list_remove, $list_other),
			       ),
		     0, gtkset_sensitive(my $check_what_other_versions = new Gtk::CheckButton( _("Use Incremental Backups  (do not replace old backups)") ), 0),
		     ),
	    );
    check_list([$check_what_other_versions, \$backup_other_versions]);
    fonction_env(\$box_what_other, \&advanced_what_other, \&advanced_what, "what");
    $up_box->show_all();
}

sub advanced_what_entire_sys{
    my $box_what;
    
    my ($pix_user_map, $pix_user_mask) = gtkcreate_png("user");
    my ($pix_other_map, $pix_other_mask) = gtkcreate_png("net_u");
    my ($pix_sys_map, $pix_sys_mask) = gtkcreate_png("bootloader");

    gtkpack($advanced_box,
	    $box_what = gtkpack_(new Gtk::HBox(0, 15),
		     1, new Gtk::VBox(0, 5),
		     1, gtkpack_(new Gtk::VBox(0, 15),	
				 1, new Gtk::VBox(0, 5),
				 1, gtksignal_connect(my $button_what_other = new Gtk::Button(), 
						      clicked => sub { ${$central_widget}->destroy(); message_underdevel(); }),
				 1, gtksignal_connect(my $button_what_all = new Gtk::Button(), 
						      clicked => sub { ${$central_widget}->destroy(); message_underdevel(); }),
				 1, new Gtk::VBox(0, 5),
				 ),
		     1, new Gtk::VBox(0, 5),	
		     ),
	    );
    $button_what_other->add(gtkpack(new Gtk::HBox(0,10),
				    new Gtk::Pixmap($pix_sys_map, $pix_sys_mask),
				    new Gtk::Label(_("Linux")),
				    new Gtk::HBox(0, 5)
				    ));
    $button_what_all->add(gtkpack(new Gtk::HBox(0,10),
				  new Gtk::Pixmap($pix_user_map, $pix_user_mask),
				   new Gtk::Label(_("Windows (FAT32)")),
				  new Gtk::HBox(0, 5)
				  ));
    fonction_env(\$box_what, \&advanced_what_entire_sys, \&advanced_what, "");
    $up_box->show_all();
}

sub advanced_what{
    my $box_what;    
    my ($pix_user_map, $pix_user_mask) = gtkcreate_png("ic82-users-40");
    my ($pix_other_map, $pix_other_mask) = gtkcreate_png("ic82-others-40");
    my ($pix_sys_map, $pix_sys_mask) = gtkcreate_png("ic82-system-40");
    my ($pix_sysp_map, $pix_sysp_mask) = gtkcreate_png("ic82-systemeplus-40");

    gtkpack($advanced_box,
	    $box_what =  gtkpack_(new Gtk::HBox(0, 15),
		     1, new Gtk::VBox(0, 5),
		     1, gtkpack_(new Gtk::VBox(0, 15),	
				 1, new Gtk::VBox(0, 5),
				 1, gtksignal_connect(my $button_what_sys = new Gtk::Button(), 
						      clicked => sub { $box_what->destroy(); advanced_what_sys(); }),
				 1, gtksignal_connect(my $button_what_user = new Gtk::Button(), 
						      clicked => sub { ${$central_widget}->destroy(); advanced_what_user();}),
				 1, gtksignal_connect(my $button_what_other = new Gtk::Button(), 
						      clicked => sub { ${$central_widget}->destroy(); advanced_what_other(); }),
#				 1, gtksignal_connect(my $button_what_all = new Gtk::Button(), 
#						  clicked => sub { ${$central_widget}->destroy(); advanced_what_entire_sys(); }),
				 1, new Gtk::VBox(0, 5),
				 ),
		     1, new Gtk::VBox(0, 5),	
				 ),
	    );
    $button_what_sys->add(  gtkpack(new Gtk::HBox(0,10),
				    new Gtk::Pixmap($pix_sys_map, $pix_sys_mask),
				    new Gtk::Label(_("System")),
				    new Gtk::HBox(0, 5)
				    ));
    $button_what_user->add( gtkpack(new Gtk::HBox(0,10),
				    new Gtk::Pixmap($pix_user_map, $pix_user_mask),
				    new Gtk::Label(_("Users")),
				    new Gtk::HBox(0, 5)
				    ));
    $button_what_other->add(gtkpack(new Gtk::HBox(0,10),
				    new Gtk::Pixmap($pix_other_map, $pix_other_mask),
				    new Gtk::Label(_("Other")),
				    new Gtk::HBox(0, 5)
				    ));
#     $button_what_all->add(gtkpack(new Gtk::HBox(0,10),
# 				    new Gtk::Pixmap($pix_sysp_map, $pix_sysp_mask),
# 				    new Gtk::Label(_("An Entire System")),
# 				    new Gtk::HBox(0, 5)
# 				    ));

    fonction_env(\$box_what, \&advanced_what, \&advanced_box, "");
    $up_box->show_all();
}

sub advanced_where_net_types {
    my ($previous_function) = @_,
    my $box_where_net;
    my $entry_net_type = new Gtk::Combo();
    $entry_net_type->set_popdown_strings(@net_methods);
#    $entry_net_type->set_value_in_list(1, 0);   
	$entry_net_type->entry->set_text("$net_proto");
	        
    gtkpack($advanced_box,
	    $box_where_net = gtkpack_(new Gtk::VBox(0, 15),
	 0, new Gtk::HSeparator,
	 0, gtkpack_(new Gtk::HBox(0,10),
	 	0, my $check_where_use_net = new Gtk::CheckButton( _("Use network connection to backup") ),
		1, new Gtk::HBox(0,10),
	 	0, new Gtk::Label("Net Method:"),
	 	0, gtkset_sensitive($entry_net_type, $where_net),
	 ),	 
	 0, new Gtk::HSeparator,
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please enter the host name or IP.")), $where_net),
		     1, new Gtk::HBox(0,10),
		     0, gtkset_sensitive(my $host_name_entry = new Gtk::Entry(), $where_net),
		     ),
	 0, gtkpack_(new Gtk::HBox(0,10),
	 0, gtkset_sensitive(new Gtk::Label(_("Please enter the directory (or module) to\n put the backup on this host.")), $where_net),
		     1, new Gtk::HBox(0,10),
		     0, gtkset_sensitive(my $host_path_entry = new Gtk::Entry(), $where_net), 
		     ),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please enter your login")), $where_net),
		     1, new Gtk::HBox(0,10),
		     0, gtkset_sensitive(my $login_user_entry = new Gtk::Entry(), $where_net),
		     ),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please enter your password")),  $where_net),
		     1, new Gtk::HBox(0,10),
		     0, gtkset_sensitive(my $passwd_user_entry = new Gtk::Entry(), $where_net),
		     ),
	 0, gtkpack_(new Gtk::HBox(0,10),
	   1, new Gtk::HBox(0,10),
	   0, gtkset_sensitive(my $check_remember_pass = new Gtk::CheckButton( _("Remember this password")), $where_net),
		     ),
	 ),
	    );
    $passwd_user_entry->set_visibility(0);
    $passwd_user_entry->set_text( $passwd_user );
    $passwd_user_entry->signal_connect( 'changed', sub { $passwd_user = $passwd_user_entry->get_text()});
    $host_path_entry->set_text( $host_path );
    $host_name_entry->set_text( $host_name );
    $login_user_entry->set_text( $login_user );
    $host_name_entry->signal_connect( 'changed', sub { $host_name = $host_name_entry->get_text()});
    $host_path_entry->signal_connect( 'changed', sub { $host_path = $host_path_entry->get_text()});
    $login_user_entry->signal_connect( 'changed', sub { $login_user = $login_user_entry->get_text()});
    $entry_net_type->entry->signal_connect( 'changed', sub { $net_proto = $entry_net_type->entry->get_text()});
    check_list ([$check_remember_pass, \$remember_pass]);
    gtksignal_connect(gtkset_active($check_where_use_net, $where_net), toggled => sub { 
		invbool \$where_net;
 		#- assure other methods disabled
		if ($where_net = 1) {
			$where_cd = 0;
			$where_tape = 0;
		}
		${$central_widget}->destroy();
 		$current_widget->();
    });
    if ($previous_function) { 
		fonction_env (\$box_where_net, \&advanced_where_net_types, \&$previous_function, "net" );
    } else { 
		fonction_env (\$box_where_net, \&advanced_where_net_types, \&advanced_where, "net" );
	}
    $up_box->show_all();
}

#- 7/4/2002 SB - obsolete - see advanced where net types
sub advanced_where_net_ssh {
    my ($previous_function) = @_,
    my $box_where_ssh;
    
    gtkpack($advanced_box,
	    $box_where_ssh =  gtkpack_(new Gtk::VBox(0, 15),
	     1, gtkpack(new Gtk::HBox(0, 15),	
			 new Gtk::VBox(0, 15),
			 gtkpack_(new Gtk::VBox(0, 15),	
				     1, new Gtk::VBox(0, 5),
				     1, gtksignal_connect(new Gtk::Button("rsync"),  clicked => sub {
					 ${$central_widget}->destroy(); message_underdevel(); }),
				     1, gtksignal_connect(new Gtk::Button("WebDav"), clicked => sub { 
					 ${$central_widget}->destroy(); message_underdevel(); }),
				     1, gtksignal_connect(new Gtk::Button("scp"),   clicked => sub { 
					 ${$central_widget}->destroy(); message_underdevel(); }),
				     1, new Gtk::VBox(0, 5),
				     ),
			 new Gtk::VBox(0, 15),
			 ),
				       ),
	    );
# test si x11
#print system("xterm -fn 7x14 -bg black -fg white -e ssh-keygen -f ~/.ssh/identity-backup && scp") . "\n";

    if ($previous_function) { 
		fonction_env (\$box_where_ssh, \&advanced_where_net_ssh, \&$previous_function, "ssh" );
	} else { 
		fonction_env (\$box_where_ssh, \&advanced_where_net_ssh, \&advanced_where, "ssh" );
	}
    $up_box->show_all();
}

sub advanced_where_cd {
    my ($previous_function) = @_,
    my $box_where_cd;
    my $combo_where_cd_time = new Gtk::Combo();
    $combo_where_cd_time->set_popdown_strings ("650","700", "750", "800");    
 
    gtkpack($advanced_box,
		$box_where_cd = gtkpack_(new Gtk::VBox(0, 6),
			0, my $check_where_cd = new Gtk::CheckButton( _("Use CD/DVDROM to backup")),
			0, new Gtk::HSeparator,
			0, gtkpack_(new Gtk::HBox(0,10),
			0, gtkset_sensitive(new Gtk::Label(_("Please choose your CD space")), $where_cd),
				1, new Gtk::VBox(0, 5),
				0, gtkset_sensitive(gtkset_usize($combo_where_cd_time, 200, 20), $where_cd),
			),
			0, new Gtk::VBox(0, 5),
			0, gtkpack_(new Gtk::HBox(0,10),
				0, gtkset_sensitive(new Gtk::Label(_("Please check if you are using CDRW media")), $where_cd),
				1, new Gtk::VBox(0, 5),
				0, gtkset_sensitive(my $check_cdrw = new Gtk::CheckButton(), $where_cd),
			),
	 		0, new Gtk::VBox(0, 5),
	 		0, gtkpack_(new Gtk::HBox(0,10),
	 			0, gtkset_sensitive(new Gtk::Label(_("Please check if you want to erase your CDRW before")), $cdrw && $where_cd),
	    		1, new Gtk::VBox(0, 5),
	    		0, gtkset_sensitive(my $check_cdrw_erase = new Gtk::CheckButton(), $cdrw && $where_cd),
			),
# don't know what this is about - hold off for now (SB)
			0, new Gtk::VBox(0, 5),
			0, gtkpack_(new Gtk::HBox(0,10),
				0, gtkset_sensitive(new Gtk::Label(_("Please check if you want to include\n install boot on your CD.")),  $where_cd),
				1, new Gtk::VBox(0, 5),
				0, gtkset_sensitive(my $check_cd_with_install_boot = new Gtk::CheckButton(), $where_cd),
			),
			0, new Gtk::VBox(0, 5),
			0, gtkpack_(new Gtk::HBox(0,10),
				0, gtkset_sensitive(new Gtk::Label(_("Please enter your CD Writer device name\n ex: 0,1,0")),  $where_cd),
				1, new Gtk::VBox(0, 5),
				0, gtkset_usize(gtkset_sensitive($cd_device_entry = new Gtk::Entry(), $where_cd), 200, 20),
			),
		),
	);

    foreach ([$check_cdrw_erase, \$media_erase], [$check_cd_with_install_boot, \$cd_with_install_boot ]) {
		my $ref = $_->[1];
		gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => sub { ${$ref} = ${$ref} ? 0 : 1; })
	}
    gtksignal_connect(gtkset_active($check_where_cd, $where_cd), toggled => sub { 
		$where_cd = $where_cd ? 0 : 1;
		#- toggle where_net, where_tape off
		if ($where_cd = 1) {
			$where_net = 0;
			$where_tape = 0;
		}
		${$central_widget}->destroy();
		$current_widget->();
    });
    gtksignal_connect(gtkset_active($check_cdrw, $cdrw), toggled => sub { 
		$cdrw = $cdrw ? 0 : 1;
		${$central_widget}->destroy();
		$current_widget->();
    });
    $cd_device_entry->set_text( $cd_device );
    $cd_device_entry->signal_connect( 'changed', sub { $cd_device = $cd_device_entry->get_text(); });
    $combo_where_cd_time->entry->set_text($cd_time);
    $combo_where_cd_time->entry->signal_connect( 'changed', sub { $cd_time = $combo_where_cd_time->entry->get_text()});	       

    if ($previous_function) { 
		fonction_env(\$box_where_cd, \&advanced_where_cd, \&$previous_function, ""); 
	} else { 
		fonction_env(\$box_where_cd, \&advanced_where_cd, \&advanced_where, ""); 
	}
    $up_box->show_all();
}

sub advanced_where_tape {
    my ($previous_function) = @_,
    my $box_where_tape;
    my $button;
    my $adj = new Gtk::Adjustment 550.0, 1.0, 10000.0, 1.0, 5.0, 0.0;
    #my ($pix_fs_map, $pix_fs_mask) = gtkcreate_png("filedialog");
    
    gtkpack($advanced_box,
		$box_where_tape = gtkpack_(new Gtk::VBox(0, 6),
			0, new Gtk::HSeparator,
		 	0, my $check_where_tape = new Gtk::CheckButton( _("Use tape to backup") ),
		 	0, new Gtk::HSeparator,
		 	0, gtkpack_(new Gtk::HBox(0,10),
				0, gtkset_sensitive(new Gtk::Label(_("Please enter the device name to use for backup")), $where_tape ),
				1, new Gtk::VBox(0, 6),
				0, gtkset_usize(gtkset_sensitive(my $tape_device_entry = new Gtk::Entry(), $where_tape), 200, 20),
			),
				 	0, new Gtk::VBox(0, 5),
	 		0, gtkpack_(new Gtk::HBox(0,10),
	    		0, gtkset_sensitive(new Gtk::Label(_("Please check if you want to erase your tape before the backup.")), $where_tape),
	    		1, new Gtk::VBox(0, 5),
	    		0, gtkset_sensitive(my $check_tape_erase = new Gtk::CheckButton(), $where_tape),
			),
			0, new Gtk::VBox(0, 6),
			0, gtkpack_(new Gtk::HBox(0,10),
				0, gtkset_sensitive(new Gtk::Label(_("Please enter the maximum size\n allowed for Drakbackup")), $where_tape),
				1, new Gtk::VBox(0, 6),
				0, gtkset_usize(gtkset_sensitive(my $spinner = new Gtk::SpinButton( $adj, 0, 0), $where_tape ), 200, 20),
			),
			0, gtkpack_(new Gtk::HBox(0,10),),
		),
	);
    gtksignal_connect(gtkset_active($check_where_tape, $where_tape), toggled => sub { 
		$where_tape = $where_tape ? 0 : 1;
		#- assure other methods are off
		if ($where_tape = 1) {
			$where_net = 0;
			$where_cd = 0;
		}
		${$central_widget}->destroy();
		$current_widget->();
    });
	gtksignal_connect(gtkset_active($check_tape_erase, $media_erase), toggled => sub { 
		$media_erase = $media_erase ? 0 : 1;
		${$central_widget}->destroy();
		$current_widget->();
    });
    $tape_device_entry->set_text( $tape_device );
    $tape_device_entry->signal_connect( 'changed', sub { $tape_device = $tape_device_entry->get_text()});
    if ($previous_function) { 
		fonction_env(\$box_where_tape, \&advanced_where_tape, \&$previous_function, ""); 
	} else { 
		fonction_env(\$box_where_tape, \&advanced_where_tape, \&advanced_where, ""); 
	}
    $up_box->show_all();
}

sub advanced_where_hd {
    my ($previous_function) = @_,
    my $box_where_hd;
    my $button;
    my $adj = new Gtk::Adjustment 550.0, 1.0, 10000.0, 1.0, 5.0, 0.0;
    my ($pix_fs_map, $pix_fs_mask) = gtkcreate_png("ic82-dossier-32");
    
    gtkpack($advanced_box,
	    $box_where_hd = gtkpack_(new Gtk::VBox(0, 6),
	 0, new Gtk::HSeparator,
#	 0, my $check_where_hd = new Gtk::CheckButton( _("Use Hard Disk to backup") ),
#	 0, new Gtk::HSeparator,
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please enter the directory to save to:")), $where_hd ),
		     1, new Gtk::VBox(0, 6),
		     0, gtkset_usize(gtkset_sensitive($save_path_entry = new Gtk::Entry(), $where_hd), 152, 20),
		     0, gtkset_sensitive($button = gtksignal_connect(new Gtk::Button(),  clicked => sub {
			 filedialog_where_hd();}), $where_hd ),
		     ),
	 0, new Gtk::VBox(0, 6),
	 0, gtkpack_(new Gtk::HBox(0,10),
	   0, gtkset_sensitive(new Gtk::Label(_("Please enter the maximum size\n allowed for Drakbackup")),  $where_hd ),
	   1, new Gtk::VBox(0, 6),
	   0, gtkset_usize(gtkset_sensitive(my $spinner = new Gtk::SpinButton( $adj, 0, 0), $where_hd ), 200, 20),
		     ),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     1, new Gtk::VBox(0, 6),
	   0, gtkset_sensitive(my $check_where_hd_quota = new Gtk::CheckButton( _("Use quota for backup files.")), $where_hd ),
		     0, new Gtk::VBox(0, 6),
		     ),
	 ),
	    );
    foreach ([$check_where_hd_quota, \$hd_quota]) {
	my $ref = $_->[1];
	gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => sub { ${$ref} = ${$ref} ? 0 : 1; })
	}
#    gtksignal_connect(gtkset_active($check_where_hd, $where_hd), toggled => sub { 
#	$where_hd = $where_hd ? 0 : 1;
#	$where_hd = 1;
#	${$central_widget}->destroy();
#	$current_widget->();
#    });
    $button->add(gtkpack(new Gtk::HBox(0,10), new Gtk::Pixmap($pix_fs_map, $pix_fs_mask)));
    $save_path_entry->set_text( $save_path );
    $save_path_entry->signal_connect( 'changed', sub { $save_path = $save_path_entry->get_text()});
    if ($previous_function) { 
		fonction_env(\$box_where_hd, \&advanced_where_hd, \&$previous_function, ""); 
	} else { 
		fonction_env(\$box_where_hd, \&advanced_where_hd, \&advanced_where, ""); 
	}
    $up_box->show_all();
}

sub advanced_where{
    my $box_where;
    my ($pix_net_map, $pix_net_mask) = gtkcreate_png("ic82-network-40");
    my ($pix_cd_map, $pix_cd_mask) = gtkcreate_png("ic82-CD-40");
    my ($pix_hd_map, $pix_hd_mask) = gtkcreate_png("ic82-discdurwhat-40");
    my ($pix_tape_map, $pix_tape_mask) = gtkcreate_png("ic82-tape-40");

    gtkpack($advanced_box,
	    $box_where = gtkpack_(new Gtk::HBox(0, 15),
				  1, new Gtk::VBox(0, 5),
				  1, gtkpack_(new Gtk::VBox(0, 15),	
					  1, new Gtk::VBox(0, 5),
					  1, gtksignal_connect(my $button_where_net = new Gtk::Button(), clicked => sub { 
#					      $box_where->destroy(); advanced_where_net(); }),
#					      $box_where->destroy(); advanced_where_net_ftp(); }),
#					      $box_where->destroy(); 
					      ${$central_widget}->destroy();
					      advanced_where_net_types(); 
					  }),
					  1, gtksignal_connect(my $button_where_cd = new Gtk::Button(),  clicked => sub { 
					      ${$central_widget}->destroy(); 
					      if (require_rpm("mkisofs", "cdrecord")) { 
					      	advanced_where_cd();
					      } else { 
						  	${$central_widget}->destroy();
						  	install_rpm(\&advanced_where);
						  }
					  }),
					  1, gtksignal_connect(my $button_where_hd = new Gtk::Button(),  clicked => sub { 
					      ${$central_widget}->destroy(); 
					      advanced_where_hd();
					  }),
					  1, gtksignal_connect(my $button_where_tape = new Gtk::Button(),  clicked => sub { 
					      ${$central_widget}->destroy(); 
						  # message_underdevel();
						  advanced_where_tape(); }),
					  1, new Gtk::VBox(0, 5),
					     ),
				  1, new Gtk::VBox(0, 5),	
				  ),
	    );
    $button_where_net->add(gtkpack(new Gtk::HBox(0,10),
				   new Gtk::Pixmap($pix_net_map, $pix_net_mask),
				   new Gtk::Label(_("Network")),
				   new Gtk::HBox(0, 5)
				   ));
    $button_where_cd->add(gtkpack(new Gtk::HBox(0,10),
				  new Gtk::Pixmap($pix_cd_map, $pix_cd_mask),
				  new Gtk::Label(_("CDROM / DVDROM")),
				  new Gtk::HBox(0, 5)
				  ));
    $button_where_hd->add(gtkpack(new Gtk::HBox(0,10),
				  new Gtk::Pixmap($pix_hd_map, $pix_hd_mask),
				  new Gtk::Label(_("HardDrive / NFS")),
				  new Gtk::HBox(0, 5)
				  ));
    $button_where_tape->add(gtkpack(new Gtk::HBox(0,10),
 				  new Gtk::Pixmap($pix_tape_map, $pix_tape_mask),
 				  new Gtk::Label(_("Tape")),
 				  new Gtk::HBox(0, 5)
 				  ));
    fonction_env(\$box_where, \&advanced_where, \&advanced_box, ""); 
    $up_box->show_all();
}

#- 7/7/2002 - S.Benedict reworked when - drop all the checkboxes and use a list
#- chances that we want to do backups via multiple medias in cron are slim
sub advanced_when{
    my $box_when;
#   $daemon_media = '';
    my ($pix_time_map, $pix_time_mask) = gtkcreate_png("ic82-when-40");
    my $combo_when_space = new Gtk::Combo();
    my %trans = (_("hourly") => 'hourly',
		 _("daily") => 'daily',
		 _("weekly") => 'weekly',
		 _("monthly") => 'monthly');
    my %trans2 = ('hourly' => _("hourly"),
		  'daily' => _("daily"),
		  'weekly' => _("weekly"),
		  'monthly' => _("monthly"));
    $combo_when_space->set_popdown_strings (_("hourly"),_("daily"),_("weekly"),_("monthly"));    

	#- drop down list of possible medias - default to config value
    my $entry_media_type = new Gtk::Combo();
    $entry_media_type->set_popdown_strings(@media_types, @net_methods);
#    $entry_media_type->set_value_in_list(1, 0);   
	$entry_media_type->entry->set_text("$daemon_media");
	
    gtkpack($advanced_box,
	  $box_when = gtkpack_(new Gtk::VBox(0, 15),
	  0, gtkpack_(new Gtk::HBox(0,10),
		1, new Gtk::HBox(0,10),
		1, new Gtk::Pixmap($pix_time_map, $pix_time_mask),
		0, my $check_when_daemon  = new Gtk::CheckButton( _("Use daemon")  ), 
		1, new Gtk::HBox(0,10),
	  ),
	  0, new Gtk::HSeparator,
	  0, gtkpack_(new Gtk::HBox(0,10),
		0, gtkset_sensitive(new Gtk::Label(_("Please choose the time \ninterval between each backup")),  $backup_daemon),
		1, new Gtk::HBox(0,10),
		0, gtkset_sensitive($combo_when_space, $backup_daemon),
	  ),
	  0, new Gtk::HBox(0,10),
	  0, gtkpack_(new Gtk::HBox(0,10),
		0, gtkset_sensitive(new Gtk::Label(_("Please choose the\nmedia for backup.")), $backup_daemon),
		1, new Gtk::HBox(0,10),
		0, gtkpack_(new Gtk::VBox(0,10),
			0, gtkset_sensitive($entry_media_type, $backup_daemon),
		),
	  ),
	  0, new Gtk::HSeparator,
	  1, gtkset_sensitive(new Gtk::Label(_("Please be sure that the cron daemon is included in your services. 
\nNote that currently all 'net' medias also use the hard drive.")),  $backup_daemon),
	  ),
	);

    gtksignal_connect(gtkset_active($check_when_daemon, $backup_daemon), toggled => sub { 
		$backup_daemon = $backup_daemon ? 0 : 1;
		${$central_widget}->destroy();
		advanced_when();
    });
    $combo_when_space->entry->set_text( $trans2{$when_space} );
    $combo_when_space->entry->signal_connect( 'changed', sub { $when_space = $trans{$combo_when_space->entry->get_text()}; });
	$entry_media_type->entry->signal_connect( 'changed', sub { 
		$daemon_media = $entry_media_type->entry->get_text();
		set_daemon_media();
	});
    fonction_env(\$box_when, \&advanced_when, \&advanced_box, "");
    $up_box->show_all();
}

sub set_daemon_media {
	#- is there really any need to set all these daemon flags?
	#- why not just use daemon_media - leave it for now (sb)
#	$daemon_media = @_;
	$hd_daemon = 1;
	$ftp_daemon = 0;
	$ssh_daemon = 0;
	$cd_daemon = 0;
	$tape_daemon = 0;
	$rsync_daemon = 0;
	$webdav_daemon = 0;
	$ftp_daemon = 1 if ($daemon_media eq 'ftp'); 		
	$ssh_daemon = 1 if ($daemon_media eq 'ssh');
	$rsync_daemon = 1 if ($daemon_media eq 'rsync');
	$cd_daemon = 1 if ($daemon_media eq 'cd');
	$tape_daemon = 1 if ($daemon_media eq 'tape');
	$tape_daemon = 1 if ($daemon_media eq 'tape');
	$webdav_daemon = 1 if ($daemon_media eq 'webdav');
}

sub advanced_options{
    my $box_options;
    my ($pix_options_map, $pix_options_mask) = gtkcreate_png("ic82-moreoption-40");
    
    gtkpack($advanced_box,
	    $box_options = gtkpack_(new Gtk::VBox(0, 15),
# 				 0, gtkpack_(new Gtk::HBox(0,10),
# 					     1, new Gtk::VBox(0,10),
# 					     1, new Gtk::Pixmap($pix_options_map, $pix_options_mask),
# 					     1, _("Please choose correct options to backup."),
# 					     1, new Gtk::VBox(0,10),
# 					     ),
# 				 0, new Gtk::HSeparator,
# 				 0, gtkpack_(new Gtk::VBox(0,10),
# 					     0, gtkset_sensitive(my $check_tar_bz2  = new Gtk::CheckButton( _("Use Tar and bzip2 (very slow) [Please be careful if you\n (un)select this option, as all your old backups will be deleted.]") ), 0),
# 			 0, gtkset_sensitive(my $check_backupignore = new Gtk::CheckButton( _("Use .backupignore files")), 0),
				    0, new Gtk::VBox(0,10),
				    0, gtkpack_(new Gtk::HBox(0,10),
						0, my $check_mail = new Gtk::CheckButton( _("Send mail report after each backup to :")),
						1, new Gtk::HBox(0,10),
						0, my $mail_entry = new Gtk::Entry(),
						),
#					     ),
				    ),
	    );
    check_list([$check_mail, \$send_mail]);
#    check_list([$check_mail, \$send_mail], [$check_tar_bz2, \$comp_mode], [$check_backupignore, \$backupignore]);
    $mail_entry->set_text( $user_mail );
    $mail_entry->signal_connect( 'changed', sub { $user_mail = $mail_entry->get_text()});
    fonction_env(\$box_options, \&advanced_options, \&advanced_box, "options");
    $up_box->show_all();
}

sub advanced_box{
    my $box_adv;
    my ($pix_hd_map, $pix_hd_mask) = gtkcreate_png("ic82-discdurwhat-40");
    my ($pix_time_map, $pix_time_mask) = gtkcreate_png("ic82-when-40");
    my ($pix_net_map, $pix_net_mask) = gtkcreate_png("ic82-where-40");
    my ($pix_options_map, $pix_options_mask) = gtkcreate_png("ic82-moreoption-40");

    gtkpack($advanced_box,
	    $box_adv = gtkpack_(new Gtk::HBox(0, 15),
				    1, new Gtk::VBox(0, 5),	
				    1, gtkpack_(new Gtk::VBox(0, 15),	
						1, new Gtk::VBox(0, 5),	
						1, gtksignal_connect(my $button_what = new Gtk::Button(), clicked => sub { 
						    ${$central_widget}->destroy(); advanced_what(); }),
						1, gtksignal_connect(my $button_where = new Gtk::Button(), clicked => sub { 
						    ${$central_widget}->destroy();  advanced_where(); }),
						1, gtksignal_connect(my $button_when = new Gtk::Button(), clicked => sub { 
						    ${$central_widget}->destroy();  advanced_when(); }),
						1, gtksignal_connect(my $button_options = new Gtk::Button(), clicked => sub {
						    ${$central_widget}->destroy(); advanced_options();}),
						1, new Gtk::VBox(0, 5),	
						),
				    1, new Gtk::VBox(0, 5),	
				    ),
	    );
    $button_what->add(gtkpack(new Gtk::HBox(0,10),
			      new Gtk::Pixmap($pix_hd_map, $pix_hd_mask),
			      new Gtk::Label(_("What")),
			      new Gtk::HBox(0, 5)
			      ));
    $button_where->add(gtkpack(new Gtk::HBox(0,10),
			      new Gtk::Pixmap($pix_net_map, $pix_net_mask),
			      new Gtk::Label(_("Where")),
			      new Gtk::HBox(0, 5)
			      ));
    $button_when->add(gtkpack(new Gtk::HBox(0,10),
			      new Gtk::Pixmap($pix_time_map, $pix_time_mask),
			      new Gtk::Label(_("When")),
			      new Gtk::HBox(0, 5)
			      ));
    $button_options->add(gtkpack(new Gtk::HBox(0,10),
			      new Gtk::Pixmap($pix_options_map, $pix_options_mask),
			      new Gtk::Label(_("More Options")),
			      new Gtk::HBox(0, 5)
			      ));
    fonction_env(\$box_adv, \&advanced_box, \&interactive_mode_box, "");
    $up_box->show_all();
}

################################################  WIZARD  ################################################  

sub wizard_step3 {
    my $box2;    
    my $text = new Gtk::Text(undef, undef);
    system_state();
    gtktext_insert($text, $system_state);
    button_box_restore_main();

    gtkpack($advanced_box,
	    $box2 =  gtkpack_(new Gtk::HBox(0, 15),	
			      1, gtkpack_(new Gtk::VBox(0,10),
					  0, _("Drakbackup Configuration"),
					  1, createScrolledWindow($text),
					  ),
			      ),
	    );
    fonction_env(\$box2, \&wizard_step3, \&wizard_step2, "");
    button_box_wizard_end();
    $up_box->show_all();
}

sub wizard_step2 {
    my $box2;    
    
    gtkpack($advanced_box,
	    $box2 =  gtkpack_(new Gtk::HBox(0, 15),	
			      1, new Gtk::VBox(0, 5),	
			      1, gtkpack_(new Gtk::VBox(0, 15),	
					  1, new Gtk::VBox(0, 5),
					  0, _("Please choose where you want to backup"),
					  0, gtkpack_(new Gtk::HBox(0, 15),	      
						      0, my $check_wizard_hd = new Gtk::CheckButton(_("on Hard Drive")),
						      1, new Gtk::VBox(0, 5),
						      0, gtkset_sensitive(gtksignal_connect(new Gtk::Button(_("Configure")),
											    clicked => sub {
												${$central_widget}->destroy();
												to_ok();
												advanced_where_hd(\&wizard_step2);
												to_normal();
											    }), $where_hd ),
									  ),
					  0, gtkpack_(new Gtk::HBox(0, 15),	      
						      0, my $check_wizard_net = new Gtk::CheckButton(_("across Network")),
						      1, new Gtk::VBox(0, 5),
						      0, gtkset_sensitive(gtksignal_connect(new Gtk::Button(_("Configure")),
											    clicked => sub {
												${$central_widget}->destroy();
												to_ok();
												advanced_where_net_types(\&wizard_step2);
												to_normal();
											    }), $where_net ),
						      ),
# 					  0, gtkpack_(new Gtk::HBox(0, 15),	      
# 						      0, my $check_wizard_cd = new Gtk::CheckButton(_("on CDROM")),
# 						      1, new Gtk::VBox(0, 5),	
# 						      0, gtkset_sensitive(gtksignal_connect(new Gtk::Button(_("Configure")),
# 											    clicked => sub {
# 												${$central_widget}->destroy();
# 												advanced_where_cd(\&wizard_step2);
# 											    }), $where_cd ),
# 						      ),
# 					  0, gtkpack_(new Gtk::HBox(0, 15),	      
# 						      0, my $check_wizard_tape = new Gtk::CheckButton(_("on Tape Device")),
# 						      1, new Gtk::VBox(0, 5),
# 						      0, gtkset_sensitive(gtksignal_connect(new Gtk::Button(_("Configure")), 
# 											    clicked => sub {
# 												${$central_widget}->destroy();
# 												advanced_where_tape(\&wizard_step2);
# 											    }), $where_tape),
# 						      ),
					  1, new Gtk::VBox(0, 5),
					  ),
			      1, new Gtk::VBox(0, 5),	
			      ),
	    );
#    $where_net = $where_net_ssh || $where_net_ftp;
    foreach ([$check_wizard_hd, \$where_hd], 
#	     [$check_wizard_cd, \$where_cd], 
#	     [$check_wizard_tape, \$where_tape],
	     [$check_wizard_net, \$where_net]) {
	my $ref = $_->[1];
	gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => 
			  sub { ${$ref} = ${$ref} ? 0 : 1;
				$where_hd = 1;
				if (!$where_hd && !$where_cd && !$where_net) {  $next_widget = \&message_noselect_box; }
				else { $next_widget = \&wizard_step3;   }
#				if(!$where_net) {$where_net_ssh = 0; $where_net_ftp = 0; }
#				else {$where_net_ftp = 1;}
				${$central_widget}->destroy();
				wizard_step2();
			    })
	}
    if (!$where_hd && !$where_cd && !$where_net) { fonction_env(\$box2, \&wizard_step2, \&wizard, "", \&message_noselect_box)}
    else { fonction_env(\$box2, \&wizard_step2, \&wizard, "", \&wizard_step3)}
    button_box_wizard();
    $up_box->show_all();
}

sub wizard   {
    my $box2;    
    
    gtkpack($advanced_box,
	    $box2 =  gtkpack_(new Gtk::HBox(0, 15),	
			      1, new Gtk::VBox(0, 5),	
			      1, gtkpack_(new Gtk::VBox(0, 15),	
					  1, new Gtk::VBox(0, 5),
					  0, _("Please choose what you want to backup"),
					  0, my $check_wizard_sys = new Gtk::CheckButton(_("Backup system")),
					  0, my $check_wizard_user = new Gtk::CheckButton(_("Backup Users")),
					  0, gtkpack_(new Gtk::HBox(0, 15),
					       1, new Gtk::VBox(0, 5),	
					       0, gtksignal_connect(new Gtk::Button(_("Select user manually")), clicked => sub {
						   ${$central_widget}->destroy();
						   advanced_what_user(\&wizard);
					       }),
						      ),
					  1, new Gtk::VBox(0, 5),	
					  ),
			      1, new Gtk::VBox(0, 5),	
			      ),
	    );
    foreach ([$check_wizard_sys, \$backup_sys], [$check_wizard_user, \$backup_user]) {
	my $ref = $_->[1];
	gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => 
			  sub { ${$ref} = ${$ref} ? 0 : 1;
				if ($backup_sys || $backup_user && @user_list ) { $next_widget = \&wizard_step2; } 
				else { $next_widget = \&message_noselect_what_box; }
			    })}
    if ($backup_sys || $backup_user && @user_list ) { fonction_env(\$box2, \&wizard, \&interactive_mode_box, "", \&wizard_step2) } 
    else { fonction_env(\$box2, \&wizard, \&interactive_mode_box, "", \&message_noselect_what_box) } 
    button_box_wizard();
    $up_box->show_all();
}

################################################  RESTORE  ################################################  

sub find_backup_to_restore {
	# fixme: 
	# faire test existance cd
	# faire reponse si non existance de  $path_to_find_restore
    my @list_backup = ();
    my @list_backup_tmp2 = ();
    my $to_put;
    @sys_backuped = ();
    my @list_backup_tmp;
    my @user_backuped_tmp;

    @user_backuped = ();
    -d $path_to_find_restore and @list_backup_tmp2 = all($path_to_find_restore);
    foreach (@list_backup_tmp2) {
	s/\_base//gi;
	s/\_incr//gi;
	push @list_backup , $_;
    }
    if (grep /^backup_other/, @list_backup) {$other_backuped = 1;}
    if (grep /^backup_sys/, @list_backup) {$sys_backuped = 1;}
    foreach (grep /^backup_sys_/, @list_backup) {
	chomp;
	s/^backup_sys_//gi;
	s/.tar.gz$//gi;
	s/.tar.bz2$//gi;
 	my ( $date, $heure) = /^(.*)_([^_]*)$/; 
	my $year = substr($date, 0, 4);
	my $month = substr($date, 4,  2);
	my $day =  substr($date, 6, 2);
	my $hour = substr($heure, 0,  2);
	my $min =  substr($heure, 2, 2);
	$to_put = "$day/$month/$year $hour:$min                   $_";
 	push @sys_backuped , $to_put;
    }
    $restore_step_sys_date  = $to_put;
    foreach (grep /^backup_user_/, @list_backup) {
	chomp;
	s/^backup_user_//gi;
	s/.tar.gz$//gi;
	s/.tar.bz2$//gi;
	my ($nom, $date, $heure) = /^(.*)_([^_]*)_([^_]*)$/;
	my $year = substr($date, 0, 4);
	my $month = substr($date, 4,  2);
	my $day =  substr($date, 6, 2);
	my $hour = substr($heure, 0,  2);
	my $min =  substr($heure, 2, 2);
#	my $to_put = "  $nom,  (date: $date, hour: $heure)";
	$to_put = "$_       user: $nom,   date: $day/$month/$year,   hour: $hour:$min";
	push @user_backuped , $to_put;
	grep ( /^$nom$/, @user_list_backuped) or push @user_list_backuped, $nom;
    }
}

sub system_state {
    $system_state = ();

    if ($cfg_file_exist) { 
		$system_state .= _("\nBackup Sources: \n");
        $backup_sys and $system_state .= _("\n- System Files:\n"); 
        $backup_sys and $system_state .= "\t\t$_\n" foreach @sys_files; 
        $backup_user and $system_state .= _("\n- User Files:\n");
        $backup_user and $system_state .= "\t\t$_\n" foreach @user_list;
        @list_other and $system_state .= _("\n- Other Files:\n"); 
        @list_other and $system_state .= "\t\t$_\n" foreach @list_other;
        $where_hd and $system_state .= _("\n- Save on Hard drive on path : %s\n", $save_path);
		
		#- tape and CDRW share some features
		my $erase_media = 'NO';
		$erase_media = 'YES' if ($media_erase); 
		$where_cd and $system_state .= _("\n- Burn to CD");
		$where_cd and $cdrw and $system_state .= _("RW");
		$where_cd and $system_state .= _(" on device : %s", $cd_device);
		$where_tape and $system_state .= _("\n- Save to Tape on device : %s", $tape_device);
		$media_erase and $system_state .= _("\t\tErase=%s", $erase_media);
		($where_cd || $where_tape) and $system_state .= "\n";
		
		$where_net and $system_state .= _("\n- Save via %s on host : %s\n", $net_proto, $host_name);
		$where_net and $system_state .= _("\t\t user name: %s\n\t\t on path: %s \n", $login_user, $host_path);
		$system_state .= _("\n- Options:\n");
		$backup_sys or $system_state .= _("\tDo not include System Files\n");
		
		if ($comp_mode) { 
			$system_state .= _("\tBackups use tar and bzip2\n"); 
		} else { 
			$system_state .= _("\tBackups use tar and gzip\n");
		}   

		$daemon_media and $system_state .= _("\n- Daemon (%s) include :\n", $when_space);
		$hd_daemon and $system_state .= _("\t-Hard drive.\n");    
		$cd_daemon and $system_state .= _("\t-CDROM.\n");
		$tape_daemon and $system_state .= _("\t-Tape \n");    
		$ftp_daemon and $system_state .= _("\t-Network by FTP.\n");    
		$ssh_daemon and $system_state .= _("\t-Network by SSH.\n");    
		$rsync_daemon and $system_state .= _("\t-Network by rsync.\n");    
		$webdav_daemon and $system_state .= _("\t-Network by webdav.\n");    
    } else {
    	$system_state = _("No configuration, please click Wizard or Advanced.\n");
    }
}

sub restore_state {
    my @tmp = split( ' ', $restore_step_sys_date);
    $restore_state = _("List of data to restore:\n\n");
    if ($restore_sys) { $restore_state .= "- Restore System Files.\n";
			$restore_state .= "   - from date: $tmp[0] $tmp[1]\n";
	}
    if ($restore_user) { 
		$restore_state .= "- Restore User Files: \n" ;
		$restore_state .= "\t\t$_\n" foreach @user_list_to_restore2 ;
		push @user_list_to_restore, (split(',', $_))[0] foreach @user_list_to_restore2 ;
    }
    if ($restore_other) { 
		$restore_state .= "- Restore Other Files: \n";
		-f "$path_to_find_restore/list_other" and $restore_state .= "\t\t$_\n" foreach split( "\n", cat_("$path_to_find_restore/list_other"));  
    }
    if ($restore_other_path) {
		$restore_state .= "- Path to Restore: $restore_path \n";
    }
}

sub select_most_recent_selected_of {
    my ($user_name) = @_;
    my @list_tmp2;
    my @tmp = sort @user_list_to_restore2;
    foreach (grep /$user_name\_/, sort @tmp) { push @list_tmp2 , $_; }
    return pop @list_tmp2;
}

sub select_user_data_to_restore {
    my $var_eq = 1;
    my @list_backup = ();
    my @list_tmp = ();
    my @list_tmp2 = ();
    @user_list_to_restore = ();

    -d $path_to_find_restore and my @list_backup_tmp2 = grep /^backup/, all($path_to_find_restore);
    @list_tmp2 = @list_backup_tmp2;
    foreach (@list_backup_tmp2) {
		s/\_base//gi;
		s/\_incr//gi;
		push @list_backup , $_;
    }
    foreach my $var_tmp (@user_list_backuped) {
		$var_eq = 1;
		my $more_recent = (split( ' ', select_most_recent_selected_of($var_tmp)))[0]; 
		foreach (grep /^backup\_user\_$var_tmp\_/, sort @list_backup) {
	    	s/.tar.gz//gi;
	    	s/.tar.bz2//gi;	    
	    	if ($more_recent) {
				if ( $_ =~ /$more_recent/ ) {
		    		push @list_tmp , $_;
		    		$var_eq = 0;    
				} else { 
					$var_eq and push @list_tmp , $_;
				}
	    	}
		}
    }
	foreach my $var_to_restore (@list_tmp) {
		$var_to_restore =~ s/backup_//gi;
		foreach my $var_exist ( sort @list_tmp2) {
	    	if ($var_exist =~ /$var_to_restore/ ) {
				push @user_list_to_restore, $var_exist;
	    	}
		}
    }
    $DEBUG and print "(incremental restore) real user list to restore :  $_ \n" foreach (@user_list_to_restore);
}

sub select_sys_data_to_restore {
    my $var_eq = 1;
    my @list_tmp = ();
    @sys_list_to_restore = ();

    -d $path_to_find_restore and @list_tmp = grep /^backup/, all($path_to_find_restore);
    my @more_recent = split( ' ', $restore_step_sys_date); 
    my $more_recent = pop @more_recent;
    foreach my $var_exist (grep /\_sys\_/, sort @list_tmp) {
		if ($var_exist =~ /$more_recent/ ) {
	    	push @sys_list_to_restore, $var_exist;
	    	$var_eq = 0; 
	    } else {  
	    	$var_eq and push @sys_list_to_restore, $var_exist; 
	    }
    }
    $DEBUG and print "sys list to restore: $_\n " foreach (@sys_list_to_restore);
}

sub valid_backup_test {
    my (@files_list) = @_;
    @files_corrupted = ();
    my $is_corrupted = 0;
    foreach (@files_list) {
		if (system("gzip -l $path_to_find_restore/$_") > 1 ) {
	    	push @files_corrupted, $_;
	    	$is_corrupted = -1;
		}
    }
    return $is_corrupted;
}

sub restore_aff_backup_problems {
    my $do_restore;
    my $button_restore;
    my $text = new Gtk::Text(undef, undef);
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');
    my $restore_pbs_state = _("List of data corrupted:\n\n");
    $restore_pbs_state .= "\t\t$_\n" foreach @files_corrupted ;
    $restore_pbs_state .= _("Please uncheck or remove it on next time.");
    gtktext_insert($text, $restore_pbs_state);
    button_box_restore_main();    

    gtkpack($advanced_box,
	    $do_restore = gtkpack_(new Gtk::VBox(0,10),
				   0, new Gtk::VBox(0,10),
				   1, gtkpack_(new Gtk::HBox(0, 15),	
					      1, new Gtk::VBox(0, 5),	
					      0, new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
					      0, _("Backup files are corrupted"),
					      1, new Gtk::VBox(0, 5),	
					  ),
				   0, new Gtk::VBox(0,10),
				   1, createScrolledWindow($text),
				   ),
	    );
    button_box_restore_pbs_end();
    fonction_env(\$do_restore, \&restore_aff_backup_problems, "", "restore_pbs");
    $up_box->show_all();
}

sub restore_aff_result {
    my $do_restore;
    my $text = new Gtk::Text(undef, undef);
    gtktext_insert($text, $restore_state);
    button_box_restore_main();
    
    gtkpack($advanced_box,
	    $do_restore = gtkpack_(new Gtk::VBox(0,10),
				   1, new Gtk::VBox(0,10),
				   0, _("          All your selectionned data have been          "),
				   0, _("          Successfuly Restored on %s       ", $restore_path),
				   1, new Gtk::VBox(0,10),
				   ),
	    );
    button_box_build_backup_end();
    $central_widget = \$do_restore;
    $up_box->show_all();

}

sub return_path {
    my ($username) = @_;
    my $usr;
    my $home_dir;
    my $passwdfile = "/etc/passwd";
    open (PASSWD, $passwdfile) or exit 1; 
    while (defined(my $line = <PASSWD>)) {
		chomp($line);
		($usr,$home_dir) = (split(/:/, $line))[0,5];
		last if ($usr eq $username); 
    }
    close (PASSWD);
    return $home_dir;
}

sub restore_backend {
    my $untar_cmd;
    my $exist_problem = 0;
    my $user_dir;
    if (grep /tar.gz$/, all($path_to_find_restore)) { 
    	$untar_cmd = 0; 
    } else { 
    	$untar_cmd = 1; 
    }
    if ($restore_user)  { 
		if ($backup_user_versions) {
	    	select_user_data_to_restore();
	    	if (valid_backup_test(@user_list_to_restore) == -1) {
				$exist_problem = 1;
				restore_aff_backup_problems();
	    	} else {
				foreach (@user_list_to_restore) {
		    		my ($tnom, $username, $theure2) = /^(\w+\_\w+\_user_)(.*)_(\d+\_\d+.*)$/;
		    		$DEBUG and print "user name to restore: $username, user directory: $user_dir\n";		    
		    		if ($remove_user_before_restore) {
						$user_dir = return_path($username);
						-d $user_dir and rm_rf($user_dir);
		    		}
		    		$untar_cmd or system(" tar xfz  $path_to_find_restore/$_ -C $restore_path") ;
		    		$untar_cmd and system("/usr/bin/bzip2 -cd $path_to_find_restore/$_ | tar xf -C $restore_path ") ;
				}
	    	}
		}
    }
    if ($restore_sys)   { 
		if ($backup_sys_versions) {
			select_sys_data_to_restore();
	    	if (valid_backup_test(@sys_list_to_restore) == -1) {
				$exist_problem = 1;
				restore_aff_backup_problems();
	    	} else {
				$untar_cmd or system("tar xfz $path_to_find_restore/$_  -C $restore_path ") foreach @sys_list_to_restore;
				$untar_cmd and system("/usr/bin/bzip2 -cd $path_to_find_restore/$_  | tar xf -C $restore_path ") foreach @sys_list_to_restore;
			}
		} else {
			$untar_cmd or system("tar xfz $path_to_find_restore/backup_sys.tar.gz  -C $restore_path ");
			$untar_cmd and system("/usr/bin/bzip2 -cd $path_to_find_restore/backup_sys.tar.bz2  | tar xf -C $restore_path ");
		}	    
    }
    if ($restore_other) { 
		$untar_cmd or system("tar xfz $path_to_find_restore/backup_other.tar.gz  -C $restore_path ");
		$untar_cmd and system("/usr/bin/bzip2 -cd $path_to_find_restore/backup_other.tar.bz2  | tar xf -C $restore_path ");
    }
    $exist_problem or restore_aff_result();
}

sub restore_do {
    if ($backup_bef_restore) {
		if ($restore_sys) { 
			$backup_sys = 1;
		} else { 
			$backup_sys = 0;
		}
		if ($restore_user) { 
	    	$backup_user = 1;
	    	@user_list = @user_list_to_restore;
		} else { 
			$backup_user = 0;
		}
		build_backup_status();
		read_conf_file();
		build_backup_files();
		$table->destroy();
    }
    restore_do2();
}

sub restore_do2 {
    my $do_restore;
    my $button_restore;
    my $text = new Gtk::Text(undef, undef);
    restore_state();
    gtktext_insert($text, $restore_state);
    button_box_restore_main();
    
    gtkpack($advanced_box,
	    $do_restore = gtkpack_(new Gtk::VBox(0,10),
				   0, _("         Restore Configuration       "),
				   1, createScrolledWindow($text),
				   ),
	    );
    button_box_restore_end();
    fonction_env(\$do_restore, \&restore_do2, \&restore_box, "restore");
    $up_box->show_all();
}

sub restore_step_other {
    my $retore_step_other;
    my $text = new Gtk::Text(undef, undef);
    my $other_rest = cat_("$path_to_find_restore/list_other");
    gtktext_insert($text, $other_rest); 
    gtkpack($advanced_box,
	    $retore_step_other = gtkpack_(new Gtk::VBox(0,10),
					  1, new Gtk::VBox(0,10),
					  1, createScrolledWindow($text),
			      0, my $check_restore_other_sure = new Gtk::CheckButton(_("OK to restore the other files.")),
					  1, new Gtk::VBox(0,10),
					  ),
	    );
    check_list([$check_restore_other_sure, \$restore_other]);
    fonction_env(\$retore_step_other, \&restore_step_other, \&restore_step2, "restore", \&restore_do);
    $up_box->show_all();
}

my %check_user_to_restore;
sub restore_step_user {
    my $retore_step_user;
    my @tmp_list = sort @user_backuped;
    @user_backuped   = @tmp_list;

    gtkpack($advanced_box,
	    $retore_step_user = gtkpack_(new Gtk::VBox(0,10),
		     0, new Gtk::VBox(0,10),
		     0, _("User list to restore (only the most recent date per user is important)"),
		     1, createScrolledWindow( gtkpack__(new Gtk::VBox(0,0),
							map { my $name;
							      my $var2;
							      my $name_complet = $_;
							      $name = (split( ' ',$name_complet))[0];
							      my @user_list_tmp = ();
							      
							      my $b = new Gtk::CheckButton($name_complet); 
							      if ( grep $name_complet, @user_list_to_restore2)  {
								  gtkset_active($b, 1);
								  $check_user_to_restore{$name_complet}[1] = 1;
							      } else {
								  gtkset_active($b, 0);
								  $check_user_to_restore{$name_complet}[1] = 0;
							      }
							      $b->signal_connect(toggled => sub { 
								  if (!$check_user_to_restore{$name_complet}[1] ) {
								      $check_user_to_restore{$name_complet}[1] = 1;
								      if (!grep (/$name/, @user_list_to_restore2)) {
									  push @user_list_to_restore2, $name_complet;}
								  } else {
								      $check_user_to_restore{$name_complet}[1] = 0;
								      foreach (@user_list_to_restore2) {
									  $var2 =  (split( ' ',$_))[0];
									  if ($name ne $var2) {
									      push @user_list_tmp, $_;
									  }
								      }
								      @user_list_to_restore2 = @user_list_tmp;
								  }
							      });
							      $b } (@user_backuped) 
							),
					      ),
					 ),
	    );
    if ($restore_other) { fonction_env(\$retore_step_user, \&restore_step_user, "", "restore", \&restore_step_other)}
    else{ fonction_env(\$retore_step_user, \&restore_step_user, "", "restore", \&restore_do)}
    $up_box->show_all();
}

sub restore_step_sys {
    my $restore_step_sys;
    my $combo_restore_step_sys = new Gtk::Combo();
    $combo_restore_step_sys->set_popdown_strings (@sys_backuped);

    gtkpack($advanced_box,
	    $restore_step_sys = gtkpack_(new Gtk::VBox(0,10),
					1, new Gtk::VBox(0,10),
					0, my $check_backup_before = new Gtk::CheckButton(_("Backup the system files before:")),
					0, gtkpack_(new Gtk::HBox(0,10),
						    1, _("please choose the date to restore"),
						    0, $combo_restore_step_sys,
						    0, new Gtk::HBox(0,10),
						    ),
					1, new Gtk::VBox(0,10),
					),
	    );
    $combo_restore_step_sys->entry->signal_connect( 'changed', sub {
	$restore_step_sys_date = $combo_restore_step_sys->entry->get_text();
	});
    $combo_restore_step_sys->entry->set_text($restore_step_sys_date);
    fonction_env(\$restore_step_sys, \&restore_step_sys, "", "restore",  );
    if ($restore_user) { fonction_env(\$restore_step_sys, \&restore_step_sys, "", "restore", \&restore_step_user)}
    elsif ($restore_other){ fonction_env(\$restore_step_sys, \&restore_step_sys, "", "restore", \&restore_step_other)}
    else{ fonction_env(\$restore_step_sys, \&restore_step_sys, "", "restore", \&restore_do)}
    $up_box->show_all();
}

sub restore_other_media_hd {
    my ($previous_function) = @_,
    my $box_where_hd;
    my $button;
    my $adj = new Gtk::Adjustment 550.0, 1.0, 10000.0, 1.0, 5.0, 0.0;
    my ($pix_fs_map, $pix_fs_mask) = gtkcreate_png("ic82-dossier-32");
    
    gtkpack($advanced_box,
	    $box_where_hd = gtkpack_(new Gtk::VBox(0, 6),
	 0, new Gtk::HSeparator,
	 0, my $check_where_hd = new Gtk::CheckButton( _("Use Hard Disk to backup") ),
	 0, new Gtk::HSeparator,
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please enter the directory to save:")), $where_hd ),
		     1, new Gtk::VBox(0, 6),
		     0, gtkset_usize(gtkset_sensitive($save_path_entry = new Gtk::Entry(), $where_hd), 152, 20),
		     0, gtkset_sensitive($button = gtksignal_connect(new Gtk::Button(),  clicked => sub {
			 filedialog_where_hd();}), $where_hd ),
		     ),
	 0, new Gtk::VBox(0, 6),
	 0, gtkpack_(new Gtk::HBox(0,10),
	    0, gtkset_sensitive(new Gtk::Label(_("Please enter the maximum size\n allowed for Drakbackup")),  $where_hd ),
	    1, new Gtk::VBox(0, 6),
	    0, gtkset_usize(gtkset_sensitive(my $spinner = new Gtk::SpinButton( $adj, 0, 0), $where_hd ), 200, 20),
		     ),
	 0, gtkpack_(new Gtk::HBox(0,10),
	    1, new Gtk::VBox(0, 6),
	    0, gtkset_sensitive(my $check_where_hd_quota = new Gtk::CheckButton( _("Use quota for backup files.")), $where_hd ),
	    0, new Gtk::VBox(0, 6),
		     ),
	 ),
	    );
    check_list([$check_where_hd_quota, \$hd_quota]);
    gtksignal_connect(gtkset_active($check_where_hd, $where_hd), toggled => sub { 
	$where_hd = $where_hd ? 0 : 1;
	${$central_widget}->destroy();
	$current_widget->();
    });
    $button->add(gtkpack(new Gtk::HBox(0,10), new Gtk::Pixmap($pix_fs_map, $pix_fs_mask)));
    $save_path_entry->set_text( $save_path );
    $save_path_entry->signal_connect( 'changed', sub { $save_path = $save_path_entry->get_text()});
    if ($previous_function) { fonction_env( \$box_where_hd, \&advanced_where_hd, \&$previous_function, "")}
    else { fonction_env( \$box_where_hd, \&advanced_where_hd, \&advanced_where, "")}
    $up_box->show_all();
}

sub restore_find_net {
    my ($previous_function) = @_,
    my $box_where_net;
    
    gtkpack($advanced_box,
	    $box_where_net = gtkpack_(new Gtk::HBox(0, 15),
				      1, new Gtk::VBox(0, 5),
				      1, gtkpack_(new Gtk::VBox(0, 15),	
						  1, new Gtk::VBox(0, 5),
						  1, new Gtk::VBox(0,10),
						  1, gtksignal_connect(new Gtk::Button(_("FTP Connection")), clicked => sub { 
						      $box_where_net->destroy(); 
						      if ($previous_function ) {
							  message_underdevel();
#							  advanced_where_net_ftp(\&$previous_function);
						      } else {
#							  advanced_where_net_ftp();
						      }}),
						  1, gtksignal_connect(new Gtk::Button(_("Secure Connection")),  clicked => sub {
						      $box_where_net->destroy(); 
						      if ($previous_function ) {
#							  advanced_where_net_ssh(\&$previous_function);
						      } else {
#							  advanced_where_net_ssh();
						      }}),
						  1, new Gtk::VBox(0, 5),
						  1, new Gtk::VBox(0,10),
						  ),
				      1, new Gtk::VBox(0, 5),	
				      ),
	    );
    if ($previous_function) { fonction_env( \$box_where_net, \&advanced_where_net, \&$previous_function, "")}
    else { fonction_env( \$box_where_net, \&advanced_where_net, \&advanced_where, "")}
    $up_box->show_all();
}

sub restore_other_media {
    my $box_find_restore;
    my $button;
    my $adj = new Gtk::Adjustment 550.0, 1.0, 10000.0, 1.0, 5.0, 0.0;
    my ($pix_fs_map, $pix_fs_mask) = gtkcreate_png("ic82-dossier-32");
    
    gtkpack($advanced_box,
	    $box_find_restore = gtkpack_(new Gtk::VBox(0, 6),
	 0, new Gtk::HSeparator,
	 0, my $check_other_media_hd = new Gtk::CheckButton( _("Restore from Hard Disk.") ),
				 0, gtkpack_(new Gtk::HBox(0,10),
				 0, gtkset_sensitive(new Gtk::Label(_("Please enter the directory where backups are stored")), $other_media_hd ),
				 1, new Gtk::VBox(0, 6),
				 0, gtkset_usize(gtkset_sensitive($restore_find_path_entry = new Gtk::Entry(), $other_media_hd), 152, 20),
				 0, gtkset_sensitive($button = gtksignal_connect(new Gtk::Button(),  clicked => sub {
				     filedialog_restore_find_path();}), $other_media_hd ),
					     ),
					 1, new Gtk::VBox(0, 6),
#					 0, new Gtk::HSeparator,
# 					 0, my $check_other_media_net = new Gtk::CheckButton( _("Restore from Network") ),
# 					 0, new Gtk::VBox(0, 6),
# 					 1, gtkpack(new Gtk::HBox(0,10),
# 						    new Gtk::VBox(0, 6),
# 						    gtkset_sensitive(gtksignal_connect(new Gtk::Button("Network"),  clicked => sub {
# 							${$central_widget}->destroy();
# 							restore_find_net(\&restore_other_media);}), !$other_media_hd ),
# 						    new Gtk::VBox(0, 6),
# 						    ),
# 					 1, new Gtk::VBox(0, 6),
# 					 0, new Gtk::HSeparator,
					 0, new Gtk::VBox(0, 6),
					 ),
	    );
    gtksignal_connect(gtkset_active($check_other_media_hd, $other_media_hd), toggled => sub { 
	$other_media_hd = $other_media_hd ? 0 : 1;
	${$central_widget}->destroy();
	$current_widget->();
    });
#     gtksignal_connect(gtkset_active($check_other_media_net, !$other_media_hd), toggled => sub { 
# 	$other_media_hd = $other_media_hd ? 0 : 1;
# 	${$central_widget}->destroy();
# 	$current_widget->();
#    });
    $button->add(gtkpack(new Gtk::HBox(0,10), new Gtk::Pixmap($pix_fs_map, $pix_fs_mask)));
    $restore_find_path_entry->set_text( $path_to_find_restore );
    $restore_find_path_entry->signal_connect( 'changed', sub { $path_to_find_restore = $restore_find_path_entry->get_text()});
#- not sure if this was the original intent - address the crash at "Next"
    fonction_env(\$box_find_restore, \&restore_other_media, \&restore_step2, "other_media", \&restore_do);
    $up_box->show_all();
}

sub restore_step2 {
    my $retore_step2;
    my $other_exist;
    my $sys_exist;
    my $user_exist;

    if (-f "$save_path/backup_other*") { $other_exist = 1; } 
    else { my $other_exist = 0; $restore_other = 0; }
    if (grep /\_sys\_/, grep /^backup/, all("$save_path/")) { $sys_exist = 1; } 
    else { my $sys_exist = 0; $restore_sys = 0; }
    if (grep /\_user\_/, grep /^backup/, all("$save_path/")) { $user_exist = 1; } 
    else { my $user_exist = 0; $restore_user = 0; }
    $backup_sys_versions || $backup_user_versions and $backup_bef_restore = 1;

    gtkpack($advanced_box,
	    $retore_step2 = gtkpack_(new Gtk::VBox(0,10),
	 1, new Gtk::VBox(0,10),
	 1, new Gtk::VBox(0,10),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, my $check_restore_other_src = new Gtk::CheckButton(_("Select another media to restore from")),
		     1, new Gtk::HBox(0,10),
		     0, gtkset_sensitive(gtksignal_connect(new Gtk::Button(_("Other Media")),
							   clicked => sub {
							       ${$central_widget}->destroy();
							       restore_other_media();
							   }), $restore_other_src ),
		     ),
	 0, gtkset_sensitive(my $check_restore_sys = new Gtk::CheckButton(_("Restore system")), $sys_exist),
	 0, gtkset_sensitive(my $check_restore_user = new Gtk::CheckButton(_("Restore Users")), $user_exist),
	 0, gtkset_sensitive( my $check_restore_other = new Gtk::CheckButton(_("Restore Other")), $other_exist),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, my $check_restore_other_path = new Gtk::CheckButton(_("select path to restore (instead of / )")),
		     1, new Gtk::HBox(0,10),
		     0, gtkset_sensitive(my $restore_path_entry = new Gtk::Entry(), $restore_other_path),
		     ),
         0, gtkset_sensitive(my $check_backup_bef_restore = new Gtk::CheckButton(_("Do new backup before restore (only for incremental backups.)")), $backup_sys_versions || $backup_user_versions  ),
	 0, gtkset_sensitive(my $check_remove_user_dir = new Gtk::CheckButton(_("Remove user directories before restore.")), $sys_exist),
	 1, new Gtk::VBox(0,10),
	 ),
	    );
    foreach  ([$check_restore_sys, \$restore_sys], 
	      [$check_backup_bef_restore, \$backup_bef_restore],
	      [$check_restore_user, \$restore_user],
	      [$check_remove_user_dir, \$remove_user_before_restore ],
	      [$check_restore_other, \$restore_other]) {
	my $ref = $_->[1];
	gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => sub { 
	    ${$ref} = ${$ref} ? 0 : 1;
	    if (!$restore_sys && !$restore_user && !$restore_other) { $next_widget = \&message_norestore_box; }
	    elsif ($restore_sys && $backup_sys_versions) { $next_widget = \&restore_step_sys; }
	    elsif ($restore_user) { $next_widget = \&restore_step_user;}
	    elsif ($restore_other){ $next_widget = \&restore_step_other;}
	    else{ $next_widget = \&restore_do;}
	})
	}
    gtksignal_connect(gtkset_active($check_restore_other_path, $restore_other_path), toggled => sub {
	$restore_other_path = $restore_other_path ? 0 : 1;
	${$central_widget}->destroy();
	$current_widget->();
    });
    gtksignal_connect(gtkset_active($check_restore_other_src, $restore_other_src), toggled => sub {
	$restore_other_src = $restore_other_src ? 0 : 1;
	${$central_widget}->destroy();
	$current_widget->();
    });
    fonction_env(\$retore_step2, \&restore_step2, \&restore_box, "restore");
    if (!$restore_sys && !$restore_user && !$restore_other) { $next_widget = \&message_norestore_box; }
    elsif ($restore_sys && $backup_sys_versions) { $next_widget = \&restore_step_sys; }
    elsif ($restore_user) { $next_widget = \&restore_step_user;}
    elsif ($restore_other){ $next_widget = \&restore_step_other;}
    else{ $next_widget = \&restore_do;}
    $restore_path_entry->set_text($restore_path); 
    $restore_path_entry->signal_connect( 'changed', sub { $restore_path = $restore_path_entry->get_text(); });
    $up_box->show_all();
}

sub restore_box {
    my $retore_box;
    my $retore_box3;
    my $check_restore_sys;
    my $check_restore_user;
    my $check_restore_other;
    $path_to_find_restore = $save_path;
    find_backup_to_restore();
    button_box_restore_main();

    if ($other_backuped || $sys_backuped || @user_backuped) {
	gtkpack($advanced_box,
		$retore_box = gtkpack_(new Gtk::HBox(0,1),
				       1, new Gtk::VBox(0,10),
				       1, gtkpack_(new Gtk::VBox(0,10),
						   1, new Gtk::VBox(0,10),
						   1, new Gtk::VBox(0,10),
						   1, gtksignal_connect(new Gtk::Button(_("Restore all backups")), 
						       clicked => sub { $retore_box->destroy();
									button_box_restore();
									@user_list_to_restore2 = sort @user_backuped; 
									$restore_sys = 1;
									$restore_other = 1;
									$restore_user = 1;
									restore_do(); }),
						   1, gtksignal_connect(new Gtk::Button(_("Custom Restore")), 
						       clicked => sub { $retore_box->destroy();
									button_box_restore(); 
									restore_step2();
								    }),
						   1, new Gtk::VBox(0,10),
						   1, new Gtk::VBox(0,10),
						   ),
				       1, new Gtk::HBox(0,10),
				       ),
		);
    } else {
	gtkpack($advanced_box,
		$retore_box = gtkpack_(new Gtk::HBox(0,1),
				       message_norestorefile_box(),
				       ),
		),
     }
    fonction_env(\$retore_box, \&restore_box, \&interactive_mode_box, "restore");
    $up_box->show_all();
}

################################################  BUTTON_BOX  ################################################  

# sub generic_button_box {
# # 1-n -  [button name, fonctions associated]
#     $button_box_tmp->destroy();
#     gtkpack($button_box,
# 	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox,				         
# 				       0, gtksignal_connect(new Gtk::Button($_->[0]), clicked => sub {$_->[1]}) foreach (@_), 
# 				       } ), );    
# }

sub button_box_adv {
    $button_box_tmp->destroy();
    gtkpack($button_box,
		$button_box_tmp = gtkpack_(new Gtk::HButtonBox,
			0, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
				${$central_widget}->destroy();
				interactive_mode_box();
			}),
			0, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub { 
				${$central_widget}->destroy();
				adv_help(\&$current_widget,$custom_help );
			}),
			1, new Gtk::HBox(0, 1),	
			0, gtksignal_connect(new Gtk::Button(_("Previous")), clicked => sub { 
				${$central_widget}->destroy();
				$previous_widget->();
			}),
			0, gtksignal_connect(new Gtk::Button(_("Save")), clicked => sub { 
				${$central_widget}->destroy();
				if (!check_pkg_needs()) {
					save_conf_file();
					$previous_widget->();
				}
			}),
		),
	);
}

# sub button_box_adv {
#     generic_button_box(["cancel", ${$central_widget}->destroy() ]);
# }

sub button_box_restore_main {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(gtkpack_(new Gtk::HButtonBox, 
					       0, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
						   ${$central_widget}->destroy(); interactive_mode_box();  }),
					       0, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub {
						   ${$central_widget}->destroy(); 
						   adv_help(\&$current_widget, $custom_help);
					       }),
					       1, new Gtk::HBox(0, 1),	
					       0, gtksignal_connect(new Gtk::Button(_("Previous")), clicked => sub { 
						   ${$central_widget}->destroy(); interactive_mode_box(); }),
					       0, gtksignal_connect(new Gtk::Button(_("Ok")), clicked => sub { 
						   ${$central_widget}->destroy(); interactive_mode_box(); }),
					       ),
				       ),
	    );
}

sub button_box_backup_end {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox,
				       0, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
					   ${$central_widget}->destroy(); interactive_mode_box();  }),
				       0, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub { 
					   ${$central_widget}->destroy(); adv_help(\&$current_widget,$custom_help );  }),
				       1, new Gtk::HBox(0, 1),	
				       0, gtksignal_connect(new Gtk::Button(_("Previous")), clicked => sub { 
					   ${$central_widget}->destroy(); $previous_widget->(); }),
				       0, gtksignal_connect(new Gtk::Button(_("Build Backup")), clicked => sub { 
					   ${$central_widget}->destroy();
					   build_backup_status();
					   build_backup_files(); 
				       }),
				       ),
	    );
}

sub button_box_wizard_end {
    $button_box_tmp->destroy();

    gtkpack($button_box,
		$button_box_tmp = gtkpack_(new Gtk::HButtonBox,
			0, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
				${$central_widget}->destroy();
				interactive_mode_box();
			}),
			0, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub { 
				${$central_widget}->destroy();
				adv_help(\&$current_widget,$custom_help );
			}),
			1, new Gtk::HBox(0, 1),	
			0, gtksignal_connect(new Gtk::Button(_("Previous")), clicked => sub { 
				${$central_widget}->destroy(); 
				$previous_widget->();
			}),
			0, gtksignal_connect(new Gtk::Button(_("Save")), clicked => sub { 
				${$central_widget}->destroy();
				save_conf_file();
				interactive_mode_box();
			}),
		),
	);
}

sub button_box_restore_end {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox,
			0, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
				${$central_widget}->destroy();
				interactive_mode_box();
			}),
			0, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub { 
				${$central_widget}->destroy();
				adv_help(\&$current_widget,$custom_help );
			}),
			1, new Gtk::HBox(0, 1),	
			0, gtksignal_connect(new Gtk::Button(_("Previous")), clicked => sub { 
				${$central_widget}->destroy();
				$previous_widget->();
			}),
			0, gtksignal_connect(new Gtk::Button(_("Restore")), clicked => sub { 
 				${$central_widget}->destroy();
				restore_backend(); 
			}),
		),
	);
}

sub button_box_build_backup_end {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox, 
			1, new Gtk::HBox(0, 5),	
			1, new Gtk::HBox(0, 5),	
			0, gtksignal_connect(new Gtk::Button(_("Ok")), clicked => sub { 
				${$central_widget}->destroy();
				interactive_mode_box();  
			}),
		),
	);
}

sub button_box_restore_pbs_end {
    $button_box_tmp->destroy();

    gtkpack($button_box,
		$button_box_tmp = gtkpack_(new Gtk::HButtonBox, 
			1, new Gtk::HBox(0, 5),	
			1, new Gtk::HBox(0, 5),	
			1, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub {
				${$central_widget}->destroy();
				adv_help(\&$current_widget,$custom_help);
			}),
			0, gtksignal_connect(new Gtk::Button(_("Ok")), clicked => sub { 
				${$central_widget}->destroy();
				interactive_mode_box();
			}),
		),
	);
}

sub button_box_build_backup {
    $button_box_tmp->destroy();

	gtkpack($button_box,
		$button_box_tmp = gtkpack_(new Gtk::HButtonBox,
			1, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
				${$central_widget}->destroy(); 
				interactive_mode_box();
			}),
			1, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub {
				${$central_widget}->destroy();
				adv_help(\&$current_widget,$custom_help); 
			}),
			1, new Gtk::HBox(0, 0),
			0, gtksignal_connect(new Gtk::Button(_("Previous")), clicked => sub { 
				${$central_widget}->destroy();
				$previous_widget->();
			}),
			1, gtksignal_connect(new Gtk::Button(_("Next")), clicked => sub {
				${$central_widget}->destroy();
				$next_widget->();
			}),
		),
	);
}

sub button_box_restore {

    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox,
			1, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
				${$central_widget}->destroy(); 
				interactive_mode_box();  
			}),
			1, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub {
				${$central_widget}->destroy(); 
				adv_help(\&$current_widget,$custom_help);
			}),
			1, new Gtk::HBox(0, 0),
			0, gtksignal_connect(new Gtk::Button(_("Previous")), clicked => sub { 
				${$central_widget}->destroy(); 
				$previous_widget->(); 
			}),
			1, gtksignal_connect(new Gtk::Button(_("Next")), clicked => sub {
				${$central_widget}->destroy(); 
				$next_widget->();
			}),
		),
	);
}

sub button_box_wizard {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox,
				       1, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
								${$central_widget}->destroy(); interactive_mode_box();  }),
				       1, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub {
								${$central_widget}->destroy(); adv_help(\&$current_widget,$custom_help); }),
				       1, new Gtk::HBox(0, 0),
				       0, gtksignal_connect(new Gtk::Button($next_widget ? _("Previous") : _("OK")), clicked => sub { 
								${$central_widget}->destroy();
								$previous_widget ? $previous_widget->() : $next_widget->();
							    }),
				       if_($next_widget, 1, gtksignal_connect(new Gtk::Button(_("Next")), clicked => sub {
										  ${$central_widget}->destroy();
										  $next_widget ? $next_widget->() : $previous_widget->();
									      })),
				      ),
	    );
}

sub button_box_main {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack(gtkset_layout(new Gtk::HButtonBox, -start),
				      gtksignal_connect(new Gtk::Button(_("Close")), clicked => sub {  
					  Gtk->main_quit() }),
				      gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub { 
					  ${$central_widget}->destroy(); adv_help(\&interactive_mode_box,$custom_help) }),
				      ),
	    );
}

################################################  MESSAGES  ################################################  

sub message_norestorefile_box {
    $box2->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');
    
    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack(new Gtk::HBox(0, 15),	
				       new Gtk::VBox(0, 5),	
				       new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
			     _("Please Build backup before to restore it...\n or verify that your path to save is correct."),
				       new Gtk::VBox(0, 5),	
				       ),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    button_box_restore_main();
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub send_mail_pb {
    $table->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');
    
    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    0, gtkpack_(new Gtk::HBox(0, 15),	
					0, new Gtk::VBox(0, 5),	
					0, new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
					0, _("Error durind sendmail
  your report mail was not sent
  Please configure sendmail"),
					),
			    0, new Gtk::VBox(0, 5),	
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    button_box_restore_main();
    $custom_help = "mail_pb";
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub install_rpm {
    my ($previous_function) = @_;
	#- catch a crash when calling help
	#- this GUI control technique is kind of funky
	if ($previous_function eq '') {
		$previous_function = \&advanced_where;
	}
    my $box_what_user;
    gtkpack($advanced_box,
	    $box_what_user = gtkpack_(new Gtk::VBox(0, 15),
			0, _("The following packages need to be installed:\n @list_of_rpm_to_install"),
				0, new Gtk::HSeparator,
				0, gtksignal_connect(new Gtk::Button(_("Install")), clicked => sub {  
					system("urpmi --X @list_of_rpm_to_install"); 
					${$central_widget}->destroy();
					$previous_widget->();		  
				}),
		),
	);
    fonction_env(\$box_what_user, \&install_rpm, \&$previous_function, "what");
    $up_box->show_all();
}

sub client_ftp_pb {
    $table->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');
    
    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    0, gtkpack_(new Gtk::HBox(0, 15),	
					0, new Gtk::VBox(0, 5),	
					0, new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
					0, _("Error during sending file via FTP.
 Please correct your FTP configuration."),
					),
			    0, new Gtk::VBox(0, 5),	
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    button_box_restore_main();
    $custom_help = "mail_pb";
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub message_norestore_box {
    $box2->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');
    
    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack(new Gtk::HBox(0, 15),	
				       new Gtk::VBox(0, 5),	
				       new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
				       _("Please select data to restore..."),
				       new Gtk::VBox(0, 5),	
				       ),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    button_box_restore_main();
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub message_noselect_box {
    $box2->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');
    
    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack(new Gtk::HBox(0, 15),	
				       new Gtk::VBox(0, 5),	
				       new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
				       _("Please select media for backup..."),
				       new Gtk::VBox(0, 5),	
				       ),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    $previous_widget = \&wizard_step2;
    $next_widget = \&wizard_step2;
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub message_noselect_what_box {
    $box2->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');
    
    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack(new Gtk::HBox(0, 15),	
				       new Gtk::VBox(0, 5),	
				       new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
				       _("Please select data to backup..."),
				       new Gtk::VBox(0, 5),	
				       ),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    $previous_widget = \&wizard;
    $next_widget = \&wizard;
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub message_noconf_box {
    $box2->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');

    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack(new Gtk::HBox(0, 15),	
				       new Gtk::VBox(0, 5),	
				       new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
				       _("No configuration file found \nplease click Wizard or Advanced."),
				       new Gtk::VBox(0, 5),	
				       ),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    button_box_restore_main();
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub message_underdevel {
    $box2->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');

    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack(new Gtk::HBox(0, 15),	
				       new Gtk::VBox(0, 5),	
				       new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
				       _("Under Devel ... please wait."),
				       new Gtk::VBox(0, 5),	
				       ),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    $central_widget = \$box2;
    $up_box->show_all();    
}

################################################  BUILD_BACKUP  ################################################  

sub progress {
    my ($progressbar, $incr, $label_text) = @_;
    my($new_val) = $progressbar->get_current_percentage;
    $new_val += $incr;
    if ($new_val > 1) {$new_val = 1}
    $progressbar->update($new_val);
    $progressbar->{label}->set($label_text);
    Gtk->main_iteration while Gtk->events_pending;
}

sub find_backup_to_put_on_cd {
    my @list_backup_tmp;
    my @data_backuped_tmp;
    @data_backuped = ();
    -d $save_path and my @list_backup = all($save_path);
    foreach (grep /^backup_other/, @list_backup) {
	$other_backuped = 1;
	chomp;
	my $tail  = (split(' ',`du $save_path/$_` ))[0] ;
	s/^backup_other//gi;
	s/.tar.gz$//gi;
	s/.tar.bz2$//gi;
	my @user_date = split(/\_20/,$_ );
	my @user_date2 = split(/\_/,$user_date[1] );
	my $to_put = "  other_data,          (tail: $tail ko, date: 20$user_date2[0], hour: $user_date2[1])";
	push @data_backuped , $to_put;
    }
    foreach (grep /_sys_/, @list_backup) {
	$sys_backuped = 1;
	chomp;
	my $tail  = (split(' ',`du $save_path/$_` ))[0] ;
	s/^backup_other//gi;
	s/.tar.gz$//gi;
	s/.tar.bz2$//gi;
	my @user_date = split(/\_20/,$_ );
	my @user_date2 = split(/\_/,$user_date[1] );
	my $to_put = "  system,          (tail: $tail ko, date: 20$user_date2[0], hour: $user_date2[1])";
	push @data_backuped , $to_put;
    }
    foreach (grep /user_/, @list_backup) {
	chomp;
	my $tail  = (split(' ',`du $save_path/$_` ))[0] ;
	s/^backup_user_//gi;
	s/.tar.gz$//gi;
	s/.tar.bz2$//gi;
	my @user_date = split(/\_20/,$_ );
	my @user_date2 = split(/\_/,$user_date[1] );
	my $to_put = "  $user_date[0],          (tail: $tail ko, date: 20$user_date2[0], hour: $user_date2[1])";
	push @data_backuped , $to_put;
    }
}

sub build_backup_status {
    $pbar =   new Gtk::ProgressBar;
    $pbar1 =  new Gtk::ProgressBar;
    $pbar2 =  new Gtk::ProgressBar;
    $pbar3 =  new Gtk::ProgressBar;
    button_box_build_backup_end();
    gtkpack($advanced_box,
	    $table = create_packtable({ col_spacings => 10, row_spacings => 5},
   [""], 
   [""], 
   [""], 
   [""], 
   [""], 
   [""], 
   [""], 
   [""], 
   [_("Backup system files")],
   [ $pbar, $pbar->{label} = new Gtk::Label(' ' )],
   [_("Backup user files") ],
   [$pbar1,$pbar1->{label} = new Gtk::Label(' ' ) ],
   [_("Backup other files")],
   [ $pbar2, $pbar2->{label} = new Gtk::Label(' ' ) ],
   [_("Total Progress")],
   [$pbar3,$pbar3->{label} = new Gtk::Label(' ' ) ],
				      ),
	    );
    $custom_help = "options";
    $central_widget = \$table;
    $up_box->show_all();
    Gtk->main_iteration while Gtk->events_pending;
}


sub build_backup_ftp_status {
    $pbar =   new Gtk::ProgressBar;
    $pbar3 =  new Gtk::ProgressBar;
    $table->destroy();
    button_box_build_backup_end();
    $pbar->set_value(0);
    $pbar3->set_value(0);


    gtkpack($advanced_box,
	    $table =  gtkpack_(new Gtk::VBox(0, 15),
			       1, _("files sending by FTP"),
			       1, new Gtk::VBox(0, 15),
			       1, create_packtable({ col_spacings => 10, row_spacings => 5},
#						    [ $pbar->set_show_text( $show_text );
						    [_("Sending files...")],
						    [""], 
						    [ $pbar->{label} = new Gtk::Label(' ' )],
						    [ $pbar],
						    [""], 
						    [_("Total Progress")],
						    [ $pbar3->{label} = new Gtk::Label(' ' ) ],
						    [$pbar3],
						    ),
			       1, new Gtk::VBox(0, 15),
			      ),
	    );
    $custom_help = "options";
    $central_widget = \$table;
    $up_box->show_all();
    Gtk->main_iteration while Gtk->events_pending;
}



sub build_backup_box_see_conf {
    my $box2;    
    my $text = new Gtk::Text(undef, undef);
    system_state();
    gtktext_insert($text, $system_state);
    button_box_restore_main();

    gtkpack($advanced_box,
	    $box2 =  gtkpack_(new Gtk::HBox(0, 15),	
			      1, gtkpack_(new Gtk::VBox(0,10),
					  0, _("Drakbackup Configuration"),
					  1, createScrolledWindow($text),
					  ),
			      ),
	    );
    button_box_backup_end();
    $custom_help = "";
    $central_widget = \$box2;
    $current_widget = \&build_backup_box_see_conf;
    $previous_widget =\&build_backup_box;
    $up_box->show_all();
}

sub build_backup_box_progress {
#    build_backup_files(); 
}

sub aff_total_tail {
    my @toto = ();
    my $total = 0;
    push @toto, (split (",", $_))[1]  foreach @list_to_build_on_cd;
    foreach (@toto) {
	s/\s+\(tail://gi;
	s/\s+//gi;
	s/ko//gi;
	$total += $_; 
	}
    $label_tail->set("total tail: $total ko");
}

my %check_data_to_backup_cd;
sub build_backup_cd_select_data {
    my $retore_step_user;
    find_backup_to_put_on_cd();
    @list_to_build_on_cd = sort @data_backuped;
    @data_backuped = @list_to_build_on_cd;

    gtkpack($advanced_box,
	    $retore_step_user = gtkpack_(new Gtk::VBox(0,10),
		     0, new Gtk::VBox(0,10),
		     0, _("Data list to include on CDROM."),
		     1, createScrolledWindow( gtkpack__(new Gtk::VBox(0,0),
						      map { my $name = $_;
							    my @user_list_tmp = ();
							    my $b = new Gtk::CheckButton($name); 
							    if ( grep $name , @list_to_build_on_cd)  {
								gtkset_active($b, 1);
							    } else {
								gtkset_active($b, 0);
							    }
							    $b->signal_connect(toggled => sub {
								if (!$check_data_to_backup_cd{$name}[1] ) {
								    $check_data_to_backup_cd{$name}[1] = 1;
								    if (!grep ( /$name$/, @list_to_build_on_cd) ) {
									push @list_to_build_on_cd, $name;}
								} else {
								    $check_data_to_backup_cd{$name}[1] = 0;
								    foreach (@list_to_build_on_cd) {
									if ($name ne $_) {
									    push @user_list_tmp, $_;
									}
								    }
								    @list_to_build_on_cd = @user_list_tmp;
								}
								aff_total_tail();
							    });
							    $b } (@data_backuped) 
						      ),
					      ),
		      0, new Gtk::HSeparator,
		      0, $label_tail = new Gtk::Label(" "),
		      0, new Gtk::HSeparator,
					 ),
	    );
    aff_total_tail();
    fonction_env(\$retore_step_user, \&restore_step_user, \&build_backup_cd_box, "restore", \&build_backup_box_see_conf);
    $up_box->show_all();
}

sub build_backup_cd_box {
    my $box_build_backup_cd;
    my $combo_where_cd_time = new Gtk::Combo();
    my $adj = new Gtk::Adjustment 4.0, 1.0, 10000.0, 1.0, 5.0, 0.0;
    $combo_where_cd_time->set_popdown_strings ("650","700", "750", "800");

    button_box_build_backup();
    gtkpack($advanced_box,
	    $box_build_backup_cd = gtkpack_(new Gtk::VBox(0, 6),
	 	0, my $check_where_cd = new Gtk::CheckButton( _("Use CD/DVDROM to backup")),
	 	0, new Gtk::HSeparator,
	 	0, new Gtk::VBox(0, 5),
	 	0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please choose your CD space")), $where_cd),
		     1, new Gtk::VBox(0, 5),
		     0, gtkset_usize(gtkset_sensitive($combo_where_cd_time, $where_cd), 100, 20),
		     ),
	 	0, new Gtk::VBox(0, 5),
	 	0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please enter the cd writer speed")),  $where_cd ),
		     1, new Gtk::VBox(0, 6),
		     0, gtkset_usize(gtkset_sensitive(my $spinner = new Gtk::SpinButton( $adj, 0, 0), $where_cd ),  100, 20),
		     ),				 
	 	0, new Gtk::VBox(0, 5),
	 	0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please check if you are using CDRW media")), $where_cd),
		     1, new Gtk::VBox(0, 5),
		     0, gtkset_sensitive(my $check_cdrw = new Gtk::CheckButton(), $where_cd),
		     ),
	 	0, new Gtk::VBox(0, 5),
	 	0, gtkpack_(new Gtk::HBox(0,10),
	    	0, gtkset_sensitive(new Gtk::Label(_("Please check if you want to erase your CDRW before")), $cdrw && $where_cd),
	    	1, new Gtk::VBox(0, 5),
	    	0, gtkset_sensitive(my $check_cdrw_erase = new Gtk::CheckButton(), $cdrw && $where_cd),
		),
		0, new Gtk::VBox(0, 5),
		0, gtkpack_(new Gtk::HBox(0,10),
			0, gtkset_sensitive(new Gtk::Label(_("Please enter your CD Writer device name (ex: 0,1,0)")),  $where_cd),
			1, new Gtk::VBox(0, 5),
			0, gtkset_usize(gtkset_sensitive($cd_device_entry = new Gtk::Entry(), $where_cd), 100, 20),
		),
	 	0, new Gtk::VBox(0, 5),
	 	0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please check if you want to include install boot on your CD.")),  0),
		     1, new Gtk::VBox(0, 5),
		     0, gtkset_sensitive(my $check_cd_with_install_boot = new Gtk::CheckButton(), 0),
		     ),
	 	),
	);
    foreach ([$check_cdrw_erase, \$media_erase], [$check_cd_with_install_boot, \$cd_with_install_boot ]) {
	my $ref = $_->[1];
	gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => sub { ${$ref} = ${$ref} ? 0 : 1; })
	}
    
	gtksignal_connect(gtkset_active($check_where_cd, $where_cd), toggled => sub { 
		$where_cd = $where_cd ? 0 : 1;
		${$central_widget}->destroy();
		$current_widget->();
		if($where_cd) { 
			$next_widget = \&build_backup_cd_select_data;
		} else { 
			$next_widget = \&build_backup_cd_box;
		}
    });
    
	gtksignal_connect(gtkset_active($check_cdrw, $cdrw), toggled => sub { 
		$cdrw = $cdrw ? 0 : 1;
		${$central_widget}->destroy();
		$current_widget->();
    });
    
	if($where_cd) { 
		$next_widget = \&build_backup_cd_select_data;
	} else { 
		$next_widget = \&build_backup_cd_box;
	}
    
	$cd_device_entry->set_text( $cd_device );
    $cd_device_entry->signal_connect( 'changed', sub { 
		$cd_device = $cd_device_entry->get_text(); 
	});
    $combo_where_cd_time->entry->set_text($cd_time);
    $combo_where_cd_time->entry->signal_connect( 'changed', sub { 
		$cd_time = $combo_where_cd_time->entry->get_text()
	});	       
    fonction_env(\$box_build_backup_cd, \&build_backup_cd_box, \&build_backup_box, "");
    $up_box->show_all();
}

sub build_backup_box {
    $box2->destroy();
    my ($pix_cd_map, $pix_cd_mask) = gtkcreate_png("ic82-CD-40");
    my ($pix_hd_map, $pix_hd_mask) = gtkcreate_png("ic82-discdurwhat-40");
    my ($pix_options_map, $pix_options_mask) = gtkcreate_png("ic82-moreoption-40");

    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack_(new Gtk::VBox(0, 15),	
					1, new Gtk::VBox(0, 5),	
					1, gtksignal_connect(my $button_from_conf_file = new Gtk::Button(),
							     clicked => sub { ${$central_widget}->destroy();
									      build_backup_box_see_conf();
									  }),
					0, new Gtk::VBox(0, 5),	
# 					1, gtksignal_connect(my $button_on_cd = new Gtk::Button(), 
# 							     clicked => sub { ${$central_widget}->destroy(); 
# 									      $where_cd = 1;
# 									      build_backup_cd_box();
# 									  }),
# 					0, new Gtk::VBox(0, 5),	
					1, gtksignal_connect(my $button_see_conf = new Gtk::Button(), 
							     clicked => sub { ${$central_widget}->destroy();
									      build_backup_box_see_conf();
									  }),
					1, new Gtk::VBox(0, 5),	
					),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );

    $button_from_conf_file->add(gtkpack(new Gtk::HBox(0,10),
			      new Gtk::Pixmap($pix_hd_map, $pix_hd_mask),
			      new Gtk::Label(_("Backup Now from configuration file")),
			      new Gtk::HBox(0, 5)
			      ));
#     $button_on_cd->add(gtkpack(new Gtk::HBox(0,10),
# 			      new Gtk::Pixmap($pix_cd_map, $pix_cd_mask),
# 			      new Gtk::Label(_("Backup Now on CDROM")),
# 			      new Gtk::HBox(0, 5)
# 			      ));
    $button_see_conf->add(gtkpack(new Gtk::HBox(0,10),
			      new Gtk::Pixmap($pix_options_map, $pix_options_mask),
			      new Gtk::Label(_("View Backup Configuration.")),
			      new Gtk::HBox(0, 5)
			      ));


    button_box_restore_main();
    fonction_env(\$box2, \&build_backup_box, \&interactive_mode_box, "options");
    $up_box->show_all();    
}

################################################  INTERACTIVE  ################################################  

sub interactive_mode_box {
    $box2->destroy();

    read_conf_file();
    gtkadd($advanced_box,
		$box2 = gtkpack_(new Gtk::HBox(0, 15),	
			1, new Gtk::VBox(0, 5),	
			1, gtkpack_(new Gtk::VBox(0, 15),	
				1, new Gtk::VBox(0, 5),	
				1, gtksignal_connect(new Gtk::Button(_("Wizard Configuration")), clicked => sub { 
					${$central_widget}->destroy();
					read_conf_file();
					wizard(); 
				}),
				1, gtksignal_connect(new Gtk::Button(_("Advanced Configuration")), clicked => sub { 
					button_box_adv();
					${$central_widget}->destroy();
					advanced_box(); 
				}),
				1, gtksignal_connect(new Gtk::Button(_("Backup Now")), clicked => sub { 
					${$central_widget}->destroy();
					if ($cfg_file_exist) { 
						build_backup_box();
					} else { 
						message_noconf_box();
					}
				}),
				1, gtksignal_connect(new Gtk::Button(_("Restore")), clicked => sub {
					${$central_widget}->destroy(); 
					restore_box();
				}),
				1, new Gtk::VBox(0, 5),	
			),
			1, new Gtk::VBox(0, 5),	
		),
	);
    button_box_main();
    $custom_help = "main";
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub interactive_mode {
    $interactive = 1;
    my $box;
    $window1 = $::isEmbedded ? new Gtk::Plug ($::XID) : new Gtk::Window -toplevel;
    init Gtk;
    $window1->signal_connect (delete_event => sub { Gtk->exit(0) });
    $window1->set_position(1);
    $window1->set_title(_("Drakbackup"));
    my ($pix_u_map, $pix_u_mask) = gtkcreate_png("drakbackup.540x57");
    read_conf_file();    

    gtkadd($window1,
		gtkpack(new Gtk::VBox(0,0),
			gtkpack(gtkset_usize($up_box = new Gtk::VBox(0, 5), 540, 400),
				$box = gtkpack_(new Gtk::VBox(0, 3),
					0,  new Gtk::Pixmap($pix_u_map, $pix_u_mask),
					1, gtkpack_(new Gtk::HBox(0, 3),
				  		1, gtkpack_(new Gtk::HBox(0, 15),	
							0, new Gtk::HBox(0, 5),	
					    	1, $advanced_box = gtkpack_(new Gtk::HBox(0, 15),	
								1, $box2 = gtkpack_(new Gtk::VBox(0, 15),),
							),
					    	0, new Gtk::HBox(0, 5),	
						),
					),
					0, new Gtk::HSeparator,
					0, $button_box = gtkpack(new Gtk::VBox(0, 15),	
						$button_box_tmp = gtkpack(new Gtk::VBox(0, 0),),
					),
				),
			),
		),
	);
    interactive_mode_box();
    $custom_help = "main";
    button_box_main();
    $central_widget = \$box2;
    $window1->show_all;
    $window1->realize;
    $window1->show_all();    
    Gtk->main;
    Gtk->exit(0);
}

################################################  HELP & ABOUT  ################################################  


sub adv_help {
    my ($function, $custom_help) = @_,
    my $text = new Gtk::Text(undef, undef);
    my $advanced_box_help;

################################################  help definition ##############################################

    my %custom_helps = (
			"options" => 
			_("options description:

 In this step Drakbackup allow you to change:

 - The compression mode:
    
      If you check bzip2 compression, you will compress
      your data better than gzip (about 2-10 %).
      This option is not checked by default because
      this compression mode needs more time ( about 1000% more).
 
 - The update mode:

      This option will update your backup, but this
      option is not really useful because you need to
      decompress your backup before you can update it.
      
 - the .backupignore mode:

      Like with cvs, Drakbackup will ignore all references
      included in .backupignore files in each directories.
      ex: 
         #> cat .backupignore
         *.o
         *~
         ...
      

"), 
			"mail_pb" =>
			_("
 Some errors during sendmail are caused by 
 a bad configuration of postfix. To solve it you have to
 set myhostname or mydomain in /etc/postfix/main.cf

"),

			"what" =>
			_("options description:

 - Backup system files:
       
	This option allows you to backup your /etc directory,
	which contains all configuration files. Please be
	careful during the restore step to not overwrite:
		/etc/passwd 
		/etc/group 
		/etc/fstab

 - Backup User files: 

	This option allows you select all users that you want 
	to backup.
	To preserve disk space, it is recommended that you 
	do not include web browser's cache.

 - Backup Other files: 

	This option allows you to add more data to save.
	With the other backup it's not possible at the 
	moment to select select incremental backup.		
 
 - Incremental Backups:

	The incremental backup is the most powerful 
	option for backup. This option allows you 
	to backup all your data the first time, and 
	only the changed afterward.
	Then you will be able, during the restore
	step, to restore your data from a specified
	date.
	If you have not selected this option all
	old backups are deleted before each backup.    


"), 
			"restore" =>
			_("restore description:
 
Only the most recent date will be used ,because with incremental 
backups it is necesarry to restore one by one each older backups.

So if you don't like to restore an user please unselect all his
check box.

Otherwise, you are able to select only one of this

 - Incremental Backups:

	The incremental backup is the most powerfull 
	option to use backup, this option allow you 
	to backup all your data the first time, and 
	only the changed after.
	So you will be able during the restore
	step, to restore your data from a specified
	date.
	If you have not selected this options all
	old backups are deleted before each backup.    



"),  
			"main" =>
			_(" Copyright (C) 2001 MandrakeSoft by DUPONT Sebastien <dupont_s\@epita.fr>") .
"\n" .
_(" updates 2002 MandrakeSoft by Stew Benedict <sbenedict\@mandrakesoft.com>") .
"\n\n" .
_(" This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.") .
"\n\n                                            _____________________\n" .
_("Description:

  Drakbackup is used to backup your system.
  During the configuration you can select: 
	- System files, 
	- Users files, 
	- Other files.
	or All your system ...  and Other (like Windows Partitions)

  Drakbackup allows you to backup your system on:
	- Harddrive.
	- NFS.
	- CDROM (CDRW), DVDROM (with autoboot, rescue and autoinstall.).
	- FTP.
	- Rsync.
	- Webdav.
	- Tape.

  Drakbackup allows you to restore your system to
  a user selected directory.

  Per default all backup will be stored on your
  /var/lib/drakbackup directory

  Configuration file:
	/etc/drakconf/drakbackup/drakbakup.conf


Restore Step:
  
  During the restore step, DrakBackup will remove 
  your original directory and verify that all 
  backup files are not corrupted. It is recommended 
  you do a last backup before restoring.


"),
			"ftp" =>
			_("options description:

Please be careful when you are using ftp backup, because only 
backups that are already built are sent to the server.
So at the moment, you need to build the backup on your hard 
drive before sending it to the server.

"),
			"restore_pbs" =>
			_("
Restore Backup Problems:

During the restore step, Drakbackup will verify all your
backup files before restoring them.
Before the restore, Drakbackup will remove 
your original directory, and you will loose all your 
data. It is important to be careful and not modify the 
backup data files by hand.
")
);

    my $default_help = _(" Copyright (C) 2001 MandrakeSoft by DUPONT Sebastien <dupont_s\@epita.fr>") .
"\n" . 
_(" updates 2002 MandrakeSoft by Stew Benedict <sbenedict\@mandrakesoft.com>") .
"\n\n" .
_(" This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.") .
"\n\n                                            _____________________\n" .
_("Description:

  Drakbackup is used to backup your system.
  During the configuration you can select 
	- System files, 
	- Users files, 
	- Other files.
	or All your system ...  and Other (like Windows Partitions)

  Drakbackup allows you to backup your system on:
	- Harddrive.
	- NFS.
	- CDROM (CDRW), DVDROM (with autoboot, rescue and autoinstall.).
	- FTP.
	- Rsync.
	- Webdav.
	- Tape.

  Drakbackup allows you to restore your system to
  a user selected directory.

  Per default all backup will be stored on your
  /var/lib/drakbackup directory

  Configuration file:
	/etc/drakconf/drakbackup/drakbakup.conf

Restore Step:
  
  During the restore step, Drakbackup will remove
  your original directory and verify that all
  backup files are not corrupted. It is recommended
  you do a last backup before restoring.
 

");

################################################  help function ##############################################

    gtktext_insert($text, $custom_helps{$custom_help} || $default_help);
    gtkpack($advanced_box,
	    $advanced_box_help = gtkpack_(new Gtk::VBox(0,10),
					  1, gtkpack_(new Gtk::HBox(0,0),
						      1, $text, 
						      0, new Gtk::VScrollbar($text->vadj),
						      ),
					  0, gtkadd(gtkset_layout(new Gtk::HButtonBox, -spread),
						    gtksignal_connect(new Gtk::Button(_("OK")), clicked => sub { 
							${$central_widget}->destroy(); $function->();}),
						    ),
					  )
	    );
    $central_widget = \$advanced_box_help;
    $up_box->show_all();
}

sub to_ok {
    $sav_next_widget = $next_widget;
    $next_widget = undef;
    button_box_wizard();
}

sub to_normal {
    $next_widget = $sav_next_widget;
}
