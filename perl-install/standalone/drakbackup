#!/usr/bin/perl
#
# Copyright (C) 2001 by Sebastien DUPONT <sdupont@mandrakesoft.com>
# Redistribution of this file is permitted under the terms of the GNU
# Public License (GPL)
## description:
#
#  Drakbacup is use to backup system files and user files
#  Drakbacup allow to restore the system (etc, var files)
#  from starup or on drakconf utility.
#
#backup name format: all the time from the /
#                    backup_sys_12102001.tar.gz                    -> default system backup
#		     backup_sys_etc_var_proc_12102001.tar.gz       -> specific system directories
#		     backup_user_james_12102001.tar.gz             -> default user backup
#		     backup_user_james_documents_12102001.tar.gz   -> specific user directories
#                    backup_other_proc_12102001.tar.gz             -> specific other directories
#
# backup name rules: system: begin by sys
#                    user:   begin by user
#                    other:   begin by other
#                    end of all `date`.tar.gz
#
# seems to be good idea to have a txt file where user explain the differences
# between all the backup
#
# save only the differences...
#
# find / -mtime -1 \! -type d -print > /tmp/liste.jour
# build iso fs with rescue.
# configuration file on /etc/drakconf/drakbackup/drakbakup.conf
# perl -ne 'split(":");print "$_[0]:*:$_[2]:$_[3]:::\n";' /etc/passwd > passwd 
#
#
# TODO:
#	icon for cdrom.
#	wizard step.
#	implement all advanced.




use Gtk;
use lib qw(/usr/lib/libDrakX );
use interactive;
use standalone;
use my_gtk qw(:helpers :wrappers);
use common;
use strict;

my $in = 'interactive'->vnew('', 'default');
!$::isEmbedded && $in->isa('interactive_gtk') and $::isWizard=1;


if ("@ARGV" =~ /--help|-h/) {
    print q(Backup and monitoring application

--list           : list of files or directories to backup.
--default        : save default directories.
--build_cd       : build restore iso with the currents backups files
                       & rescue options.
--build_floppy   : build restore floppy.
--replace        : delete backup files before build new do not update.
--save_dir       : by default the backup files are saved in 
                       in /var/backup directory so write other directory
	               to change to change it.
--conf_file      : to read other configuration file. 
--mdk_cc	 : to include on Mandrake Control Center
);
    exit(0);
}

# Backend Options.
my $default = 0;
my $build_cd = 0;
my $build_floppy = 0;
my $mode = 0;
my $conf_file = 0;
my @list_arg = ();
my $windows = 0;
my $central_widget;
my $central_widget_save;
my $interactive;
my $up_box;
my $box;
my $backup_choice = 0;
my $cfg_file_exist = 0;
my @user_and_path_list;
my @user_list;
my $list_other;
my @list_other;
my $mdk_cc = 0;
my $DEBUG = 0;

my $backup_sys;# = 1;



# config. FILES ->  PATH  & Global variables.
my @sys_files = ("/etc");
my @home_files;
my @other_files = ("/var/www") ;
my $cfg_file = "/etc/drakxtools/drakbackup/drakbackup.conf";
my $save_path = "/var/drakbackup";
my $option_replace = 0;
my $comp_mode = 0;
my $backup_mode = 0; 

foreach (@ARGV) {
    /--default/ and $default = 1, $mode=-1;
    /--build_cd/ and $build_cd = 1, $mode=-1;
    /--build_floppy/ and $build_floppy = 1, $mode=-1;
    /--replace|-r/ and $option_replace = 1, $mode=-1;
    /--conf_file/ and $mode = 0, next;
    /--list/ and $mode = 1, next;
    /--mdk_cc/ and $mdk_cc = 1, next;
    /--debug/ and $DEBUG = 1, next;
    $mode == 1 and push @list_arg, $_;
}

sub debug {
    print "SYS_FILES: $_ \n" foreach (@sys_files);
    print "HOME_FILES: $_ \n" foreach (@home_files);
    print "OTHER_FILES: $_ \n" foreach (@other_files);
    print "PATH_TO_SAVE: $save_path \n";
    print "OPTION_REPLACE: $option_replace \n";
    print "OPTION_COMP: $comp_mode \n";
}

# initial functions
#read_conf_file();

sub read_passwd {
    @user_and_path_list = map { (split(':', $_))[0] . ":" . (split(':', $_))[5] } grep {( split(':', $_))[2] > 500} split ('\n', cat_('/etc/passwd'));  
    $DEBUG and print "user_and_path_list: ".$_."\n" foreach (@user_and_path_list);
    @home_files = ();
    @user_list = ();
    push @home_files, (split(':', $_))[1] foreach (@user_and_path_list);
    push @user_list, (split(':', $_))[0] foreach (@user_and_path_list);
    $DEBUG and print "home_files: ".$_."\n" foreach (@home_files);
}

sub save_conf_file {
    my @cfg_list = ( "SYS_FILES=@sys_files\n",
		     "HOME_FILES=@home_files\n", 
		     "OTHER_FILES=@other_files\n",
		     "PATH_TO_SAVE=$save_path\n",
		     );
    $option_replace and push @cfg_list, "OPTION_REPLACE\n" ;
    $backup_sys or push @cfg_list,  "NO_SYS_FILES\n";
    if ($comp_mode) {
	push @cfg_list, "OPTION_COMP=TAR.BZ2\n";
    } else {
	push @cfg_list, "OPTION_COMP=TAR.GZ\n";
    }
    print "before save : $backup_sys \n";
    output_p( $cfg_file, @cfg_list);
}

sub read_conf_file {
    read_passwd();
    if (-e $cfg_file) {
        open ( CONF_FILE, "<"."$cfg_file") || die;
        while (<CONF_FILE>) {
	    next unless /\S/;
	    next if /^#/;
	    chomp;
	    if (/^SYS_FILES/)      { s/^SYS_FILES=//gi;    @sys_files = split(' ', $_ );	}
	    if (/^HOME_FILES/)     { s/^HOME_FILES=//gi;   @home_files = split(' ', $_ );	}
	    if (/^OTHER_FILES/)    { s/^OTHER_FILES=//gi;  @other_files = split(' ', $_ );	}
	    if (/^PATH_TO_SAVE/)   { s/^PATH_TO_SAVE=//gi; $save_path = $_;	}
	    if (/^OPTION_REPLACE/) { $option_replace = 1; }
	    if (/^NO_SYS_FILES/)   { $backup_sys = 0;}
	    if (/^OPTION_COMP/)    { s/^OPTION_COMP=//gi; /TAR.GZ/ and  $comp_mode = 0; /TAR.BZ2/ and $comp_mode = 1; }
	    unless (/^NO_SYS_FILES/)   { $backup_sys = 1;}
	}
	$cfg_file_exist = 1;
    } else {
	$cfg_file_exist = 0;
	print "no exist\n";
    }
    close CONF_FILE;    
    $DEBUG and debug; 
}

# sub read_conf_file {
#     read_passwd();
#     if (-e $cfg_file) {
# 	while (cat_ ('$cfg_file')) {
# 	    next unless /\S/;
# 	    next if /^#/;
# 	    chomp;
# 	    if (/^SYS_FILES/)      { s/^SYS_FILES=//gi;    @sys_files = split(' ', $_ );	}
# 	    if (/^HOME_FILES/)     { s/^HOME_FILES=//gi;   @home_files = split(' ', $_ );	}
# 	    if (/^OTHER_FILES/)    { s/^OTHER_FILES=//gi;  @other_files = split(' ', $_ );	}
# 	    if (/^PATH_TO_SAVE/)   { s/^PATH_TO_SAVE=//gi; $save_path = $_;	}
# 	    if (/^OPTION_REPLACE/) { $option_replace = 1; }
# 	    if (/^NO_SYS_FILES/)   { $backup_sys = 0; print "I see NO_SYS_FILES\n"; }
# 	    if (/^OPTION_COMP/)    { s/^OPTION_COMP=//gi; /TAR.GZ/ and  $comp_mode = 0; /TAR.BZ2/ and $comp_mode = 1; }
# 	    unless (/^NO_SYS_FILES/)   { $backup_sys = 1; print "I NO see NO_SYS_FILES\n"; }
# 	}
# 	$cfg_file_exist = 1;
#     } else {
# 	$cfg_file_exist = 0;
# 	print "no exist\n";
#     }    
# #    $DEBUG and debug; 
# }



if ($mdk_cc) { $build_floppy || $build_cd || $default || @list_arg || $conf_file ? backend_mod() : interactive_mode();
	   } else { $build_floppy || $build_cd || $default || @list_arg || $conf_file ? backend_mod() : interactive_mode_my(); }


sub backend_mod {

}

sub build_cd_fct {

}

sub build_floppy_fct {

}

sub build_backup_files {

}

sub interactive_mode {
    $interactive = 1;
    my $box_cfg_state;
    my $box_cgf_state_replace;
    my $box_cgf_state_comp;
    my $mask;
    my $style;
    my $box;
    init Gtk;
    my $text2 = new Gtk::Text(undef, undef);
    my $window1 = $::isEmbedded ? new Gtk::Plug ($::XID) : new Gtk::Window -toplevel;
    $window1->signal_connect (delete_event => sub { Gtk->exit(0) });
    $window1->set_position(1);
    $window1->set_title(_("Drakbackup"));

    read_conf_file();    
    if ($option_replace) { $box_cgf_state_replace = _("Replace backups (do not update)"),
    } else { $box_cgf_state_replace = _("Update backups (do not replace)"),  }

    if ($comp_mode) { $box_cgf_state_comp = _("Backups use tar and gunzip "),
    } else { $box_cgf_state_comp = _("Backups use tar and gunzip"),   }
	
    if ($cfg_file_exist) { 
	my $label_cfg_file = new Gtk::Label _("Backup Sources: \n-System Files: @sys_files \n-Users Files: @home_files\n-Other Files to backup: @other_files\nPath to save backups: $save_path\nOptions:\n$box_cgf_state_replace\n$box_cgf_state_comp\n\n");
	$box_cfg_state =  gtkpack(new Gtk::VBox( 0, 0),
				  gtkset_justify( $label_cfg_file , 'left'),
				  ),
    } else { $box_cfg_state =  gtkpack(new Gtk::VBox(0,1),
				       _("No configuration please click Wizard or Advanced.") ), }

    gtkadd($window1,
	   gtkpack(new Gtk::VBox(0,0),
		   gtkpack(gtkset_usize($up_box = new Gtk::VBox(0,5), 500, 350),
			   $box = gtkpack_(new Gtk::VBox(0,3),
					   0, _("Welcome on DrakBackup"),
					   1, gtkadd(new Gtk::Frame(_("State of configuration file.")),
						      gtkpack(new Gtk::VBox(0,10),
							      $box_cfg_state,
							      ),
						     ),
					   0, gtkpack_(new Gtk::HBox(0, 0),
						       0, gtksignal_connect(new Gtk::Button(_(" Build Backup ")), 
									    clicked => sub { save_conf_file(); Gtk->main_quit() }),
						       ),
					   0, gtkpack_(new Gtk::HBox(0, 0),
						       0, gtksignal_connect(new Gtk::Button(_("     Restore      ")), 
									    clicked => sub { save_conf_file(); Gtk->main_quit() }),
						       ),
					   0, new Gtk::HSeparator,
					   0, gtkpack_(gtkset_layout(new Gtk::HButtonBox, -end),
						       1, gtksignal_connect(new Gtk::Button(_("Advanced Conf.")), clicked => 
									    sub { ${$central_widget}->destroy(); advanced() }),
						       1, gtksignal_connect(new Gtk::Button(_("Wizard Conf.")), clicked => 
									    sub { ${$central_widget}->destroy(); wizard() }),
						       1, gtksignal_connect(new Gtk::Button(_("close")), clicked => 
									    sub { save_conf_file(); Gtk->main_quit() }),
						       ),
					   ),
			   ),
		   ),
	   );
    $central_widget = \$box;
    $window1->show_all;
    $window1->realize;
    $window1->show_all();    
    Gtk->main;
    Gtk->exit(0);
}



sub list_remove {
    my($widget, $list) = @_;
    my @to_remove;
    push @to_remove, $list->child_position($_) foreach($list->selection);
    splice @list_other, $_, 1 foreach(reverse sort @to_remove);
    $list->remove_items($list->selection);
}


sub file_ok_sel { 
    my ( $widget, $file_selection ) = @_;     
    my $file_name = $file_selection->get_filename();
 #   print "-- @install\n";
    if(!member($file_name, @list_other)) {
	push(@list_other, $file_name);
	$list_other->add(gtkshow(new Gtk::ListItem($file_name)));
    }
}

sub  filedialog {
    my $file_dialog;

    $file_dialog = gtksignal_connect(new Gtk::FileSelection(_("File Selection")), destroy => sub { $file_dialog->destroy(); } );
    $file_dialog->ok_button->signal_connect(clicked => \&file_ok_sel, $file_dialog);
    $file_dialog->ok_button->child->set(_("Add"));
    $file_dialog->cancel_button->signal_connect(clicked => sub { $file_dialog->destroy() });
    $file_dialog->cancel_button->child->set(_("Close"));
    $file_dialog->set_filename(_("Select the files or directories and click on 'Add'"));
    $file_dialog->show();
}



sub wizard {
    my $user = 1;
    my $user2;
#    map { my (user.$_)} (@user_list);
    my $text;

  begin: 
    $::isWizard=1;

 step_what_backup:
   $::Wizard_no_previous = 1;
    $in->ask_from(_("Please choose that you want to backup"),
  	          (_("Please choose that you want to backup") . "\n\n") .
	          $text,
		  [ 
		    { label => _("System Files"), val => \$user, type => "bool", text => _("  all files on your /etc directory.") },
		    map { { label => _("$_"), val => \$user, type => "bool", text => _("all data contained on $_ directory") } } @user_list,
		    ],
		  );
    

   my $r = $in->ask_from_list_(_("Backup Configuration wizard"),
				_("Please choose what you need to backup from your system"),
				[ __("Hard Drive or NFS file system"), __("Mandrake Online"), __("on CDROM") ]) 
	or quit_global($in, 0);
     

    $in->ask_from(_("Backup Configuration wizard"),
  	          (_("Please choose when you want to backup") . "\n\n") .
	          $text,
		  [ 
		    { label => _("Daemon"), val => \$user, type => "bool", text => _(" Select it if you want that backup run as daemon") },
		    ],
		  );

    $in->ask_from(_("Backup Configuration wizard"),
  	          (_("Please choose that you want to do") . "\n\n") .
	          $text,
		  [ 
		    { label => _("Build Auto-Boot CDROM"), val => \$user, type => "bool", text => _("this option work only if you have a CDR-W CDROM drive\n This options allow you to restore all\n your system (data and your system variables)") },
		    ],
		  );
} 


sub advanced {
    my $notebook; 
    my $notebook_what; 
    my $notebook_when; 
    my $notebook_where; 
    my $notebook_options; 
    my $about_box;
    my $book_open;
    my $book_open_mask;
    my $transparent;
    my $book_closed;
    my $book_closed_mask;
    my $box_tmp;    
    $list_other = new Gtk::List();
    $list_other->set_selection_mode(-extended);

    read_conf_file();


    my ($pix_net_map, $pix_net_mask) = gtkcreate_png("../pixmaps/backup_net.png");
    my ($pix_hd_map, $pix_hd_mask) = gtkcreate_png("../pixmaps/backup_hd.png");
    my ($pix_time_map, $pix_time_mask) = gtkcreate_png("../pixmaps/backup_time.png");
    my ($pix_user_map, $pix_user_mask) = gtkcreate_png("../pixmaps/user.png");
    my ($pix_sys_map, $pix_sys_mask) = gtkcreate_png("../pixmaps/bootloader.png");
    my ($pix_other_map, $pix_other_mask) = gtkcreate_png("../pixmaps/net_u.png");
    my ($pix_options_map, $pix_options_mask) = gtkcreate_png("../pixmaps/backup_options.png");

    my $label_what = gtkpack(new Gtk::VBox( 0, 2),
			 new Gtk::Pixmap($pix_hd_map, $pix_hd_mask),
			 _("What backup.")
			 );
    my $label_where = gtkpack(new Gtk::VBox( 0, 2),
			 new Gtk::Pixmap($pix_net_map, $pix_net_mask),
			 _("Where backup.")
			 );
    my $label_when = gtkpack(new Gtk::VBox( 0, 2),
			 new Gtk::Pixmap($pix_time_map, $pix_time_mask),
			 _("When backup.")
			 );

    my $label_options = gtkpack(new Gtk::VBox( 0, 2),
			 new Gtk::Pixmap($pix_options_map, $pix_options_mask),
			 _("Options")
			 );

    my $label_what_sys = gtkpack(new Gtk::HBox( 0, 2),
			 new Gtk::Pixmap($pix_sys_map, $pix_sys_mask),
			 _("System", " ")
			 );
    my $label_what_user = gtkpack(new Gtk::HBox( 0, 2),
			 new Gtk::Pixmap($pix_user_map, $pix_user_mask),
			 _("Users", " ")
			 );

    my $label_what_other = gtkpack(new Gtk::HBox( 0, 2),
			 new Gtk::Pixmap($pix_other_map, $pix_other_mask),
			 _("Other", " ")
			 ); 

    my $label_where_network = gtkpack(new Gtk::HBox( 0, 2),
			 new Gtk::Pixmap($pix_net_map, $pix_net_mask),
			 _(" Network & \n MandrakeOnline ")
			 );

    my $label_where_cd = gtkpack(new Gtk::HBox( 0, 2),
			 new Gtk::Pixmap($pix_net_map, $pix_net_mask),
			 _(" Hard Drive ")
			 );

    my $label_where_hd = gtkpack(new Gtk::HBox( 0, 2),
			 new Gtk::Pixmap($pix_net_map, $pix_net_mask),
			 _(" CDROM ")
			 );

    my $box_what_sys =  gtkpack_(new Gtk::VBox(0,1),
				 1, _("\nPlease check all options that you need.\n"),
#gtkset_active
				 0, gtksignal_connect(gtkset_active(new Gtk::CheckButton( _(" Backup your System files. (~ 10Mo)")), 0) , clicked => sub { print "on affiche le check valeur :$backup_sys \n"; $backup_sys = $backup_sys ? 0 : 1; print "backup sys value__ : $backup_sys\n"; }),
				 0, gtkset_active(new Gtk::CheckButton( _(" Need to restore any versions (CVS)") ), 1),
				 1, _("With this option you will be able to restore any version\n of your /etc directory like in CVS this solution seems to be\n more interesting because it allow you to restore at any\n moment any vercions of your /etc"),
				 );
    
    my $box_what_user =  gtkpack_(new Gtk::VBox(0,0),
				  0, _("Please check all user that you want to include inb your backup."),
				  0, new Gtk::HSeparator,
				  1, createScrolledWindow( gtkpack(new Gtk::VBox(0,0),
								   new Gtk::CheckButton("root"),
								   map {new Gtk::CheckButton("$_") } (@user_list) 
								   ),
							   ),
				  0, new Gtk::HSeparator,
				  0, new Gtk::CheckButton( _(" do not include the browser cache") ),
				  );

    my $box_what_other =  gtkpack_(new Gtk::VBox(0,10),
				   1, gtkpack_(new Gtk::HBox(0,4),
					       1, createScrolledWindow($list_other),
					       ),
				   0, gtkadd(gtkset_layout(new Gtk::HButtonBox, -spread),
					     gtksignal_connect(new Gtk::Button(_("Add")), clicked => sub {filedialog()  }),
 					     gtksignal_connect(new Gtk::Button(_("Remove Selected")), clicked => \&list_remove, $list_other),
					     ),
				   );
    
    my $box_where_mdkonline =  gtkpack_(new Gtk::VBox(0,1),
					1, _("\nPlease check all options that you need.\n"),
					0, new Gtk::CheckButton( _(" Backup your System files. (~ 10Mo)") ),
					0, new Gtk::CheckButton( _(" Need to restore any versions (CVS)") ),
					);
    
    my $box_where_hd =  gtkpack_(new Gtk::VBox(0,1),
				 1, _("\nPlease check all options that you need.\n"),
				 0, new Gtk::CheckButton( _(" Backup your System files. (~ 10Mo)") ),
				 0, new Gtk::CheckButton( _(" Need to restore any versions (CVS)") ),
				 );
    
    my $box_where_cd =  gtkpack_(new Gtk::VBox(0,1),
				 1, _("\nPlease check all options that you need.\n"),
				 0, new Gtk::CheckButton( _(" Backup your System files. (~ 10Mo)") ),
				 0, new Gtk::CheckButton( _(" Need to restore any versions (CVS)") ),
				 );
	       
    my $box_what = gtkpack(new Gtk::VBox(0,1),
			   $notebook_what = new Gtk::Notebook,
			   $notebook_what->insert_page( $box_what_sys, $label_what_sys, 0),
			   $notebook_what->insert_page( $box_what_user, $label_what_user, 1),
			   $notebook_what->insert_page( $box_what_other, $label_what_other, 2),
			   $notebook_what->set_scrollable(1),
			   );

    my $box_where =  gtkpack(new Gtk::VBox(0,1),
 			$notebook_where = new Gtk::Notebook,
			$notebook_where->insert_page( $box_where_mdkonline, $label_where_network, 0 ),
			$notebook_where->insert_page( $box_where_hd, $label_where_hd, 1 ),
			$notebook_where->insert_page( $box_where_cd, $label_where_cd, 1 ),
			);
    my $box_when =  gtkpack(new Gtk::VBox(0,1),
 			$notebook_when = new Gtk::Notebook,
# 			$notebook_when->insert_page( _("toto") , "titi", 0 ),
			);
    my $box_options =  gtkpack(new Gtk::VBox(0,1),
			$notebook_options = new Gtk::Notebook,
 #			$notebook_options->insert_page( _("toto") , "titi", 0 ),
			);

    gtkpack($up_box,
	    $about_box = gtkpack_(new Gtk::VBox(0,10),
				  1, gtkpack(new Gtk::HBox(0,0),
					     gtkpack(my $notebook_box = new Gtk::VBox(0,5),
						     $notebook = new Gtk::Notebook,
						     $notebook->insert_page( $box_what, $label_what, 0),
						     $notebook->insert_page( $box_where, $label_where, 1),
						     $notebook->insert_page( $box_when, $label_when, 2),
						     $notebook->insert_page( $box_options, $label_options, 3),
						     $notebook->set_scrollable( 1 )
							 ),
					     ),
				  0, gtkadd(new Gtk::HButtonBox,
					    gtksignal_connect(new Gtk::Button(_("Close")), clicked => 
							      sub { save_conf_file();
								    ${$central_widget}->destroy(); 
								    $mdk_cc and interactive_mode();
								    $mdk_cc or interactive_mode_my();
								}),
					    gtksignal_connect(new Gtk::Button(_("Help")), clicked => 
							      sub { save_conf_file(); ${$central_widget}->destroy(); adv_help() }),
					    gtksignal_connect(new Gtk::Button(_("Ok")), clicked => sub { 
						save_conf_file(); ${$central_widget}->destroy(); after_adv();    }),
					    ),				  
				  ),
	    ),
    my %rotate = (
		  top => "right",
		  right => "bottom",
		  bottom => "left",
		  left => "top"
		  );
    $notebook->set_tab_pos( $rotate{ $notebook->tab_pos } );
    $central_widget = \$about_box;
    $up_box->show_all();
}


sub interactive_mode_my {
    $interactive = 1;
    my $box_cfg_state;
    my $box_cgf_state_replace;
    my $box_cgf_state_comp;
    my $mask;
    my $style;
    my $box;
    init Gtk;
    my $box_cgf_state_sys = ("");
    my $text2 = new Gtk::Text(undef, undef);
    my $window1 = $::isEmbedded ? new Gtk::Plug ($::XID) : new Gtk::Window -toplevel;
    $window1->signal_connect (delete_event => sub { Gtk->exit(0) });
    $window1->set_position(1);
    $window1->set_title(_("Drakbackup"));

    my ($pix_u_map, $pix_u_mask) = gtkcreate_png("../pixmaps/backup_title.png");
    my ($pix_l_map, $pix_l_mask) = gtkcreate_png("../pixmaps/backup_left.png");
    my ($pix_r_map, $pix_r_mask) = gtkcreate_png("../pixmaps/backup_bot.png");

    read_conf_file();    
    $backup_sys or $box_cgf_state_sys = _("Do not include System Files");

    if ($option_replace) { $box_cgf_state_replace = _("Replace backups (do not update)"),
    } else { $box_cgf_state_replace = _("Update backups (do not replace)"),  }

    if ($comp_mode) { $box_cgf_state_comp = _("Backups use tar and gunzip "),
    } else { $box_cgf_state_comp = _("Backups use tar and gunzip"),   }
	
    if ($cfg_file_exist) { 
	my $label_cfg_file = new Gtk::Label _("Backup Sources: \n-System Files: @sys_files \n-Users Files: @home_files\n-Other Files to backup: @other_files\nPath to save backups: $save_path\nOptions:\n$box_cgf_state_replace\n$box_cgf_state_comp\n$box_cgf_state_sys\n");
	$box_cfg_state =  gtkpack(new Gtk::VBox( 0, 0),
				  gtkset_justify( $label_cfg_file , 'left'),
				  ),
    } else { $box_cfg_state =  gtkpack(new Gtk::VBox(0,1),
				       _("No configuration please click Wizard or Advanced.") ), }

    gtkadd($window1,
	   gtkpack(new Gtk::VBox(0,0),
		   gtkpack(gtkset_usize($up_box = new Gtk::VBox(0, 5), 500, 420),
			   $box = gtkpack_(new Gtk::VBox(0, 3),
					   0, new Gtk::Pixmap($pix_u_map, $pix_u_mask),
					   1, gtkpack_(new Gtk::HBox(0, 3),
						       0, new Gtk::Pixmap($pix_l_map, $pix_l_mask), 
						       1, createScrolledWindow( gtkpack(new Gtk::VBox(0,0),
									 gtkadd(new Gtk::Frame(_("State of configuration file.")),
										gtkpack(new Gtk::VBox(0,10),
											$box_cfg_state,
											),),),),),
					   0, gtkpack_(new Gtk::HBox(0, 0),
						       0, new Gtk::Pixmap($pix_r_map, $pix_r_mask),
						       1, gtkpack_(new Gtk::VBox(0, 1),	
								   1, gtksignal_connect(new Gtk::Button(_(" Build Backup ")), 
										  clicked => sub {  Gtk->main_quit() }),
							       1, gtksignal_connect(new Gtk::Button(_("     Restore      ")), 
										  clicked => sub {  Gtk->main_quit() }),
								   ),
						       ),
					   0, new Gtk::HSeparator,
					   0, new Gtk::HSeparator,
					   0, gtkpack_(gtkset_layout(new Gtk::HButtonBox, -end),
						       1, gtksignal_connect(new Gtk::Button(_("Advanced Conf.")), clicked => 
									    sub { ${$central_widget}->destroy(); advanced() }),
						       1, gtksignal_connect(new Gtk::Button(_("Wizard Conf.")), clicked => 
									    sub { ${$central_widget}->destroy(); wizard() }),
						       1, gtksignal_connect(new Gtk::Button(_("close")), clicked => 
									    sub {  Gtk->main_quit() }),
						       ),
					   ),
			   ),
		   ),
	   );
    $central_widget = \$box;
    $window1->show_all;
    $window1->realize;
    $window1->show_all();    
    Gtk->main;
    Gtk->exit(0);
}


sub after_adv {
    $interactive = 1;
    my $box_cfg_state;
    my $box_cgf_state_replace;
    my $box_cgf_state_comp;
    my $mask;
    my $style;
    my $box_cgf_state_sys;
    my $box;
    init Gtk;
    my $text2 = new Gtk::Text(undef, undef);
    my $window1 = $::isEmbedded ? new Gtk::Plug ($::XID) : new Gtk::Window -toplevel;
    $window1->signal_connect (delete_event => sub { Gtk->exit(0) });
    $window1->set_position(1);
    $window1->set_title(_("Drakbackup"));

    my ($pix_u_map, $pix_u_mask) = gtkcreate_png("../pixmaps/backup_title.png");
    my ($pix_l_map, $pix_l_mask) = gtkcreate_png("../pixmaps/backup_left.png");
    my ($pix_r_map, $pix_r_mask) = gtkcreate_png("../pixmaps/backup_bot.png");

    read_conf_file();    
    $backup_sys or $box_cgf_state_sys = _("Do not include System Files");
    if ($option_replace) { $box_cgf_state_replace = _("Replace backups (do not update)"),
    } else { $box_cgf_state_replace = _("Update backups (do not replace)"),  }

    if ($comp_mode) { $box_cgf_state_comp = _("Backups use tar and gunzip "),
    } else { $box_cgf_state_comp = _("Backups use tar and gunzip"),   }
	
    if ($cfg_file_exist) { 
	my $label_cfg_file = new Gtk::Label _("Backup Sources: \n-System Files: @sys_files \n-Users Files: @home_files\n-Other Files to backup: @other_files\nPath to save backups: $save_path\nOptions:\n$box_cgf_state_replace\n$box_cgf_state_comp\n$box_cgf_state_sys\n");
	$box_cfg_state =  gtkpack(new Gtk::VBox( 0, 0),
				  gtkset_justify( $label_cfg_file , 'left'),
				  ),
    } else { $box_cfg_state =  gtkpack(new Gtk::VBox(0,1),
				       _("No configuration please click Wizard or Advanced.") ), }

    gtkadd($window1,
	   gtkpack(new Gtk::VBox(0,0),
		   gtkpack(gtkset_usize($up_box = new Gtk::VBox(0, 5), 500, 420),
			   $box = gtkpack_(new Gtk::VBox(0, 3),
					   0, new Gtk::Pixmap($pix_u_map, $pix_u_mask),
					   1, gtkpack_(new Gtk::HBox(0, 3),
						       0, new Gtk::Pixmap($pix_l_map, $pix_l_mask), 
						       1, createScrolledWindow( gtkpack(new Gtk::VBox(0,0),
									 gtkadd(new Gtk::Frame(_("State of configuration file.")),
										gtkpack(new Gtk::VBox(0,10),
											$box_cfg_state,
											),),),),),
					   0, gtkpack_(new Gtk::HBox(0, 0),
						       0, new Gtk::Pixmap($pix_r_map, $pix_r_mask),
						       1, gtkpack_(new Gtk::VBox(0, 1),	
							       1, gtksignal_connect(new Gtk::Button(_(" Build Backup ")), 
										  clicked => sub { Gtk->main_quit() }),
							       1, gtksignal_connect(new Gtk::Button(_("     Restore      ")), 
										  clicked => sub { Gtk->main_quit() }),
								   ),
						       ),
					   0, new Gtk::HSeparator,
					   0, new Gtk::HSeparator,
					   0, gtkpack_(gtkset_layout(new Gtk::HButtonBox, -end),
						       1, gtksignal_connect(new Gtk::Button(_("Advanced Conf.")), clicked => 
									    sub { ${$central_widget}->destroy(); advanced() }),
						       1, gtksignal_connect(new Gtk::Button(_("Wizard Conf.")), clicked => 
									    sub { ${$central_widget}->destroy(); wizard() }),
						       1, gtksignal_connect(new Gtk::Button(_("close")), clicked => 
									    sub { Gtk->main_quit() }),
						       ),
					   ),
			   ),
		   ),
	   );
    $central_widget = \$box;
    $window1->show_all;
    $window1->realize;
    $window1->show_all();    
    Gtk->main;
    Gtk->exit(0);
}


sub about {
    my $text = new Gtk::Text(undef, undef);
    my $about_box;
    gtkpack($up_box,
	    $about_box = gtkpack_(new Gtk::VBox(0,10),
				  1, gtkpack_(new Gtk::HBox(0,0),
					      1, gtktext_insert(gtkset_editable($text, 1), _("
 Copyright (C) 2001 by MandrakeSoft (sdupont\@mandrakesoft.com)

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

")),
					      0, new Gtk::VScrollbar($text->vadj),
					      ),
				  0, gtkadd(gtkset_layout(new Gtk::HButtonBox, -spread),
					    gtksignal_connect(new Gtk::Button(_("OK")), clicked => 
							      sub { ${$central_widget}->destroy(); 
								    $mdk_cc and interactive_mode();
								    $mdk_cc or interactive_mode_my();
								}),
					    ),
				  )
	    );
    $central_widget = \$about_box;
    $up_box->show_all();
}


sub adv_help {
    my $text = new Gtk::Text(undef, undef);
    my $about_box;
    gtkpack($up_box,
	    $about_box = gtkpack_(new Gtk::VBox(0,10),
				  1, gtkpack_(new Gtk::HBox(0,0),
					      1, gtktext_insert(gtkset_editable($text, 1), _("
description:

 Drakbacup is use to backup system files and user files
 Drakbacup allow to restore the system (etc, var files)
 from starup or on drakconf utility.

backup name format: all the time from the / dir.

	system backup:
                   backup_sys_12102001.tar.gz 
		   backup_sys_etc_var_proc_12102001.tar.gz
	user backup
		   backup_user_james_12102001.tar.gz      
		   backup_user_james_documents_12102001.tar.gz
	other directories
                   backup_other_proc_12102001.tar.gz          

backup name rules: system:   begin by sys
                   user:     begin by user
                   other:    begin by other
                   end of all `date`.tar.gz


save only the differences...
find / -mtime -1 \! -type d -print > /tmp/liste.jour

build iso fs with rescue.

configuration file:

	/etc/drakconf/drakbackup/drakbakup.conf


")),
					      0, new Gtk::VScrollbar($text->vadj),
					      ),
				  0, gtkadd(gtkset_layout(new Gtk::HButtonBox, -spread),
					    gtksignal_connect(new Gtk::Button(_("OK")), clicked => 
							      sub { ${$central_widget}->destroy(); advanced();  }),
					    ),
				  )
	    );
    $central_widget = \$about_box;
    $up_box->show_all();
}



# sub interactive_mode_my {
#     $interactive = 1;
#     my $mask;
#     my $style;
#     my $box;
#     init Gtk;
#     my $text2 = new Gtk::Text(undef, undef);
#     my $window1 = $::isEmbedded ? new Gtk::Plug ($::XID) : new Gtk::Window -toplevel;
#     $window1->signal_connect (delete_event => sub { Gtk->exit(0) });
#     $window1->set_position(1);
#     $window1->set_title(_("Drakbackup"));

#     my ($pix_u_map, $pix_u_mask) = gtkcreate_png("../pixmaps/backup_title.png");
#     my ($pix_l_map, $pix_l_mask) = gtkcreate_png("../pixmaps/backup_left.png");
#     my ($pix_r_map, $pix_r_mask) = gtkcreate_png("../pixmaps/backup_bot.png");
#     my ($pix_hd_map, $pix_hd_mask) = gtkcreate_png("../pixmaps/backup_hd.png");

#     my $box2 = new Gtk::VBox( 0, 10 );

#     my $label3 = gtkpack(new Gtk::HBox(0,10),
# 			 new Gtk::Pixmap($pix_hd_map, $pix_hd_mask),
# 			 _("Backup Wizard")
# 			 );

#     my $radio1 = new Gtk::RadioButton( "  Backup Wizard");
#     $box2->add( $radio1);
#     $radio1->set_active(1);
#     my $radio2 = new Gtk::RadioButton( "  Backup Advanced", $radio1);
#     $box2->add( $radio2);
#     my $radio3 = new Gtk::RadioButton( "  Build Backup now", $radio2);
#     $box2->add( $radio3);
#     my $radio4 = new Gtk::RadioButton( "  Restore Backup", $radio3);
#     $box2->add( $radio4);
#     gtksignal_connect( $radio1, clicked => sub { $backup_choice = 0 });
#     gtksignal_connect( $radio2, clicked => sub { $backup_choice = 1 });
#     gtksignal_connect( $radio3, clicked => sub { $backup_choice = 2 });
    
#     gtkadd($window1,
# 	   gtkpack(new Gtk::VBox(0,0),
# 		    gtkpack(new Gtk::VBox(0,0),
# 			    new Gtk::Pixmap($pix_u_map, $pix_u_mask),
# 			    gtkpack_(new Gtk::HBox(0,0),
# 				     0, new Gtk::Pixmap($pix_l_map, $pix_l_mask), 
# 				     1, gtkpack($up_box = new Gtk::VBox(0,5),
# 						$box = gtkpack_(new Gtk::VBox(0,0),
# 								0, _("\n Please choose the method to configure your system backup."),
# 								1, gtkpack(new Gtk::HBox(0,20),
# 									   gtkpack(new Gtk::VBox(0,10),
# 										   new Gtk::HBox(0,15),
# 										   $box2,
# 										   new Gtk::HBox(0,5),
# 										   ),
# 									   ),
# 								1, gtkadd(gtkset_layout(new Gtk::HButtonBox, -end),
# 									  gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub {
# 									      ${$central_widget}->destroy(); help() }),
# 									  gtksignal_connect(new Gtk::Button(_("Next")), clicked => sub { 
# 									      ${$central_widget}->destroy(); 
# 									      $backup_choice == 0  and print "Wizard\n";
# 									      $backup_choice == 1  and advanced();
# 									      $backup_choice == 2  and print "now\n";
# 									  }),
# 									  ),
# 							       ),
# 						),
# 				     ),
# 			    new Gtk::Pixmap($pix_r_map, $pix_r_mask),
# 			    gtkadd(gtkset_layout(new Gtk::HButtonBox, -end),
# 				   gtksignal_connect(new Gtk::Button(_("Close")), clicked => sub { save_conf_file(); Gtk->main_quit() }),
# 				   gtksignal_connect(new Gtk::Button(_("About")), clicked => sub { $central_widget_save = $central_widget; 
# 				       ${$central_widget}->destroy(); about() }),
# 				   gtksignal_connect(new Gtk::Button(_("            Help           ")), clicked => sub { 
# 				       ${$central_widget}->destroy(); help() }),
# 				   ),
# 			    ),
# 		   ),
# 	   );
#     $central_widget = \$box;
#     $window1->show_all;
#     $window1->realize;
#     $window1->show_all();
    
#     Gtk->main;
#     Gtk->exit(0);
# }















#   step_where_backup:
#     undef $::Wizard_no_previous;
#     my $r2 = $in->ask_from_list_(_("Backup Configuration wizard"),
# 				_("Please choose how to backup your system"),
# 				[ __("Hard Drive"), __("accross the Network"), __("Burn auto boot Restore CDROM") ]) 
# 	or quit_global($in, 0);



#    print "$r AAAA \n";
#$r eq "Hard Drive" and  do something

#     my $wizard_box;
 
#     gtkpack($up_box,
# 	    new Gtk::VBox(0,10),
# 	    $wizard_box = new Gtk::FontSelection,
# 	    );
#     $central_widget = \$wizard_box;
#     $up_box->show_all();




# 							       0, gtktext_insert(gtkset_editable($text2, 0), _("Drakbackup allow you to build a backup of your system. With Drakbackup you will be able to save your backups on your Hard-disk or on CD, across the network with mandrake-online or other place, it accept ftp, sftp, scp, rsync, nfs. "),









#    my $checkbutton = new Gtk::CheckButton( "Check me please!" );
#    $checkbutton->set_usize( 100, 75 );
#    $checkbutton->show();


#     $pixmap_fst_choice = new Gtk::Notebook,
#     my $label1 = new Gtk::Label( "What backup." );
#     my $label2 = new Gtk::Label( "Where backup." );
#     my $label3 = new Gtk::Label( "When backup." );
#
#     gtkadd($window1,
# 	   gtkpack_(new Gtk::VBox(0,2),
# 		    1, gtkpack_(new Gtk::VBox(0,2),
# 				1, new Gtk::VBox(0,0),
# 				1, gtkpack(gtkset_usize($notebook_box = new Gtk::VBox(0,5),500, 350),
# 					   $notebook = new Gtk::Notebook,
# 					   $notebook->insert_page( $checkbutton, $label1, 2 ),
# 					   $notebook->insert_page( $checkbutton, $label2, 2 ),
# 					   $notebook->insert_page( $checkbutton, $label3, 2 )
# 					   ),
# 				1, new Gtk::VBox(0,0)
# 				),
# 		    0, gtkpack_(new Gtk::HBox(0,5),
# 				1, new Gtk::HBox(0,0),
# 				1, gtkadd(gtkset_layout(new Gtk::HButtonBox, -end),
# 					  gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub { 
# 					       ${$central_widget}->destroy(); help() }),
# 					  gtksignal_connect(new Gtk::Button(_("About")), clicked => sub { 
# 					       ${$central_widget}->destroy(); help() }),
# 					  gtksignal_connect(new Gtk::Button(_("Close")), clicked => sub { Gtk->main_quit() }),
# 					  ),
# 				)
# 		    ),
# 	   );

#________________________________________________________________________________________________________


#				0, _("DrakFont"),
#				0, gtkadd(gtkset_layout(new Gtk::VButtonBox, -end),
# 					  gtksignal_connect(new Gtk::Button(_("Windows Importation")), clicked 	=>
# 							    sub { ${$central_widget}->destroy(); $windows = 1; license(\&appli_choice)}),
# 					  gtksignal_connect(new Gtk::Button(_("Configuration")), clicked =>
# 							    sub {  ${$central_widget}->destroy(); $windows = 0; license(\&advanced_install)}),
# 					  gtksignal_connect(new Gtk::Button(_("Uninstall Fonts")), clicked => 
# 							    sub { ${$central_widget}->destroy(); uninstall() }),
# 					  gtksignal_connect(new Gtk::Button(_("Font List")), clicked 	=>
# 							    sub { ${$central_widget}->destroy(); create_fontsel()}),
#					  ),










# sub interactive_mode {
#     my $fst_choice_box;
#     my $fst_choice_box1;
#     my $pixmap_fst_choice;
#     $interactive = 1;
#     my $pixmap;
#     my $pixmapwid;
#     my $mask;
#     my $style;
#     init Gtk;
    
#     $window1 = $::isEmbedded ? new Gtk::Plug ($::XID) : new Gtk::Window -toplevel;
#     $window1->signal_connect (delete_event => sub { Gtk->exit(0) });
#     $window1->set_position(1);
#     $window1->set_title(_("Drakbackup"));

#     my ($pix_u_map, $pix_u_mask) = gtkcreate_png("/home/seb/draklogo.png");
#     my ($pix_l_map, $pix_l_mask) = gtkcreate_png("/home/seb/back_l.png");
#     my ($pix_r_map, $pix_r_mask) = gtkcreate_png("/home/seb/back_r.png");

#     gtkadd($window1,
# 	   gtkpack_(new Gtk::VBox(0,0),
# 		    1, gtkpack_(gtkset_usize(new Gtk::VBox(0,0), 550, 360), 
# 		       1, gtkpack_(my $up_box = new Gtk::VBox(0,0),
# 				   1, new Gtk::VBox(0,0),
# 				   1, gtkpack_($fst_choice_box = new Gtk::VBox(0,0),
# 					       0, my $pix_c = new Gtk::Pixmap($pix_u_map, $pix_u_mask),
# 					       0, gtkpack_(new Gtk::HBox(0,1),
# 							   0, my $pix_l = new Gtk::Pixmap($pix_l_map, $pix_l_mask),
# 							   1, gtkpack_(new Gtk::VButtonBox,
# 								       0, gtksignal_connect(new Gtk::Button(_("Wizard")), clicked => sub { 
# 									   ${$central_widget}->destroy(); wizard() }),
# 								       0, gtksignal_connect(new Gtk::Button(_("Advanced")), clicked => sub {
# 									   ${$central_widget}->destroy(); about() }),		
# 								       ),
# 								    ),
# 					       1, my $pix_r = new Gtk::Pixmap($pix_r_map, $pix_r_mask),
# 					       ),
# 				   ),
# 				1, gtkpack_(new Gtk::HBox(0,5),
# 					    1, new Gtk::HBox(0,5),
# 					    1, gtkadd(gtkset_layout(new Gtk::HButtonBox, -end),
# 						      gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub { 
# 							  ${$central_widget}->destroy(); help() }),
# 						      gtksignal_connect(new Gtk::Button(_("About")), clicked => sub { 
# 							  ${$central_widget}->destroy(); help() }),
# 						      gtksignal_connect(new Gtk::Button(_("Close")), clicked => sub { Gtk->main_quit() }),
# 						      ),
# 					    )
# 				),
# 		    ),
# 		    );
#     $central_widget = \$up_box;
#     $window1->show_all;
#     $window1->realize;
#     $window1->show_all();
    
#     Gtk->main;
#     Gtk->exit(0);
# }


# ok





#   step_where_backup:
#     undef $::Wizard_no_previous;
#     my $r2 = $in->ask_from_no_check(_("Backup Configuration wizard"),
# 				_("Please choose how to backup your system"),
# 				[ __("Hard Drive"), __("accross the Network"), __("Burn auto boot Restore CDROM") ]) 
# 	or quit_global($in, 0);




# sub after_adv {
#     my $text = new Gtk::Text(undef, undef);
#     my $after_adv_box;
#     my $box_cfg_state;
#     my $box_cgf_state_replace;
#     my $box_cgf_state_comp;

#     read_conf_file();    
#     if ($option_replace) { $box_cgf_state_replace = _("Replace backups (do not update)"),
#     } else { $box_cgf_state_replace = _("Update backups (do not replace)"), }

#     if ($comp_mode) { $box_cgf_state_comp = _("Backups use tar and gunzip "),
#     } else { $box_cgf_state_comp = _("Backups use tar and gunzip"),    }
	
#     my $label_cfg_file = new Gtk::Label _("Backup Sources: \n-System Files: @sys_files \n-Users Files: @home_files\n-Other Files to backup: @other_files\nPath to save backups: $save_path\nOptions:\n$box_cgf_state_replace\n$box_cgf_state_comp\n\n");
#     $box_cfg_state =  gtkpack(new Gtk::VBox( 0, 0),
# 			      gtkset_justify( $label_cfg_file , 'left'),
# 			      ),

#     gtkpack($up_box,
# 	    $after_adv_box = gtkpack_(new Gtk::VBox(0,10),
# 				      1, gtkadd(new Gtk::Frame(_("State of configuration file.")),
# 						gtkpack(new Gtk::VBox(0,10),
# 							$box_cfg_state,
# 							),
# 						),
# 				      0, gtksignal_connect(new Gtk::Button(_("Click here if you want to build a backup now.")), clicked => 
# 							   sub { ${$central_widget}->destroy(); }),
# 				      0, new Gtk::HSeparator,
# 				      0, gtkadd(new Gtk::HButtonBox,
# 						gtksignal_connect(new Gtk::Button(_("Close")), clicked => sub { Gtk->main_quit() }),
# 						gtksignal_connect(new Gtk::Button(_("About")), clicked => 
# 								  sub { ${$central_widget}->destroy();  about() }),
# 						gtksignal_connect(new Gtk::Button(_("Help")), clicked => 
# 								  sub { save_conf_file(); ${$central_widget}->destroy(); adv_help() }),
# 						gtksignal_connect(new Gtk::Button(_("Ok")), clicked => sub { 
# 						    ${$central_widget}->destroy(); after_adv();    }),
# 						),				  
# 				      ),
# 	    );
#     $central_widget = \$box;
#     $up_box->show_all();
# }
