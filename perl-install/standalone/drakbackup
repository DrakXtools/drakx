#!/usr/bin/perl
#
# Copyright (C) 2001 by Sebastien DUPONT <sdupont@mandrakesoft.com>
# Redistribution of this file is permitted under the terms of the GNU
# Public License (GPL)
## description:
#
#  Drakbacup is use to backup system files and user files
#  Drakbacup allow to restore the system (etc, var files)
#  from starup or on drakconf utility.
#
#backup name format: all the time from the /
#                    backup_sys_12102001.tar.gz                    -> default system backup
#		     backup_sys_etc_var_proc_12102001.tar.gz       -> specific system directories
#		     backup_user_james_12102001.tar.gz             -> default user backup
#		     backup_user_james_documents_12102001.tar.gz   -> specific user directories
#                    backup_other_proc_12102001.tar.gz             -> specific other directories
#
# backup name rules: system: begin by sys
#                    user:   begin by user
#                    other:   begin by other
#                    end of all `date`.tar.gz
#
# seems to be good idea to have a txt file where user explain the differences
# between all the backup
#
# save only the differences...
#
# find / -mtime -1 \! -type d -print > /tmp/liste.jour
# build iso fs with rescue.
# configuration file on /etc/drakconf/drakbackup/drakbakup.conf
# perl -ne 'split(":");print "$_[0]:*:$_[2]:$_[3]:::\n";' /etc/passwd > passwd 
#
#
# TODO:
#	icon for cdrom.
#	wizard step.
#	implement all advanced.



use Gtk;
use lib qw(/usr/lib/libDrakX );
use interactive;
use standalone;
use my_gtk qw(:helpers :wrappers);
use common;
use strict;

my $in = 'interactive'->vnew('', 'default');
!$::isEmbedded && $in->isa('interactive_gtk') and $::isWizard=1;


if ("@ARGV" =~ /--help|-h/) {
    print q(Backup and monitoring application

--list           : list of files or directories to backup.
--default        : save default directories.
--build_cd       : build restore iso with the currents backups files
                       & rescue options.
--build_floppy   : build restore floppy.
--replace        : delete backup files before build new do not update.
--save_dir       : by default the backup files are saved in 
                       in /var/backup directory so write other directory
	               to change to change it.
--conf_file      : to read other configuration file. 
--mdk_cc	 : to include on Mandrake Control Center
);
    exit(0);
}

# Backend Options.
my $default = 0;
my $build_cd = 0;
my $build_floppy = 0;
my $mode = 0;
my $conf_file = 0;
my @list_arg = ();
my $windows = 0;
my $central_widget;
my $central_widget_save;
my $interactive;
my $up_box;
my $box;
my $backup_choice = 0;
my $cfg_file_exist = 0;
my @user_and_path_list;
my @user_list;
my @all_user_list;
my $list_other;
my @list_other;
my $mdk_cc = 0;
my $DEBUG = 0;


# config. FILES -> Default PATH  & Global variables.
my @sys_files = ("/etc");
my @user_list;
my @list_other = () ;
my $cfg_file = "/etc/drakxtools/drakbackup/drakbackup.conf";
my $save_path = "/var/drakbackup";
my $option_replace = 0;
my $comp_mode = 0;
my $backup_mode = 0; 
my $backup_sys = 1;
my $backup_sys_cvs = 1;
my $what_no_browser = 1;
my $remember_pass = 0;
my $cdrw = 0;
my $net_proto;
my $host_path;
my $login_user;
my $passwd_user;
my $net_daemon = 0;
my $hd_daemon = 0;
my $cd_daemon = 0;
my $hd_quota = 0;
my $where_net= 0;
my $where_hd = 1;
my $where_cd =0;
my $cd_time = 650;
my $when_space;

foreach (@ARGV) {
    /--default/ and $default = 1, $mode=-1;
    /--build_cd/ and $build_cd = 1, $mode=-1;
    /--build_floppy/ and $build_floppy = 1, $mode=-1;
    /--replace|-r/ and $option_replace = 1, $mode=-1;
    /--conf_file/ and $mode = 0, next;
    /--list/ and $mode = 1, next;
    /--mdk_cc/ and $mdk_cc = 1, next;
    /--debug/ and $DEBUG = 1, next;
    $mode == 1 and push @list_arg, $_;
}

sub debug {
    print "SYS_FILES: $_ \n" foreach (@sys_files);
    print "HOME_FILES: $_ \n" foreach (@user_list);
    print "OTHER_FILES: $_ \n" foreach (@list_other);
    print "PATH_TO_SAVE: $save_path \n";
    print "OPTION_REPLACE: $option_replace \n";
    print "OPTION_COMP: $comp_mode \n";
}

sub read_passwd {
    @user_and_path_list = map { (split(':', $_))[0] . ":" . (split(':', $_))[5] } grep {( split(':', $_))[2] > 500} split ('\n', cat_('/etc/passwd'));  
    $DEBUG and print "user_and_path_list: ".$_."\n" foreach (@user_and_path_list);
    @user_list = ();
    @all_user_list = ();
    push @user_and_path_list, 'root:/root';
    push @user_list, (split(':', $_))[0] foreach (@user_and_path_list);
    push @all_user_list, (split(':', $_))[0] foreach (@user_and_path_list);
    $DEBUG and print "home_files: ".$_."\n" foreach (@user_list);
}

sub save_conf_file {
    my @cfg_list = ( "SYS_FILES=@sys_files\n",
		     "HOME_FILES=@user_list\n", 
		     "OTHER_FILES=@list_other\n",
		     "PATH_TO_SAVE=$save_path\n",
		     "HOST_PATH=$host_path\n",
		     "NET_PROTO=$net_proto\n",
		     "CD_TIME=$cd_time\n",
		     "DAEMON_TIME_SPACE=$when_space\n"
		     );
    $remember_pass and push @cfg_list, "LOGIN=$login_user\n" ;
    $remember_pass and push @cfg_list, "PASSWD=$passwd_user\n" ;
    $net_daemon and push @cfg_list, "NET_DAEMON\n" ;
    $hd_daemon and push @cfg_list, "HD_DAEMON\n" ;
    $cd_daemon and push @cfg_list, "CD_DAEMON\n" ;
    $hd_quota and  push @cfg_list, "HD_QUOTA\n" ;
    $where_hd and  push @cfg_list, "USE_HD\n" ;
    $where_cd and  push @cfg_list, "USE_CD\n" ;
    $where_net and  push @cfg_list, "USE_NET\n" ;
    $cdrw and push @cfg_list, "CDRW\n"; 
    $remember_pass and push @cfg_list, "REMEMBER_PASS\n" ;
    $what_no_browser or push @cfg_list, "BROWSER_CACHE\n" ;
    $backup_sys_cvs or push @cfg_list, "NO_SYS_CVS\n" ;
    $option_replace and push @cfg_list, "OPTION_REPLACE\n" ;
    $backup_sys or push @cfg_list,  "NO_SYS_FILES\n";
    if ($comp_mode) {	push @cfg_list, "OPTION_COMP=TAR.BZ2\n"; } 
    else { push @cfg_list, "OPTION_COMP=TAR.GZ\n"; }
    output_p( $cfg_file, @cfg_list);
}

sub read_conf_file {
    read_passwd();
    if (-e $cfg_file) {
        open ( CONF_FILE, "<"."$cfg_file") || die;
        while (<CONF_FILE>) {
	    next unless /\S/;
	    next if /^#/;
	    chomp;
	    if (/^SYS_FILES/)      { s/^SYS_FILES=//gi;    @sys_files = split(' ', $_ );	}
	    if (/^HOME_FILES/)     { s/^HOME_FILES=//gi;   @user_list = split(' ', $_ );	}
	    if (/^OTHER_FILES/)    { s/^OTHER_FILES=//gi;  @list_other = split(' ', $_ );	}
	    if (/^PATH_TO_SAVE/)   { s/^PATH_TO_SAVE=//gi; $save_path = $_;	}
	    if (/^OPTION_REPLACE/) { $option_replace = 1; }
	    if (/^NO_SYS_FILES/)   { $backup_sys = 0;}
	    if (/^OPTION_COMP/)    { s/^OPTION_COMP=//gi; /TAR.GZ/ and  $comp_mode = 0; /TAR.BZ2/ and $comp_mode = 1; }
	    if (/^NO_SYS_CVS/)	   { $backup_sys_cvs = 0;  }
	    if (/^BROWSER_CACHE/)  { $what_no_browser = 0; }
	    if (/^CDRW/)           { $cdrw = 1; }
	    if (/^REMEMBER_PASS/)  { $remember_pass = 1; }
	    if (/^NET_PROTO/)      { s/^NET_PROTO=//gi; $net_proto = $_; }
	    if (/^HOST_PATH/)      { s/^HOST_PATH=//gi; $host_path = $_; } 
	    if (/^LOGIN/)          { s/^LOGIN=//gi;  $login_user  = $_; $remember_pass = 1; }
	    if (/^PASSWD/)         { s/^PASSWD=//gi; $passwd_user = $_; $remember_pass = 1; }
	    if (/^NET_DAEMON/)	   { $net_daemon = 1; }
	    if (/^HD_DAEMON/)	   { $hd_daemon = 1; }
	    if (/^CD_DAEMON/)	   { $cd_daemon = 1; }
	    if (/^HD_QUOTA/)       { $hd_quota = 1;  }
	    if (/^USE_HD/)         { $where_hd = 1;  }
	    if (/^USE_CD/)         { $where_cd = 1;  }
	    if (/^USE_NET/)        { $where_net = 1; }
	    if (/^CD_TIME/)        { s/^CD_TIME=//gi; $cd_time = $_; }
	    if (/^DAEMON_TIME_SPACE/) { s/^DAEMON_TIME_SPACE=//gi; $when_space = $_; }
	}
	$cfg_file_exist = 1;
    } 
    else { $cfg_file_exist = 0; }
    close CONF_FILE;    
    $DEBUG and debug; 
}

if ($mdk_cc) { $build_floppy || $build_cd || $default || @list_arg || $conf_file ? backend_mod() : interactive_mode();
	   } else { $build_floppy || $build_cd || $default || @list_arg || $conf_file ? backend_mod() : interactive_mode_my(); }

sub backend_mod {

}

sub build_cd_fct {

}

sub build_floppy_fct {
}

sub build_backup_files {

}

sub interactive_mode {
    $interactive = 1;
    my $box_cfg_state;
    my $box_cgf_state_replace;
    my $box_cgf_state_comp;
    my $mask;
    my $style;
    my $box;
    init Gtk;
    my $text2 = new Gtk::Text(undef, undef);
    my $window1 = $::isEmbedded ? new Gtk::Plug ($::XID) : new Gtk::Window -toplevel;
    $window1->signal_connect (delete_event => sub { Gtk->exit(0) });
    $window1->set_position(1);
    $window1->set_title(_("Drakbackup"));

    read_conf_file();    
    if ($option_replace) { $box_cgf_state_replace = _("Replace backups (do not update)"),
    } else { $box_cgf_state_replace = _("Update backups (do not replace)"),  }

    if ($comp_mode) { $box_cgf_state_comp = _("Backups use tar and gunzip "),
    } else { $box_cgf_state_comp = _("Backups use tar and gunzip"),   }
	
    if ($cfg_file_exist) { 
	my $label_cfg_file = new Gtk::Label _("Backup Sources: \n-System Files: @sys_files \n-Users Files: @user_list\n-Other Files to backup: @list_other\nPath to save backups: $save_path\nOptions:\n$box_cgf_state_replace\n$box_cgf_state_comp\n\n");
	$box_cfg_state =  gtkpack(new Gtk::VBox( 0, 0),
				  gtkset_justify( $label_cfg_file , 'left'),
				  ),
    } else { $box_cfg_state =  gtkpack(new Gtk::VBox(0,1),
				       _("No configuration please click Wizard or Advanced.") ), }

    gtkadd($window1,
	   gtkpack(new Gtk::VBox(0,0),
		   gtkpack(gtkset_usize($up_box = new Gtk::VBox(0,5), 500, 350),
			   $box = gtkpack_(new Gtk::VBox(0,3),
					   0, _("Welcome on DrakBackup"),
					   1, gtkadd(new Gtk::Frame(_("State of configuration file.")),
						      gtkpack(new Gtk::VBox(0,10),
							      $box_cfg_state,
							      ),
						     ),
					   0, gtkpack_(new Gtk::HBox(0, 0),
						       0, gtksignal_connect(new Gtk::Button(_(" Build Backup ")), 
									    clicked => sub { save_conf_file(); Gtk->main_quit() }),
						       ),
					   0, gtkpack_(new Gtk::HBox(0, 0),
						       0, gtksignal_connect(new Gtk::Button(_("     Restore      ")), 
									    clicked => sub { save_conf_file(); Gtk->main_quit() }),
						       ),
					   0, new Gtk::HSeparator,
					   0, gtkpack_(gtkset_layout(new Gtk::HButtonBox, -end),
						       1, gtksignal_connect(new Gtk::Button(_("Advanced Conf.")), clicked => 
									    sub { ${$central_widget}->destroy(); advanced() }),
						       1, gtksignal_connect(new Gtk::Button(_("Wizard Conf.")), clicked => 
									    sub { ${$central_widget}->destroy(); wizard() }),
						       1, gtksignal_connect(new Gtk::Button(_("close")), clicked => 
									    sub { save_conf_file(); Gtk->main_quit() }),
						       ),
					   ),
			   ),
		   ),
	   );
    $central_widget = \$box;
    $window1->show_all;
    $window1->realize;
    $window1->show_all();    
    Gtk->main;
    Gtk->exit(0);
}



sub list_remove {
    my($widget, $list) = @_;
    my @to_remove;
    push @to_remove, $list->child_position($_) foreach($list->selection);
    splice @list_other, $_, 1 foreach(reverse sort @to_remove);
    $list->remove_items($list->selection);
}


sub file_ok_sel { 
    my ( $widget, $file_selection ) = @_;     
    my $file_name = $file_selection->get_filename();
    if(!member($file_name, @list_other)) {
	push(@list_other, $file_name);
	$list_other->add(gtkshow(new Gtk::ListItem($file_name)));
    }
}

sub  filedialog {
    my $file_dialog;

    $file_dialog = gtksignal_connect(new Gtk::FileSelection(_("File Selection")), destroy => sub { $file_dialog->destroy(); } );
    $file_dialog->ok_button->signal_connect(clicked => \&file_ok_sel, $file_dialog);
    $file_dialog->ok_button->child->set(_("Add"));
    $file_dialog->cancel_button->signal_connect(clicked => sub { $file_dialog->destroy() });
    $file_dialog->cancel_button->child->set(_("Close"));
    $file_dialog->set_filename(_("Select the files or directories and click on 'Add'"));
    $file_dialog->show();
}

sub wizard {
    my $user = 1;
    my $user2;
    my $text;

  begin: 
    $::isWizard=1;

 step_what_backup:
   $::Wizard_no_previous = 1;
    $in->ask_from(_("Please choose that you want to backup"),
  	          (_("Please choose that you want to backup") . "\n\n") .
	          $text,
		  [ 
		    { label => _("System Files"), val => \$user, type => "bool", text => _("  all files on your /etc directory.") },
		    map { { label => _("$_"), val => \$user, type => "bool", text => _("all data contained on $_ directory") } } @user_list,
		    ],
		  );
    

   my $r = $in->ask_from_list_(_("Backup Configuration wizard"),
				_("Please choose what you need to backup from your system"),
				[ __("Hard Drive or NFS file system"), __("Mandrake Online"), __("on CDROM") ]) 
	or quit_global($in, 0);
     

    $in->ask_from(_("Backup Configuration wizard"),
  	          (_("Please choose when you want to backup") . "\n\n") .
	          $text,
		  [ 
		    { label => _("Daemon"), val => \$user, type => "bool", text => _(" Select it if you want that backup run as daemon") },
		    ],
		  );

    $in->ask_from(_("Backup Configuration wizard"),
  	          (_("Please choose that you want to do") . "\n\n") .
	          $text,
		  [ 
		    { label => _("Build Auto-Boot CDROM"), val => \$user, type => "bool", text => _("this option work only if you have a CDR-W CDROM drive\n This options allow you to restore all\n your system (data and your system variables)") },
		    ],
		  );
} 

sub advanced {
    my $notebook; 
    my $notebook_what; 
    my $notebook_when; 
    my $notebook_where; 
    my $notebook_options; 
    my $about_box;
    my $book_open;
    my $book_open_mask;
    my $transparent;
    my $book_closed;
    my $book_closed_mask;
    my $box_tmp;    
    my $choice_what_sys;
    read_conf_file();
    
    my ($pix_net_map, $pix_net_mask) = gtkcreate_png("../pixmaps/backup_net.png");
    my ($pix_hd_map, $pix_hd_mask) = gtkcreate_png("../pixmaps/backup_hd.png");
    my ($pix_time_map, $pix_time_mask) = gtkcreate_png("../pixmaps/backup_time.png");
    my ($pix_user_map, $pix_user_mask) = gtkcreate_png("../pixmaps/user.png");
    my ($pix_sys_map, $pix_sys_mask) = gtkcreate_png("../pixmaps/bootloader.png");
    my ($pix_other_map, $pix_other_mask) = gtkcreate_png("../pixmaps/net_u.png");
    my ($pix_options_map, $pix_options_mask) = gtkcreate_png("../pixmaps/backup_options.png");
    my ($pix_hd2_map, $pix_hd2_mask) = gtkcreate_png("../pixmaps/hd.png");
    my ($pix_net2_map, $pix_net2_mask) = gtkcreate_png("../pixmaps/net.png");
    my ($pix_cd_map, $pix_cd_mask) = gtkcreate_png("../pixmaps/cdrom.png");

    my $label_what = gtkpack(new Gtk::VBox( 0, 2),
			 new Gtk::Pixmap($pix_hd_map, $pix_hd_mask),
			 _("What backup.")
			 );
    my $label_where = gtkpack(new Gtk::VBox( 0, 2),
			 new Gtk::Pixmap($pix_net_map, $pix_net_mask),
			 _("Where backup.")
			 );
    my $label_when = gtkpack(new Gtk::VBox( 0, 2),
			 new Gtk::Pixmap($pix_time_map, $pix_time_mask),
			 _("When backup.")
			 );

    my $label_options = gtkpack(new Gtk::VBox( 0, 2),
			 new Gtk::Pixmap($pix_options_map, $pix_options_mask),
			 _("Options")
			 );

    my $label_what_sys = gtkpack(new Gtk::HBox( 0, 2),
			 new Gtk::Pixmap($pix_sys_map, $pix_sys_mask),
			 _("System", " ")
			 );
    my $label_what_user = gtkpack(new Gtk::HBox( 0, 2),
			 new Gtk::Pixmap($pix_user_map, $pix_user_mask),
			 _("Users", " ")
			 );

    my $label_what_other = gtkpack(new Gtk::HBox( 0, 2),
			 new Gtk::Pixmap($pix_other_map, $pix_other_mask),
			 _("Other", " ")
			 ); 

    my $label_where_net = gtkpack(new Gtk::HBox( 0, 2),
			 new Gtk::Pixmap($pix_net2_map, $pix_net2_mask),
			 _(" Network ")
			 );

    my $label_where_cd = gtkpack(new Gtk::HBox( 0, 2),
			 new Gtk::Pixmap($pix_cd_map, $pix_cd_mask),
			 _(" CDROM\nDVDROM ")
			 );

    my $label_where_hd = gtkpack(new Gtk::HBox( 0, 2),
			 new Gtk::Pixmap($pix_hd2_map, $pix_hd2_mask),
			 _(" Hard Drive\n NFS ")
			 );

    my $box_what_sys =  gtkpack_(new Gtk::VBox(0,1),
				 1, _("\nPlease check all options that you need.\n"),
				 0, my $check_what_sys = new Gtk::CheckButton( _(" Backup your System files. (~ 10Mo)")),
				 0, my $check_what_cvs = new Gtk::CheckButton( _(" Need to restore any versions (CVS)") ),
				 1, _("With this option you will be able to restore any version\n of your /etc directory like in CVS this solution seems to be\n more interesting because it allow you to restore at any\n moment any vercions of your /etc"),
				 );
    my %check_what_user;
    my $box_what_user =  gtkpack_(new Gtk::VBox(0,0),
				  0, _("Please check all user that you want to include inb your backup."),
				  0, new Gtk::HSeparator,
				  1, createScrolledWindow( gtkpack(new Gtk::VBox(0,0),
				      map { my $name = $_;
					    my @user_list_tmp;
					    my $b = new Gtk::CheckButton($name); 

					    if (grep /^$name$/, @user_list) {
						$check_what_user{$_}[1] = 1;
						gtkset_active($b, 1);
					    } else {
						$check_what_user{$_}[1] = 0;
						gtkset_active($b, 0);
					    }
					    $b->signal_connect(toggled => sub { 
						if ($check_what_user{$name}[1] ) {
						    $check_what_user{$name}[1] = 0;
						    @user_list_tmp = grep(!/^$name$/, @user_list);
						    @user_list = @user_list_tmp;
						} else { 
						    $check_what_user{$name}[1] = 1;
						    if (!member($name, @user_list) ) {push @user_list, $name;}
						}
					    });
					    $b } (@all_user_list) 
								   ),
							   ),
				  0, new Gtk::HSeparator,
				  0, my $check_what_browser = new Gtk::CheckButton( _(" do not include the browser cache") ),
				  );
    
    $list_other = new Gtk::List();
    $list_other->set_selection_mode(-extended);
    $list_other->add(gtkshow(new Gtk::ListItem($_))) foreach (@list_other);
    my $box_what_other =  gtkpack_(new Gtk::VBox(0,10),
				   1, gtkpack_(new Gtk::HBox(0,4),
					       1, createScrolledWindow($list_other),
					       ),
				   0, gtkadd(gtkset_layout(new Gtk::HButtonBox, -spread),
					     gtksignal_connect(new Gtk::Button(_("Add")), clicked => sub {filedialog()  }),
 					     gtksignal_connect(new Gtk::Button(_("Remove Selected")), clicked => \&list_remove, $list_other),
					     ),
				   );
    
    my $combo_where_net_proto = new Gtk::Combo();
    $combo_where_net_proto->set_popdown_strings ("scp","ftp", "sftp", "rsync");

    my $box_where_net =  gtkpack_(new Gtk::VBox(0,1),
				  0, new Gtk::HSeparator,
				  0, my $check_where_net = new Gtk::CheckButton( _(" Use Network to backup") ),
#				  0, my $check_where_net_daemon = new Gtk::CheckButton( _(" Use Network with daemon") ),
				  0, new Gtk::HSeparator,
				  0, gtkpack_(new Gtk::HBox(0,10),
					      1, _("please choose your protocol"),
					      0, $combo_where_net_proto,
					      0, _(""),
					      ),
				  0, _(""),
				  0, gtkpack_(new Gtk::HBox(0,10),
					      1, _("please entrer the directory\n to put the backup on this host. "),
					      1, my $host_path_entry = new Gtk::Entry(),
					      0, _(""),
					      ),
				  0, _(""),
				  0, gtkpack_(new Gtk::HBox(0,10),
					      1, _("please entrer your login"),
					      0, my $login_user_entry = new Gtk::Entry(),
					      0, _(""),
					      ),
				  0, gtkpack_(new Gtk::HBox(0,10),
					      1, _("please entrer your passord"),
					      0, my $passwd_user_entry = new Gtk::Entry(),
					      0, _(""),
					      ),
				  0, my $check_remember_pass = new Gtk::CheckButton( _(" remember this password") ),
				  );
    $combo_where_net_proto->entry->set_text($net_proto);
    $combo_where_net_proto->entry->signal_connect( 'changed', sub { $net_proto = $combo_where_net_proto->entry->get_text()});
    $passwd_user_entry->set_visibility(0);
    $host_path_entry->set_text( $host_path );
    $login_user_entry->set_text( $login_user );
    $passwd_user_entry->set_text( $passwd_user );
    $host_path_entry->signal_connect( 'changed', sub { $host_path = $host_path_entry->get_text()});
    $login_user_entry->signal_connect( 'changed', sub { $login_user = $login_user_entry->get_text()});
    $passwd_user_entry->signal_connect( 'changed', sub { $passwd_user = $passwd_user_entry->get_text()});

    my $adj = new Gtk::Adjustment 500.0, 1.0, 10000.0, 1.0, 5.0, 0.0;
    my $box_where_hd =  gtkpack_(new Gtk::VBox(0,1),
				 0, new Gtk::HSeparator,
				 0, my $check_where_hd = new Gtk::CheckButton( _(" Use Hard Disk to backup") ),
#				 0, my $check_where_hd_daemon = new Gtk::CheckButton( _(" Use Hard Disk with daemon") ),
				 0, new Gtk::HSeparator,
				 0, gtkpack_(new Gtk::HBox(0,10),
					     0, _(" "),
					     0, _("Please entrer the directory to save: "),
					     1, my $save_path_entry = new Gtk::Entry(),
					     0, _(""),
					     ),
				 0, _(""),
				 0, gtkpack_(new Gtk::HBox(0,10),
					     0, _(""),
					     0, _("Please entrer the maximum size allowed for Drakbackup "),
					     1, my $spinner = new Gtk::SpinButton( $adj, 0, 0),
					     0, _(""),
					     ),
				 0, gtkpack_(new Gtk::HBox(0,10),
					     1, _(""),
					     0, my $check_where_hd_quota = new Gtk::CheckButton( _(" Use quota for backup files.") ),
					     0, _(""),
					     ),
				 );

    $save_path_entry->set_text( $save_path );
    $save_path_entry->signal_connect( 'changed', sub { $save_path = $save_path_entry->get_text()});

    my $combo_where_cd_time = new Gtk::Combo();
    $combo_where_cd_time->set_popdown_strings ("650","700", "750", "800");    
    my $box_where_cd =  gtkpack_(new Gtk::VBox(0,1),
				 0, new Gtk::HSeparator,
				 0, my $check_where_cd = new Gtk::CheckButton( _(" Use CD/DVDROM to backup") ),
#				 0, my $check_where_cd_daemon = new Gtk::CheckButton( _(" Use CD/DVDROM with daemon") ),
				 0, new Gtk::HSeparator,
				 0, gtkpack_(new Gtk::HBox(0,10),
					     1, _("please choose your CD space"),
					     0, $combo_where_cd_time,
					     0, _(""),
					     ),
				 0, _(""),
				 0, gtkpack_(new Gtk::HBox(0,10),
					     1, _(" Please check if you are using CDRW media"),
					     0, my $check_cdrw = new Gtk::CheckButton(),
					     0, _(""),
					     ),
				 0, gtkpack_(new Gtk::HBox(0,10),
					     1, _("please enter your CDRW device name"),
					     0, $combo_where_cd_time,
					     0, _(""),
					     ),
				 );
    $combo_where_cd_time->entry->set_text($cd_time);
    $combo_where_cd_time->entry->signal_connect( 'changed', sub { $cd_time = $combo_where_cd_time->entry->get_text()});	       

    my $box_what = gtkpack(new Gtk::VBox(0,1),
			   $notebook_what = new Gtk::Notebook,
			   $notebook_what->insert_page( $box_what_sys, $label_what_sys, 0),
			   $notebook_what->insert_page( $box_what_user, $label_what_user, 1),
			   $notebook_what->insert_page( $box_what_other, $label_what_other, 2),
			   $notebook_what->set_scrollable(1),
			   );
    
    my $box_where =  gtkpack(new Gtk::VBox(0,1),
			     $notebook_where = new Gtk::Notebook,
			     $notebook_where->insert_page( $box_where_net, $label_where_net, 0 ),
			     $notebook_where->insert_page( $box_where_hd, $label_where_hd, 1 ),
			     $notebook_where->insert_page( $box_where_cd, $label_where_cd, 1 ),
			     );

    my $combo_when_space = new Gtk::Combo();
    $combo_when_space->set_popdown_strings (_("daily"),_("week"),_("month"),_("year"),);    
    my $box_when =  gtkpack_(new Gtk::VBox(0,1),
			     0, new Gtk::Pixmap($pix_time_map, $pix_time_mask),
			     0, new Gtk::HSeparator,
			     0, gtkpack_(new Gtk::HBox(0,10),
					 1, _("Please choose interval \nspace between each backup "),
					 0, $combo_when_space,
					 0, _(""),
					 ),
			     0, _(""),
			     0, gtkpack_(new Gtk::HBox(0,10),
					 1, _("Please choose media to backup. "),
					 0, gtkpack_(new Gtk::VBox(0,10),
						     0, my $check_where_cd_daemon  = new Gtk::CheckButton( _(" Use CD/DVDROM with daemon")  ),
						     0, my $check_where_hd_daemon  = new Gtk::CheckButton( _(" Use Hard Drive with daemon") ),
						     0, my $check_where_net_daemon = new Gtk::CheckButton( _(" Use Network with daemon")    ),
						     ),
					 ),
			     
			     0, new Gtk::HSeparator,
			     );
    $combo_when_space->entry->set_text( $when_space );
    $combo_when_space->entry->signal_connect( 'changed', sub { $when_space = $combo_when_space->entry->get_text()});

    my $box_options = gtkpack(new Gtk::VBox(0,1),
			      $notebook_options = new Gtk::Notebook,
			      );
    
    gtkpack($up_box,
	    $about_box = gtkpack_(new Gtk::VBox(0,10),
				  1, gtkpack(new Gtk::HBox(0,0),
					     gtkpack(my $notebook_box = new Gtk::VBox(0,5),
						     $notebook = new Gtk::Notebook,
						     $notebook->insert_page( $box_what, $label_what, 0),
						     $notebook->insert_page( $box_where, $label_where, 1),
						     $notebook->insert_page( $box_when, $label_when, 2),
#						     $notebook->insert_page( $box_options, $label_options, 3),
						     $notebook->set_scrollable( 1 )
						     ),
					     ),
				  0, gtkadd(new Gtk::HButtonBox,
					    gtksignal_connect(new Gtk::Button(_("Close")), clicked => 
							      sub { save_conf_file();
								    ${$central_widget}->destroy(); 
								    $mdk_cc and interactive_mode();
								    $mdk_cc or interactive_mode_my();
								}),
					    gtksignal_connect(new Gtk::Button(_("Help")), clicked => 
							      sub { save_conf_file(); ${$central_widget}->destroy(); adv_help() }),
					    gtksignal_connect(new Gtk::Button(_("Ok")), clicked => sub { 
						save_conf_file(); ${$central_widget}->destroy(); after_adv();    }),
					    ),				  
				  ),
	    ),
    my %rotate = (
		  top => "right",
		  right => "bottom",
		  bottom => "left",
		  left => "top"
		  );




    foreach ([$check_what_sys, \$backup_sys], [$check_what_cvs, \$backup_sys_cvs], [$check_what_browser, \$what_no_browser], [$check_remember_pass, \$remember_pass], [$check_cdrw, \$cdrw], [$check_where_net_daemon, \$net_daemon], [$check_where_hd_daemon, \$hd_daemon], [$check_where_cd_daemon, \$cd_daemon], [$check_where_hd_quota,  \$hd_quota], [$check_where_hd, \$where_hd], [$check_where_cd, \$where_cd], [$check_where_net, \$where_net]) {
	my $ref = $_->[1];
	gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => sub { ${$ref} = ${$ref} ? 0 : 1; })
	}
    
    $notebook->set_tab_pos( $rotate{ $notebook->tab_pos } );
    $central_widget = \$about_box;
    $up_box->show_all();
}


sub interactive_mode_my {
    $interactive = 1;
    my $box_cfg_state;
    my $box_cgf_state_replace;
    my $box_cgf_state_comp;
    my $mask;
    my $style;
    my $box;
    my $box_cgf_state_sys = ("");
    my $text2 = new Gtk::Text(undef, undef);
    my $window1 = $::isEmbedded ? new Gtk::Plug ($::XID) : new Gtk::Window -toplevel;

    init Gtk;

    $window1->signal_connect (delete_event => sub { Gtk->exit(0) });
    $window1->set_position(1);
    $window1->set_title(_("Drakbackup"));
    
    my ($pix_u_map, $pix_u_mask) = gtkcreate_png("../pixmaps/backup_title.png");
    my ($pix_l_map, $pix_l_mask) = gtkcreate_png("../pixmaps/backup_left.png");
    my ($pix_r_map, $pix_r_mask) = gtkcreate_png("../pixmaps/backup_bot.png");
    
    read_conf_file();    
    $backup_sys or $box_cgf_state_sys = _("Do not include System Files");    
    if ($option_replace) { $box_cgf_state_replace = _("Replace backups (do not update)"),
    } else { $box_cgf_state_replace = _("Update backups (do not replace)"),  }
    if ($comp_mode) { $box_cgf_state_comp = _("Backups use tar and gunzip "),
    } else { $box_cgf_state_comp = _("Backups use tar and gunzip"),   }
    if ($cfg_file_exist) { my $label_cfg_file = new Gtk::Label _("Backup Sources: \n-System Files: @sys_files \n-Users Files: @user_list\n-Other Files to backup: @list_other\nPath to save backups: $save_path\nOptions:\n$box_cgf_state_replace\n$box_cgf_state_comp\n$box_cgf_state_sys\n");
			   $box_cfg_state =  gtkpack(new Gtk::VBox( 0, 0),
						     gtkset_justify( $label_cfg_file , 'left'),
						     ),
     } else { $box_cfg_state = gtkpack(new Gtk::VBox(0,1),
				       _("No configuration please click Wizard or Advanced.") ), }

    gtkadd($window1,
	   gtkpack(new Gtk::VBox(0,0),
		   gtkpack(gtkset_usize($up_box = new Gtk::VBox(0, 5), 500, 420),
			   $box = gtkpack_(new Gtk::VBox(0, 3),
					   0, new Gtk::Pixmap($pix_u_map, $pix_u_mask),
					   1, gtkpack_(new Gtk::HBox(0, 3),
						       0, new Gtk::Pixmap($pix_l_map, $pix_l_mask), 
						       1, createScrolledWindow( gtkpack(new Gtk::VBox(0,0),
											gtkadd(new Gtk::Frame(_("State of configuration file.")),
											       gtkpack(new Gtk::VBox(0,10),
												       $box_cfg_state,
												       ),),),),),
					   0, gtkpack_(new Gtk::HBox(0, 0),
						       0, new Gtk::Pixmap($pix_r_map, $pix_r_mask),
						       1, gtkpack_(new Gtk::VBox(0, 1),	
								   1, gtksignal_connect(new Gtk::Button(_(" Build Backup ")), 
											clicked => sub {  Gtk->main_quit() }),
								   1, gtksignal_connect(new Gtk::Button(_("     Restore      ")), 
										  clicked => sub {  Gtk->main_quit() }),
								   ),
						       ),
					   0, new Gtk::HSeparator,
					   0, new Gtk::HSeparator,
					   0, gtkpack_(gtkset_layout(new Gtk::HButtonBox, -end),
						       1, gtksignal_connect(new Gtk::Button(_("Advanced Conf.")), clicked => 
									    sub { ${$central_widget}->destroy(); advanced() }),
						       1, gtksignal_connect(new Gtk::Button(_("Wizard Conf.")), clicked => 
									    sub { ${$central_widget}->destroy(); wizard() }),
						       1, gtksignal_connect(new Gtk::Button(_("close")), clicked => 
									    sub {  Gtk->main_quit() }),
						       ),
					   ),
			   ),
		   ),
	   );
    $central_widget = \$box;
    $window1->show_all;
    $window1->realize;
    $window1->show_all();    
    Gtk->main;
    Gtk->exit(0);
}


sub after_adv {
    $interactive = 1;
    my $box_cfg_state;
    my $box_cgf_state_replace;
    my $box_cgf_state_comp;
    my $mask;
    my $style;
    my $box_cgf_state_sys = ("");
    my $box;
    init Gtk;
    my $text2 = new Gtk::Text(undef, undef);
    my $window1 = $::isEmbedded ? new Gtk::Plug ($::XID) : new Gtk::Window -toplevel;
    $window1->signal_connect (delete_event => sub { Gtk->exit(0) });
    $window1->set_position(1);
    $window1->set_title(_("Drakbackup"));
    
    my ($pix_u_map, $pix_u_mask) = gtkcreate_png("../pixmaps/backup_title.png");
    my ($pix_l_map, $pix_l_mask) = gtkcreate_png("../pixmaps/backup_left.png");
    my ($pix_b_map, $pix_b_mask) = gtkcreate_png("../pixmaps/backup_bot2.png");
    my ($pix_cd_map, $pix_cd_mask) = gtkcreate_png("../pixmaps/cdrom.png");
    my ($pix_hd2_map, $pix_hd2_mask) = gtkcreate_png("../pixmaps/hd.png");
    my ($pix_quit_map, $pix_quit_mask) = gtkcreate_png("../pixmaps/quit.png");
    
    my $button_burn_cd = new Gtk::Button();
    $button_burn_cd->add( gtkpack(new Gtk::HBox( 0, 2),
				  new Gtk::Pixmap($pix_cd_map, $pix_cd_mask),
				  _("Burn auto\n Install CDROM")
				  ),
			  );

    my $button_do_backup = new Gtk::Button();
    $button_do_backup->add( gtkpack(new Gtk::HBox( 0, 2),
				    new Gtk::Pixmap($pix_hd2_map, $pix_hd2_mask),
				    _("Build a \nbackupn now")
				    ),
			    );
    
    my $button_quit = new Gtk::Button();
    $button_quit->add( gtkpack(new Gtk::HBox( 0, 2),
			       new Gtk::Pixmap($pix_quit_map, $pix_quit_mask),
			       _("Quit DrakBackup")
			       ),
		       );

    read_conf_file();    
    $backup_sys or $box_cgf_state_sys = _("Do not include System Files");
    if ($option_replace) { $box_cgf_state_replace = _("Replace backups (do not update)"),
    } else { $box_cgf_state_replace = _("Update backups (do not replace)"),  }
    
    if ($comp_mode) { $box_cgf_state_comp = _("Backups use tar and gunzip "),
    } else { $box_cgf_state_comp = _("Backups use tar and gunzip"),   }
    
    if ($cfg_file_exist) { 
	my $label_cfg_file = new Gtk::Label _("Backup Sources: \n-System Files: @sys_files \n-Users Files: @user_list\n-Other Files to backup: @list_other\nPath to save backups: $save_path\nOptions:\n$box_cgf_state_replace\n$box_cgf_state_comp\n$box_cgf_state_sys\n");
	$box_cfg_state =  gtkpack(new Gtk::VBox( 0, 0),
				  gtkset_justify( $label_cfg_file , 'left'),
				  ),
    } else { $box_cfg_state =  gtkpack(new Gtk::VBox(0,1),
				       _("No configuration please click Wizard or Advanced.") ), }
    
    gtkadd($window1,
	   gtkpack(new Gtk::VBox(0,0),
		   gtkpack(gtkset_usize($up_box = new Gtk::VBox(0, 5), 500, 420),
			   $box = gtkpack_(new Gtk::VBox(0, 3),
					   0, new Gtk::Pixmap($pix_u_map, $pix_u_mask),
					   1, gtkpack_(new Gtk::HBox(0, 3),
						       0, new Gtk::Pixmap($pix_l_map, $pix_l_mask), 
						       1, createScrolledWindow( gtkpack(new Gtk::VBox(0,0),
								  gtkadd(new Gtk::Frame(_("State of configuration file.")),
									 gtkpack(new Gtk::VBox(0,10),
										 $box_cfg_state,
										 ),),),),),
					   0, new Gtk::Pixmap($pix_b_map, $pix_b_mask),
					   0, gtkpack_(new Gtk::HBox(0, 0),
						       1, gtkpack_(new Gtk::HBox(0, 1),	
								   1, gtksignal_connect($button_quit,  clicked => sub {
								       Gtk->main_quit() }),
								   1, gtksignal_connect($button_do_backup, clicked => sub { 
								       ${$central_widget}->destroy(); }),
								   1, gtksignal_connect($button_burn_cd, clicked => sub { 
								       ${$central_widget}->destroy(); }),
								   ),
						       ),
					   ),
			   ),
		   ),
	   );
    $central_widget = \$box;
    $window1->show_all;
    $window1->realize;
    $window1->show_all();    
    Gtk->main;
    Gtk->exit(0);
}

sub about {
    my $text = new Gtk::Text(undef, undef);
    my $about_box;
    gtkpack($up_box,
	    $about_box = gtkpack_(new Gtk::VBox(0,10),
				  1, gtkpack_(new Gtk::HBox(0,0),
					      1, gtktext_insert(gtkset_editable($text, 1), _("
 Copyright (C) 2001 by MandrakeSoft (sdupont\@mandrakesoft.com)

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

")),
					      0, new Gtk::VScrollbar($text->vadj),
					      ),
				  0, gtkadd(gtkset_layout(new Gtk::HButtonBox, -spread),
					    gtksignal_connect(new Gtk::Button(_("OK")), clicked => 
							      sub { ${$central_widget}->destroy(); 
								    $mdk_cc and interactive_mode();
								    $mdk_cc or interactive_mode_my();
								}),
					    ),
				  )
	    );
    $central_widget = \$about_box;
    $up_box->show_all();
}

sub adv_help {
    my $text = new Gtk::Text(undef, undef);
    my $about_box;
    gtkpack($up_box,
	    $about_box = gtkpack_(new Gtk::VBox(0,10),
				  1, gtkpack_(new Gtk::HBox(0,0),
					      1, gtktext_insert(gtkset_editable($text, 1), _("
description:

 Drakbacup is use to backup system files and user files
 Drakbacup allow to restore the system (etc, var files)
 from starup or on drakconf utility.

backup name format: all the time from the / dir.

	system backup:
                   backup_sys_12102001.tar.gz 
		   backup_sys_etc_var_proc_12102001.tar.gz
	user backup
		   backup_user_james_12102001.tar.gz      
		   backup_user_james_documents_12102001.tar.gz
	other directories
                   backup_other_proc_12102001.tar.gz          

backup name rules: system:   begin by sys
                   user:     begin by user
                   other:    begin by other
                   end of all `date`.tar.gz


save only the differences...
find / -mtime -1 \! -type d -print > /tmp/liste.jour

build iso fs with rescue.

configuration file:

	/etc/drakconf/drakbackup/drakbakup.conf

")),
					      0, new Gtk::VScrollbar($text->vadj),
					      ),
				  0, gtkadd(gtkset_layout(new Gtk::HButtonBox, -spread),
					    gtksignal_connect(new Gtk::Button(_("OK")), clicked => 
							      sub { ${$central_widget}->destroy(); advanced();  }),
					    ),
				  )
	    );
    $central_widget = \$about_box;
    $up_box->show_all();
}

