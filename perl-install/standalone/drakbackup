#!/usr/bin/perl
#
#  Copyright (C) 2001 MandrakeSoft by Sebastien DUPONT <dupont_s@epita.fr>
#  Redistribution of this file is permitted under the terms of the GNU
#  Public License (GPL)
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2, or (at your option)
#  any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#________________________________________________________________
#
#  Description:
#
#   Drakbackup is used to backup your system.
#   During the configuration you can select 
# 	- System files, 
# 	- Users files, 
# 	- Other files.
# 	or All your system ...  and Other (like windows Partitions)
#
#   Drakbackup allows you to backup your system on:
# 	- Harddrive.
# 	- NFS.
# 	- CDROM (CDRW), DVDROM (with autoboot, rescue and autoinstall.).
# 	- FTP.
# 	- Rsync.
# 	- Webdav.
# 	- Tape.
#
#   Drakbackup allows you to Restore your system on
#   choosen directory.
#
#   Per default all backup will be stored on your
#   /var/lib/drakbackup directory
#
#   Configuration file:
# 	/etc/drakconf/drakbackup/drakbakup.conf
#
#________________________________________________________________
#
#  Backup files formats:
#	
#	no incremental backup:
#			backup_sys_date_hour.tar.*
#			backup_user_toto_date_hour.tar.*
#			backup_other_date_hour.tar.*
#
#	first incremental backup: (if backup_base* does not exist )
#
#			backup_base_sys_date_hour.tar.*
#			backup_base_user_toto_date_hour.tar.*
#			backup_base_other_date_hour.tar.*
#			
#	other incremental backup: (if backup_base* already exist )
#
#			backup_incr_sys_date_hour.tar.*
#			backup_incr_user_toto_date_hour.tar.*
#			backup_incr_other_date_hour.tar.*
#
#________________________________________________________________
# 
# REQUIRE:      cron if daemon
#               cdrecord & mkisofs
#		perl Net::FTP
#		ssh-askpass
#
# BUGS :
#		restore->other_media->next->previous => crash ...
#		selection des sources a inclure dans le backup cd. 
#		help -> ok after install_rpm
#               
# TODO:
#		1 - print ftp problem for user. 
#	        2 - calcul disk space.
#		   use quota.
#               3 - ssh & rsync -> expect or .identity.pub/authorized_keys 
#		4 - write on cd --> ! change Joliet to HFS for Apple
#		5 - cd writer detection  -> cdrw: /sys/dev/cdrom/info  /scsi/host0/bus0/target4/lun0 
#			/proc/sys/dev/cdrom/
#		6 - total backup.( all partitions wanted, windows partitions for example!)
#		    dump use for total backup.
#		7 - custom deamon
#		8 - placer README dans $save_path -> prevenir des danger de supprimer la premier version
#		    explain configuration file variables (mainly for non X users)
#		9 - webdav
#	        10- backend : --resore_all, --restore_sys, --restore_users
#			  --build_cd_autoinst 	
#			  --backup_now --backup_default_now
#		11- tape device support		 
#		12- cpio use !!
#		13- boot floppy disk (with dialog)
#		14- build autoboot with backup and install cd 
#		15- use .backupignore like on CVS
#		16- afficher les modif dans un fichier texte du meme nom 
#			pour afficher durant le restore.
#		17- futur: could be possible to restore a specific file 
#			or directory at specific date. 
#		18- possible all files each time from directory.
#		               
# DONE TODAY:
#________________________________________________________________


use Gtk;
use lib qw(/usr/lib/libDrakX );

use standalone;     #- warning, standalone must be loaded very first, for 'explanations'

use interactive;
use my_gtk qw(:helpers :wrappers);
use common;
use strict;
use Time::localtime;

my $in = 'interactive'->vnew('', 'default');
$::isEmbedded = ($::XID, $::CCPID) = "@ARGV" =~ /--embedded (\w+) (\w+)/;

if ("@ARGV" =~ /--help|-h/) {
    print q(Backup and Restore application

--default             : save default directories.
--debug		      : show all debug messages.
--show-conf           : list of files or directories to backup.
--daemon              : use daemon configuration. 
--help                : show this message.
--version             : show version name.
);
    exit(0);
}

if ("@ARGV" =~ /--version/) {
    print "DrakBakckup Version 1.0\n";
    exit(0);
}

# Backend Options.      
my $central_widget;
my $previous_widget;
my $current_widget;
my $interactive;
my $up_box;
my $advanced_box;
my $box2;
my $cfg_file_exist = 0;
my @all_user_list;
my $list_other;
my $DEBUG = 0;
my $restore_sys = 1; 
my $restore_user = 1; 
my $restore_other = 1; 
my $restore_step_sys_date = "";
my @user_backuped = ();
my @sys_backuped = ();
my $sys_backuped = 0;
my $other_backuped = 0;
my @user_list_to_restore= ();
my @sys_list_to_restore = ();
my $cd_devive_entry;
my $custom_help;
my $button_box;
my $button_box_tmp;
my $next_widget;
my $system_state;
my $restore_state;
my $save_path_entry;
my $restore_find_path_entry;
my $pbar;
my $pbar1;
my $pbar2;
my $pbar3;
my $the_time;
my @user_list_to_restore2 = ();
my @data_backuped = ();
my $label_tail;
my @list_to_build_on_cd = (); 
my $restore_path = "/";
my $restore_other_path = 0;
my $restore_other_src;
my $path_to_find_restore;
my $other_media_hd;
my $backup_bef_restore = 0;
my $table;
my @user_list_backuped = ();
my @files_corrupted = ();
my $remove_user_before_restore = 1;
my @file_list_to_send_by_ftp = ();
my $results;

# config. FILES -> Default PATH  & Global variables.
my @sys_files = ("/etc");
my @user_list;
my @list_other = () ;
my $cfg_file = "/etc/drakxtools/drakbackup/drakbackup.conf";
my $save_path = "/var/lib/drakbackup";
my $comp_mode = 0;
my $backup_sys = 1;
my $backup_user = 1;
my $backup_daemon = 1;
my $backup_sys_versions = 1;
my $backup_user_versions = 1;
my $backup_other_versions = 0;
my $what_no_browser = 1;
my $cdrw = 0;
my $net_proto= '';
my $host_path = '';
my $login_user = '';
my $daemon = 0;
my $ssh_daemon = 0;
my $ftp_daemon = 0;
my $hd_daemon = 0;
my $cd_daemon = 0;
my $hd_quota = 0;
my $where_net_ftp = 0;
my $where_net_ssh = 0;
my $where_net = 0;
my $where_hd = 1;
my $where_cd = 0;
my $where_tape = 0;
my $cd_time = 650;
my $when_space;
my $cd_with_install_boot = 0;
my $cd_devive = '';
my $host_name = '';
my $backupignore = 0; 
my $auth_choice = 0;
my $remember_pass = 0;
my $passwd_user= '';
my $save_device_tape = ();
my $cdrw_erase = 0;
my $no_critical_sys = 1;
my $send_mail = 0;
my $user_mail;

foreach (@ARGV) {
    /--default/ and backend_mode();
    /--daemon/ and daemon_mode();
    /--show-conf/ and show_conf();
    /--debug/ and $DEBUG = 1, next;
}

sub show_conf {
    print "DrakBakckup configuration:\n\n";
    read_conf_file();
    system_state();
    print $system_state . "\n";
    exit(0);
}

sub backend_mode {
    build_backup_files();
    exit(0);
}

sub daemon_mode {
    $daemon = 1;
    build_backup_files();
    exit(0);
}

interactive_mode();

sub all_user_list {
    my ($username) = @_;
    my $passwdfile = "/etc/passwd";
    my $user;
    my $uid;
    @all_user_list = ();

    open (PASSWD, $passwdfile) or exit 1; 
    while (defined(my $line = <PASSWD>)) {
	chomp($line);
	($user, $uid) = (split(/:/, $line))[0, 2];
	if ($uid >= 500 || $uid == 0 ) {
	    push @all_user_list, $user;
	}
    }
    close (PASSWD);
    if ($DEBUG) {
	print "/--  User list  --/ \n";
	print " -> $_\n" foreach (@all_user_list);
	print "\n";
    }
}

sub the_time {
    $the_time = "_";
    $the_time .= localtime->year() + 1900;
    if (localtime->mon() < 9 ) { $the_time .= "0"; }
    $the_time .= localtime->mon() +1;
    if (localtime->mday() < 10 ) { $the_time .= "0"; }
    $the_time .= localtime->mday();
    $the_time .= "_";
    if (localtime->hour() < 10 ) { $the_time .= "0"; }
    $the_time .= localtime->hour();
    if (localtime->min() < 10 ) { $the_time .= "0"; }
    $the_time .= localtime->min();
    if (localtime->sec() < 10 ) { $the_time .= "0"; }
    $the_time .= localtime->sec();    
}

sub save_conf_file {
    my @cfg_list = ( "SYS_FILES=@sys_files\n",
		     "HOME_FILES=@user_list\n", 
		     "OTHER_FILES=@list_other\n",
		     "PATH_TO_SAVE=$save_path\n",
		     "HOST_PATH=$host_path\n",
		     "NET_PROTO=$net_proto\n",
		     "CD_TIME=$cd_time\n",
		     "USER_MAIL=$user_mail\n",		     
		     "DAEMON_TIME_SPACE=$when_space\n",
		     "CDRW_DEVICE=$cd_devive\n",
		     "LOGIN=$login_user\n",
		     "TAPE_DEVICE=$save_device_tape\n",
		     "HOST_NAME=$host_name\n"
		     );
    $no_critical_sys and push @cfg_list, "NO_CRITICAL_SYS\n" ; 
    $no_critical_sys or push @cfg_list, "CRITICAL_SYS\n" ; 
    $send_mail and push @cfg_list, "SEND_MAIL\n";
    $backup_sys_versions and push @cfg_list, "SYS_INCREMENTAL_BACKUPS\n" ; 
    $backup_user_versions and push @cfg_list, "USER_INCREMENTAL_BACKUPS\n" ; 
    $backup_other_versions  and push @cfg_list, "OTHER_INCREMENTAL_BACKUPS\n" ; 
    $cdrw_erase and push @cfg_list, "CDRW_ERASE\n" ; 
    $where_net_ftp and push @cfg_list, "USE_NET_FTP\n" ; 
    $where_net_ssh and push @cfg_list, "USE_NET_SSH\n" ; 
    $remember_pass and push @cfg_list, "LOGIN=$login_user\n" ; 
    $remember_pass and push @cfg_list, "PASSWD=$passwd_user\n" ;
    $remember_pass and push @cfg_list, "REMEMBER_PASS\n" ;
    $auth_choice or push @cfg_list, "AUTH_CHOICE=0\n" ;
    if ($auth_choice == 1) { push @cfg_list, "AUTH_CHOICE=1\n" ;}
    if ($auth_choice == 2) { push @cfg_list, "AUTH_CHOICE=2\n" ;}
    $cd_with_install_boot and push @cfg_list, "CD_WITH_INSTALL_BOOT\n" ;
    $ssh_daemon and push @cfg_list, "SSH_DAEMON\n" ;
    $ftp_daemon and push @cfg_list, "FTP_DAEMON\n" ;
    $hd_daemon and push @cfg_list, "HD_DAEMON\n" ;
    $cd_daemon and push @cfg_list, "CD_DAEMON\n" ;
    $hd_quota and  push @cfg_list, "HD_QUOTA\n" ;
    $where_hd and  push @cfg_list, "USE_HD\n" ;
    $where_cd and  push @cfg_list, "USE_CD\n" ;
    $where_net and  push @cfg_list, "USE_NET\n" ;
    $cdrw and push @cfg_list, "CDRW\n"; 
    $what_no_browser or push @cfg_list, "BROWSER_CACHE\n" ;
    $backup_sys or push @cfg_list,  "NO_SYS_FILES\n";
    if ($comp_mode) {push @cfg_list, "OPTION_COMP=TAR.BZ2\n"} 
    else { push @cfg_list, "OPTION_COMP=TAR.GZ\n"   }
    output_p($cfg_file, @cfg_list);
    system("chmod 600 $cfg_file");
    save_cron_files();
}

sub read_cron_files {
    my $daemon_found = 0;
    foreach (qw(hourly daily weekly monthly)) {
	if (-f "/etc/cron.$_/drakbackup") {
	    $when_space = $_;	    
	    $daemon_found = 1;
	    last;
	}

    }
    !$daemon_found and $backup_daemon = 0; 
}

sub save_cron_files {
    my @cron_file = ("#!/bin/sh\n", "\n", "/usr/sbin/drakbackup --daemon" );

    if ($backup_daemon) {
	foreach (qw(hourly daily weekly monthly)) {
	    -f "/etc/cron.$_/drakbackup" and rm_rf("/etc/cron.$_/drakbackup");
	}
	output_p("/etc/cron.$when_space/drakbackup",  @cron_file );
	system("chmod +x /etc/cron.$when_space/drakbackup");
    } else {
	foreach (qw(hourly daily weekly monthly)) {
	    -f "/etc/cron.$_/drakbackup" and rm_rf("/etc/cron.$_/drakbackup");
	}
    }
}

sub read_conf_file {
    if (-e $cfg_file) {
        open ( CONF_FILE, "<"."$cfg_file") || print "You must be root to read configuration file. \n" ;
        while (<CONF_FILE>) {
	    next unless /\S/;
	    next if /^#/;
	    chomp;
	    if (/^SYS_FILES/)           { s/^SYS_FILES=//gi;    @sys_files = split(' ', $_ );	}
	    if (/^HOME_FILES/)		{ s/^HOME_FILES=//gi;   @user_list = split(' ', $_ );	}
	    if (/^OTHER_FILES/)		{ s/^OTHER_FILES=//gi;  @list_other = split(' ', $_ );	}
	    if (/^PATH_TO_SAVE/)	{ s/^PATH_TO_SAVE=//gi; $save_path = $_;	}
	    if (/^NO_SYS_FILES/)   { $backup_sys = 0;}
	    if (/^NO_USER_FILES/)  { $backup_user = 0;}
	    if (/^OPTION_COMP/)    { s/^OPTION_COMP=//gi; /TAR.GZ/ and  $comp_mode = 0; /TAR.BZ2/ and $comp_mode = 1; }
	    if (/^BROWSER_CACHE/)  { $what_no_browser = 0; }
	    if (/^CDRW/)           { $cdrw = 1; }
	    if (/^NET_PROTO/)      { s/^NET_PROTO=//gi; $net_proto = $_; }
	    if (/^HOST_PATH/)      { s/^HOST_PATH=//gi; $host_path = $_; } 
	    if (/^SSH_DAEMON/)	   { $ssh_daemon = 1; }
	    if (/^FTP_DAEMON/)	   { $ftp_daemon = 1; }
	    if (/^HD_DAEMON/)	   { $hd_daemon = 1; }
	    if (/^CD_DAEMON/)	   { $cd_daemon = 1; }
	    if (/^HD_QUOTA/)       { $hd_quota = 1;  }
	    if (/^USE_HD/)         { $where_hd = 1;  }
	    if (/^USE_CD/)         { $where_cd = 1;  }
	    if (/^USE_NET/)        { $where_net = 1; }
	    if (/^USE_TAPE/)       { $where_tape = 1; }
	    if (/^CD_TIME/)        { s/^CD_TIME=//gi; $cd_time = $_; }
	    if (/^DAEMON_TIME_SPACE/) { s/^DAEMON_TIME_SPACE=//gi; $when_space = $_; }
	    if (/^CD_WITH_INSTALL_BOOT/) { $cd_with_install_boot = 1; }
	    if (/^CDRW_DEVICE/)    { s/^CDRW_DEVICE=//gi; $cd_devive = $_;}
	    if (/^HOST_NAME/)      { s/^HOST_NAME=//gi; $host_name = $_;} 
	    if (/^AUTH_CHOICE/)    { s/^AUTH_CHOICE=//gi; $auth_choice = $_; }
	    if (/^REMEMBER_PASS/)  { $remember_pass = 1; }
	    if (/^LOGIN/)          { s/^LOGIN=//gi;  $login_user  = $_; $remember_pass = 1; }
	    if (/^PASSWD/)         { s/^PASSWD=//gi; $passwd_user = $_; $remember_pass = 1; }
	    if (/^USER_MAIL/)      { s/^USER_MAIL=//gi; $user_mail= $_; }		     
	    if (/^USE_NET_FTP/)    { $where_net_ftp = 1;  }
	    if (/^SEND_MAIL/)      { $send_mail = 1;  }
	    if (/^USE_NET_SSH/)    { $where_net_ssh = 1;  }
	    if (/^TAPE_DEVICE/)    { s/TAPE_DEVICE=//gi; $save_device_tape = $_;}
	    if (/^CDRW_ERASE/)     { $cdrw_erase = 1;}
	    if (/^SYS_INCREMENTAL_BACKUPS/)   { $backup_sys_versions = 1;}
	    if (/^USER_INCREMENTAL_BACKUPS/)  { $backup_user_versions = 1;}
	    if (/^OTHER_INCREMENTAL_BACKUPS/) { $backup_other_versions = 1;}
	    if (/^NO_CRITICAL_SYS/)  { $no_critical_sys = 1;}
	    if (/^CRITICAL_SYS/)  { $no_critical_sys = 0;}
	}
	read_cron_files();
	$cfg_file_exist = 1;
    } 
    else { $cfg_file_exist = 0; }
    close CONF_FILE;    
}

sub complete_results {
    system_state();
    $results .=  _("***********************************************************************\n\n");
    $daemon or $results .=  _("\n                      DrakBackup Report \n\n");
    $daemon and $results .= _("\n                      DrakBackup Daemon Report\n\n\n");
    $results .=  _("***********************************************************************\n\n");
    $results .= $system_state;
    $results .=  _("\n\n***********************************************************************\n\n");
    $results .=             _("\n                    DrakBackup Report Details\n\n\n");
    $results .=  _("***********************************************************************\n\n");
}


sub ftp_client {
    use Net::FTP; 
    my $ftp;

    $DEBUG and print "file list to send : $_\n "  foreach @file_list_to_send_by_ftp;
    if ($DEBUG && $interactive) { $ftp = Net::FTP->new("$host_name", Debug => 1) or return(1);  }
    elsif ($interactive)  {  $ftp = Net::FTP->new("$host_name", Debug => 0) or return(1); }
    else {  $ftp = Net::FTP->new("$host_name", Debug => 0) or return(1); }
    $ftp->login("$login_user","$passwd_user");
    $ftp->cwd("$host_path"); 
    foreach (@file_list_to_send_by_ftp) {
	$pbar->set_value(0);
	$interactive and progress($pbar, 0.5, $_);
	$interactive and $pbar->set_show_text( $_ );
	$ftp->put("$_");
	$interactive and progress($pbar, 0.5, $_);
	$interactive and $pbar->set_show_text( $_ );
	$interactive and progress($pbar3, 1/@file_list_to_send_by_ftp, _("total progess"));
    }
    $ftp->quit; 
    return(0);
}

sub ssh_client {
    system("scp @file_list_to_send_by_ftp root\@petra:.");
}

sub write_on_cd {
#  system("cdrecord ");
}

sub build_iso {
#    system("mkisofs -r -J -T -v -V 'Drakbackup' -o drakbackup.iso /var/lib/drakbackup");
}

sub build_cd {
    build_iso();
}

sub send_mail {
    my ($result) = @_;
    my $datem = `date`;

    open F, "|/usr/sbin/sendmail -f$user_mail $user_mail" or return(1);
    print F "From: drakbackup\n";
    print F "To: $user_mail \n";
    print F "Subject: DrakBackup report on $datem \n";
    print F "\n";
    print F "$result\n";
    close F or  return(1);
    return(0);
}


sub build_backup_files {
    my $path_name;
    my $tar_cmd;
    my $more_recent;
    my $tar_cmd_sys;
    my $tar_cmd_user;
    my $tar_cmd_other;
    my $tar_ext;
    my $vartemp;
    my $base_sys_exist = 0;
    my $base_user_exist = 0;
    my $base_other_exist = 0;
    my @list_temp = ();
    my @list_other_;
    my @dir_content = ();
    my $file_date;
    $results = "";

    read_conf_file();
    the_time();    
    $send_mail and complete_results();
    -d  $save_path or mkdir_p($save_path);
    if ($comp_mode) { 
	$DEBUG and $tar_cmd = "tar cv --use-compress-program /usr/bin/bzip2 ";
	$DEBUG or $tar_cmd = "tar c --use-compress-program /usr/bin/bzip2 "; 
	$tar_ext = "tar.bz2" ;
    }
    else { 
	$DEBUG and $tar_cmd = "tar cvpz "; 
	$DEBUG or $tar_cmd = "tar cpz "; 
	$tar_ext = "tar.gz"
	}
    $tar_cmd_sys = $tar_cmd;
    $tar_cmd_user = $tar_cmd;
    $tar_cmd_other = $tar_cmd;
    $no_critical_sys and $tar_cmd_sys .= "--exclude passwd --exclude fstab --exclude group --exclude mtab";
    $what_no_browser and $tar_cmd_user .= "--exclude NewCache --exclude Cache --exclude cache";

    -d $save_path and @dir_content = all($save_path);
    grep (/^backup\_base\_sys/, @dir_content) and $base_sys_exist = 1;

    if (($where_hd && !$daemon) || ($daemon && $hd_daemon)) {
	$interactive and progress($pbar, 0.5, _("Backup system files..."));
	if ($backup_sys) { 
	    if ($backup_sys_versions) {
 		if (grep /^backup\_incr\_sys/, @dir_content) { 
		    my @more_recent = grep /^backup\_incr\_sys/, sort @dir_content; 
		    $more_recent = pop @more_recent;
		    $DEBUG and print "more recent file: $more_recent\n";
 system("find @sys_files -cnewer $save_path/$more_recent \! -type d -print > $save_path/list_incr_sys$the_time.txt");
		    if (!cat_("$save_path/list_incr_sys$the_time.txt")) {
			system("rm $save_path/list_incr_sys$the_time.txt");
		    } else {
 system("$tar_cmd_sys -f $save_path/backup_incr_sys$the_time.$tar_ext -T $save_path/list_incr_sys$the_time.txt");
 push @file_list_to_send_by_ftp, "$save_path/backup_incr_sys$the_time.$tar_ext";
 push @file_list_to_send_by_ftp, "$save_path/list_incr_sys$the_time.txt";
 $results .= "\nfile: $save_path/backup_incr_sys$the_time.$tar_ext\n";
 $results .= cat_("$save_path/list_incr_sys$the_time.txt");
		    }
		}
  		elsif (grep /^backup\_base\_sys/,  @dir_content) { 
		    my @more_recent = grep /^backup\_base\_sys/, sort @dir_content; 
		    $more_recent = pop @more_recent;
		    $DEBUG and print "more recent file: $more_recent\n";
  system("find @sys_files -cnewer $save_path/$more_recent \! -type d -print > $save_path/list_incr_sys$the_time.txt");
		    if (!cat_("$save_path/list_incr_sys$the_time.txt")) {
			system("rm $save_path/list_incr_sys$the_time.txt");
		    } else {
  system("$tar_cmd_sys -f $save_path/backup_incr_sys$the_time.$tar_ext -T $save_path/list_incr_sys$the_time.txt");
  push @file_list_to_send_by_ftp, "$save_path/backup_incr_sys$the_time.$tar_ext";
  push @file_list_to_send_by_ftp, "$save_path/list_incr_sys$the_time.txt";
  $results .= "\nfile: $save_path/backup_incr_sys$the_time.$tar_ext\n";
  $results .= cat_("$save_path/list_incr_sys$the_time.txt");
		    }
		   }
		else { 
  system("$tar_cmd_sys -f $save_path/backup_base_sys$the_time.$tar_ext @sys_files"); 
  push @file_list_to_send_by_ftp, "$save_path/backup_base_sys$the_time.$tar_ext";
  $results .= "\nfile: $save_path/backup_base_sys$the_time.$tar_ext\n";
		}
	    }
	    else {
#  system("cd $save_path && rm -f backup_sys* backup_base_sys* backup_incr_sys*");
  system("$tar_cmd_sys -f $save_path/backup_sys$the_time.$tar_ext @sys_files");
  push @file_list_to_send_by_ftp, "$save_path/backup_sys$the_time.$tar_ext";
  $results .= "\nfile: $save_path/backup_sys$the_time.$tar_ext\n";
	    }
	}
	
	$interactive and progress($pbar, 0.5, _("Backup system files..."));
	$interactive and progress($pbar3, 0.3, _("Hard Disk Backup files..."));

	if (@list_other) {
  system("cd $save_path && rm -f backup_other* ");
  system("$tar_cmd_other -f $save_path/backup_other$the_time.$tar_ext @list_other");
  push @file_list_to_send_by_ftp, "$save_path/backup_other$the_time.$tar_ext";
  $results .= "\nfile: $save_path/backup_other$the_time.$tar_ext\n";
#old	    foreach (@list_other) { push @list_other_, $_ . "\n"; }
	    @list_other_ = map { "$_\n" } @list_other;
	    output_p( $save_path . '/list_other', @list_other_);    
	}
	
	$interactive and progress($pbar1, 1, _("Backup User files..."));
	$interactive and progress($pbar3, 0.3, _("Hard Disk Backup Progress..."));
	
	if ($backup_user) {
	    foreach (@user_list) {
		my $user = $_;
		$path_name = return_path($user);
		if ($backup_user_versions) {
		    if (grep(/^backup\_incr\_user\_$user\_/, @dir_content)) { 
			my @more_recent = grep /^backup\_incr\_user\_$user\_/, sort @dir_content; 
			$more_recent = pop @more_recent;
			$DEBUG and print "more recent file: $more_recent\n";
 system("find $path_name -cnewer $save_path/$more_recent \! -type d -print > $save_path/list_incr_user_$user$the_time.txt");
			if (!cat_("$save_path/list_incr_user_$user$the_time.txt")) {
			    system("rm $save_path/list_incr_user_$user$the_time.txt");
			} else {
 system("$tar_cmd_user -f $save_path/backup_incr_user_$user$the_time.$tar_ext -T $save_path/list_incr_user_$user$the_time.txt");
 push @file_list_to_send_by_ftp, "$save_path/backup_incr_user_$user$the_time.$tar_ext";
 push @file_list_to_send_by_ftp, "$save_path/list_incr_user_$user$the_time.txt";
 $results .= " \nfile: $save_path/backup_incr_user_$user$the_time.$tar_ext\n";
 $results .= cat_("$save_path/list_incr_user_$user$the_time.txt");
			}
		    }
		    elsif (grep /^backup\_base\_user\_$user\_/, @dir_content) { 
			my @more_recent = grep /^backup\_base\_user\_$user\_/, sort @dir_content; 
			$more_recent = pop @more_recent;			
			$DEBUG and print "more recent file: $more_recent\n";
 system("find $path_name -cnewer $save_path/$more_recent \! -type d -print > $save_path/list_incr_user_$user$the_time.txt");
			if (!cat_("$save_path/list_incr_user_$user$the_time.txt")) {
			    system("rm $save_path/list_incr_user_$user$the_time.txt");
			} else {
 system("$tar_cmd_user -f $save_path/backup_incr_user_$user$the_time.$tar_ext -T $save_path/list_incr_user_$user$the_time.txt");
 push @file_list_to_send_by_ftp, "$save_path/backup_incr_user_$user$the_time.$tar_ext";
 push @file_list_to_send_by_ftp, "$save_path/list_incr_user_$user$the_time.txt";
 $results .= "\nfile: $save_path/backup_incr_user_$user$the_time.$tar_ext\n";
 $results .= cat_("$save_path/list_incr_user_$user$the_time.txt");
			}
		    }
		    else {
			system("$tar_cmd_user -f $save_path/backup_base_user_$user$the_time.$tar_ext $path_name");
			push @file_list_to_send_by_ftp, "$save_path/backup_base_user_$user$the_time.$tar_ext";
			$results .= "\nfile: $save_path/backup_base_user_$user$the_time.$tar_ext\n";
		    }
		} else {
		    system("cd $save_path && rm -f backup_user_$_* backup_base_user_$_* backup_incr_user_$_*");
		    system("$tar_cmd_user -f $save_path/backup_user_$_$the_time.$tar_ext $path_name");
		    push @file_list_to_send_by_ftp, "$save_path/backup_user_$_$the_time.$tar_ext";
		    $results .= "\nfile: $save_path/backup_user_$user$the_time.$tar_ext\n";
		}
	    }
	}
	$interactive and progress($pbar2, 1, _("Backup Other files..."));
	$interactive and progress($pbar3, 0.4, _("Hard Disk Backup files..."));
    }

    if (($where_net_ssh && !$daemon) || ($daemon && $ssh_daemon)) {
	#ssh_client();
    }
    if (($where_net_ftp && !$daemon) || ($daemon && $ftp_daemon)) {
	$results .= _("file list send by FTP : %s\n ", $_)  foreach @file_list_to_send_by_ftp;
	$interactive and build_backup_ftp_status();
	if (ftp_client()) { 
	    $results .= _("\n(!) FTP connexion problem: It was not possible to send your backup files by FTP.\n");
	    $interactive and client_ftp_pb();
	} 
    }
    if (($where_cd && !$daemon) || ($daemon && $cd_daemon)) {
	build_cd();
    }
    if ($send_mail) { 
	if (send_mail("$results")) { 
	    $interactive and send_mail_pb();
	    $interactive or print _("(!) Error during mail sending. \n");
	} 
    }
}


my @list_of_rpm_to_install;
sub require_rpm {
    my $all_rpms_found = 1;
    my $res;
    my @file_cache =  cat_("/var/log/rpmpkgs");
    @list_of_rpm_to_install = ();
#    my($pkg) = @_;
    foreach my $pkg (@_) {
	$res = grep /$pkg/, @file_cache;
#	$res = system("rpm -qa | grep $_");
	if ($res == 0) { $all_rpms_found = 0; push @list_of_rpm_to_install, $pkg;}
    }
    return($all_rpms_found);
}

sub list_remove {
    my($widget, $list) = @_;
    my @to_remove;
    push @to_remove, $list->child_position($_) foreach($list->selection);
    splice @list_other, $_, 1 foreach(reverse sort @to_remove);
    $list->remove_items($list->selection);
}

sub file_ok_sel { 
    my ( $widget, $file_selection ) = @_;     
    my $file_name = $file_selection->get_filename();
    if(!member($file_name, @list_other)) {
	push(@list_other, $file_name);
	$list_other->add(gtkshow(new Gtk::ListItem($file_name)));
    }
}

sub filedialog_where_hd {
    my $file_dialog;

    $file_dialog = gtksignal_connect(new Gtk::FileSelection(_("File Selection")), destroy => sub { $file_dialog->destroy(); } );
    $file_dialog->ok_button->signal_connect(clicked => sub { 
	$save_path_entry->set_text($file_dialog->get_filename()); 
	$file_dialog->destroy() });
    $file_dialog->cancel_button->signal_connect(clicked => sub { $file_dialog->destroy() });
    $file_dialog->show();
}

sub filedialog_restore_find_path {
    my $file_dialog;

    $file_dialog = gtksignal_connect(new Gtk::FileSelection(_("File Selection")), destroy => sub { $file_dialog->destroy(); } );
    $file_dialog->ok_button->signal_connect(clicked => sub { 
	$restore_find_path_entry->set_text($file_dialog->get_filename()); 
	$file_dialog->destroy() });
    $file_dialog->cancel_button->signal_connect(clicked => sub { $file_dialog->destroy() });
    $file_dialog->show();
}

sub filedialog {
    my $file_dialog;

    $file_dialog = gtksignal_connect(new Gtk::FileSelection(_("File Selection")), destroy => sub { $file_dialog->destroy(); } );
    $file_dialog->ok_button->signal_connect(clicked => \&file_ok_sel, $file_dialog);
    $file_dialog->ok_button->child->set(_("Add"));
    $file_dialog->cancel_button->signal_connect(clicked => sub { $file_dialog->destroy() });
    $file_dialog->cancel_button->child->set(_("Close"));
    $file_dialog->set_filename(_("Select the files or directories and click on 'Add'"));
    $file_dialog->show();
}

################################################  ADVANCED  ################################################  

sub check_list {
    foreach (@_) {
	my $ref = $_->[1];
	gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => sub { invbool $ref })
	}
}

sub fonction_env {
    ($central_widget, $current_widget, $previous_widget, $custom_help, $next_widget) = @_;
}

# sub redraw_during_check {
#     my ($tmp1, $tmp2) = @_;
#     gtksignal_connect(gtkset_active($tmp1, $tmp2), toggled => sub { 
# #	invbool \$tmp2;
# 	print "tmp2 bef = $tmp2\n";
# 	$tmp2 = $tmp2 ? 0 : 1;
# 	${$central_widget}->destroy();
# 	print "tmp2 after = $tmp2\n";
# 	$current_widget->();
# 	return ($tmp2);
#     });
# }

sub advanced_what_sys {
    my $box_what_sys;
    
    gtkpack($advanced_box,
	    $box_what_sys =  gtkpack_(new Gtk::VBox(0, 15),
		     1, _("\nPlease check all options that you need.\n"),
		     1, _("These options can backup and restore all files in your /etc directory.\n"),
		     0, my $check_what_sys = new Gtk::CheckButton( _("Backup your System files. ( /etc directory )")),
		     0, my $check_what_versions = new Gtk::CheckButton( _("Use incremental backup  (do not replace old backups)") ),
		     0, my $check_what_critical = new Gtk::CheckButton( _("Do not include critical files (passwd, group, fstab)") ),
		     0, _("With this option you will be able to restore any version\n of your /etc directory."),
		     1, new Gtk::VBox(0, 15),
		     ),
	    );
    check_list([$check_what_sys, \$backup_sys], [$check_what_critical, \$no_critical_sys], [$check_what_versions, \$backup_sys_versions]);
    fonction_env(\$box_what_sys, \&advanced_what_sys, \&advanced_what, "what");
    $up_box->show_all();
}

sub advanced_what_user {
    my ($previous_function) = @_,
    my $box_what_user;
    my %check_what_user;
    
    all_user_list();
    gtkpack($advanced_box,
	    $box_what_user = gtkpack_(new Gtk::VBox(0, 15),
				      0, _("Please check all users that you want to include in your backup."),
				      0, new Gtk::HSeparator,
				      1, createScrolledWindow( 
						gtkpack__(new Gtk::VBox(0,0),
							map { my $name = $_;
							      my @user_list_tmp;
							      my $b = new Gtk::CheckButton($name); 
							      if (grep /^$name$/, @user_list) {
								  $check_what_user{$_}[1] = 1;
								  gtkset_active($b, 1);
							      } else {
								  $check_what_user{$_}[1] = 0;
								  gtkset_active($b, 0);
							      }
							      $b->signal_connect(toggled => sub { 
								  if ($check_what_user{$name}[1] ) {
								      $check_what_user{$name}[1] = 0;
								      @user_list_tmp = grep(!/^$name$/, @user_list);
								      @user_list = @user_list_tmp;
								  } else { 
								      $check_what_user{$name}[1] = 1;
								      if (!member($name, @user_list) ) {push @user_list, $name;}
								  }
							      });
							      $b } (@all_user_list) 
							),
							       ),
				      0, my $check_what_browser = new Gtk::CheckButton( _("Do not include the browser cache") ),
	    0, my $check_what_user_versions = new Gtk::CheckButton( _("Use Incremental Backups  (do not replace old backups)") ),
				      ),
	    );
    check_list([$check_what_browser, \$what_no_browser], [$check_what_user_versions, \$backup_user_versions]);
    if ($previous_function) { fonction_env(\$box_what_user, \&advanced_what_user, \&$previous_function, "what", \&$previous_function);}
    else { fonction_env(\$box_what_user, \&advanced_what_user, \&advanced_what, "what");}
    $up_box->show_all();
}

sub advanced_what_other {
    my $box_what_other;
    $list_other = new Gtk::List();
    $list_other->set_selection_mode(-extended);
    $list_other->add(gtkshow(new Gtk::ListItem($_))) foreach (@list_other);
    
    gtkpack($advanced_box,
	    $box_what_other = gtkpack_(new Gtk::VBox(0, 15),
		     1, gtkpack_(new Gtk::HBox(0,4),
				 1, createScrolledWindow($list_other),
				 ),
		     0, gtkadd(gtkset_layout(new Gtk::HButtonBox, -spread),
			       gtksignal_connect(new Gtk::Button(_("Add")), clicked => sub {filedialog()  }),
			       gtksignal_connect(new Gtk::Button(_("Remove Selected")), clicked => \&list_remove, $list_other),
			       ),
		     0, gtkset_sensitive(my $check_what_other_versions = new Gtk::CheckButton( _("Use Incremental Backups  (do not replace old backups)") ), 0),
		     ),
	    );
    check_list([$check_what_other_versions, \$backup_other_versions]);
    fonction_env(\$box_what_other, \&advanced_what_other, \&advanced_what, "what");
    $up_box->show_all();
}

sub advanced_what_entire_sys{
    my $box_what;
    
    my ($pix_user_map, $pix_user_mask) = gtkcreate_png("user");
    my ($pix_other_map, $pix_other_mask) = gtkcreate_png("net_u");
    my ($pix_sys_map, $pix_sys_mask) = gtkcreate_png("bootloader");

    gtkpack($advanced_box,
	    $box_what = gtkpack_(new Gtk::HBox(0, 15),
		     1, new Gtk::VBox(0, 5),
		     1, gtkpack_(new Gtk::VBox(0, 15),	
				 1, new Gtk::VBox(0, 5),
				 1, gtksignal_connect(my $button_what_other = new Gtk::Button(), 
						      clicked => sub { ${$central_widget}->destroy(); message_underdevel(); }),
				 1, gtksignal_connect(my $button_what_all = new Gtk::Button(), 
						      clicked => sub { ${$central_widget}->destroy(); message_underdevel(); }),
				 1, new Gtk::VBox(0, 5),
				 ),
		     1, new Gtk::VBox(0, 5),	
		     ),
	    );
    $button_what_other->add(gtkpack(new Gtk::HBox(0,10),
				    new Gtk::Pixmap($pix_sys_map, $pix_sys_mask),
				    new Gtk::Label(_("Linux")),
				    new Gtk::HBox(0, 5)
				    ));
    $button_what_all->add(gtkpack(new Gtk::HBox(0,10),
				  new Gtk::Pixmap($pix_user_map, $pix_user_mask),
				   new Gtk::Label(_("Windows (FAT32)")),
				  new Gtk::HBox(0, 5)
				  ));
    fonction_env(\$box_what, \&advanced_what_entire_sys, \&advanced_what, "");
    $up_box->show_all();
}

sub advanced_what{
    my $box_what;    
    my ($pix_user_map, $pix_user_mask) = gtkcreate_png("ic82-users-40");
    my ($pix_other_map, $pix_other_mask) = gtkcreate_png("ic82-others-40");
    my ($pix_sys_map, $pix_sys_mask) = gtkcreate_png("ic82-system-40");
    my ($pix_sysp_map, $pix_sysp_mask) = gtkcreate_png("ic82-systemeplus-40");

    gtkpack($advanced_box,
	    $box_what =  gtkpack_(new Gtk::HBox(0, 15),
		     1, new Gtk::VBox(0, 5),
		     1, gtkpack_(new Gtk::VBox(0, 15),	
				 1, new Gtk::VBox(0, 5),
				 1, gtksignal_connect(my $button_what_sys = new Gtk::Button(), 
						      clicked => sub { $box_what->destroy(); advanced_what_sys(); }),
				 1, gtksignal_connect(my $button_what_user = new Gtk::Button(), 
						      clicked => sub { ${$central_widget}->destroy(); advanced_what_user();}),
				 1, gtksignal_connect(my $button_what_other = new Gtk::Button(), 
						      clicked => sub { ${$central_widget}->destroy(); advanced_what_other(); }),
#				 1, gtksignal_connect(my $button_what_all = new Gtk::Button(), 
#						  clicked => sub { ${$central_widget}->destroy(); advanced_what_entire_sys(); }),
				 1, new Gtk::VBox(0, 5),
				 ),
		     1, new Gtk::VBox(0, 5),	
				 ),
	    );
    $button_what_sys->add(  gtkpack(new Gtk::HBox(0,10),
				    new Gtk::Pixmap($pix_sys_map, $pix_sys_mask),
				    new Gtk::Label(_("System")),
				    new Gtk::HBox(0, 5)
				    ));
    $button_what_user->add( gtkpack(new Gtk::HBox(0,10),
				    new Gtk::Pixmap($pix_user_map, $pix_user_mask),
				    new Gtk::Label(_("Users")),
				    new Gtk::HBox(0, 5)
				    ));
    $button_what_other->add(gtkpack(new Gtk::HBox(0,10),
				    new Gtk::Pixmap($pix_other_map, $pix_other_mask),
				    new Gtk::Label(_("Other")),
				    new Gtk::HBox(0, 5)
				    ));
#     $button_what_all->add(gtkpack(new Gtk::HBox(0,10),
# 				    new Gtk::Pixmap($pix_sysp_map, $pix_sysp_mask),
# 				    new Gtk::Label(_("An Entire System")),
# 				    new Gtk::HBox(0, 5)
# 				    ));

    fonction_env(\$box_what, \&advanced_what, \&advanced_box, "");
    $up_box->show_all();
}

sub advanced_where_net_ftp {
    my ($previous_function) = @_,
    my $box_where_net;
    
    gtkpack($advanced_box,
	    $box_where_net = gtkpack_(new Gtk::VBox(0, 15),
	 0, new Gtk::HSeparator,
	 0, my $check_where_net_ftp = new Gtk::CheckButton( _("Use FTP connection to backup") ),
	 0, new Gtk::HSeparator,
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please enter the host name or IP.")), $where_net_ftp),
		     1, new Gtk::HBox(0,10),
		     0, gtkset_sensitive(my $host_name_entry = new Gtk::Entry(), $where_net_ftp),
		     ),
	 0, gtkpack_(new Gtk::HBox(0,10),
	 0, gtkset_sensitive(new Gtk::Label(_("Please enter the directory to\n put the backup on this host.")), $where_net_ftp),
		     1, new Gtk::HBox(0,10),
		     0, gtkset_sensitive(my $host_path_entry = new Gtk::Entry(), $where_net_ftp), 
		     ),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please enter your login")), $where_net_ftp),
		     1, new Gtk::HBox(0,10),
		     0, gtkset_sensitive(my $login_user_entry = new Gtk::Entry(), $where_net_ftp),
		     ),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please enter your password")),  $where_net_ftp),
		     1, new Gtk::HBox(0,10),
		     0, gtkset_sensitive(my $passwd_user_entry = new Gtk::Entry(), $where_net_ftp),
		     ),
	 0, gtkpack_(new Gtk::HBox(0,10),
	   1, new Gtk::HBox(0,10),
	   0, gtkset_sensitive(my $check_remember_pass = new Gtk::CheckButton( _("Remember this password")), $where_net_ftp),
		     ),
	 ),
	    );
    $passwd_user_entry->set_visibility(0);
    $passwd_user_entry->set_text( $passwd_user );
    $passwd_user_entry->signal_connect( 'changed', sub { $passwd_user = $passwd_user_entry->get_text()});
    $host_path_entry->set_text( $host_path );
    $host_name_entry->set_text( $host_name );
    $login_user_entry->set_text( $login_user );
    $host_name_entry->signal_connect( 'changed', sub { $host_name = $host_name_entry->get_text()});
    $host_path_entry->signal_connect( 'changed', sub { $host_path = $host_path_entry->get_text()});
    $login_user_entry->signal_connect( 'changed', sub { $login_user = $login_user_entry->get_text()});
    check_list ([$check_remember_pass, \$remember_pass]);
    gtksignal_connect(gtkset_active($check_where_net_ftp, $where_net_ftp), toggled => sub { 
	invbool \$where_net_ftp;
 	${$central_widget}->destroy();
 	$current_widget->();
    });
    if ($previous_function) { fonction_env (\$box_where_net, \&advanced_where_net_ftp, \&$previous_function, "ftp" );}
    else { fonction_env (\$box_where_net, \&advanced_where_net_ftp, \&advanced_where, "ftp" );}
    $up_box->show_all();
}

sub advanced_where_net_ssh {
    my ($previous_function) = @_,
    my $box_where_ssh;
    
    gtkpack($advanced_box,
	    $box_where_ssh =  gtkpack_(new Gtk::VBox(0, 15),
	     1, gtkpack(new Gtk::HBox(0, 15),	
			 new Gtk::VBox(0, 15),
			 gtkpack_(new Gtk::VBox(0, 15),	
				     1, new Gtk::VBox(0, 5),
				     1, gtksignal_connect(new Gtk::Button("rsync"),  clicked => sub {
					 ${$central_widget}->destroy(); message_underdevel(); }),
				     1, gtksignal_connect(new Gtk::Button("WebDav"), clicked => sub { 
					 ${$central_widget}->destroy(); message_underdevel(); }),
				     1, gtksignal_connect(new Gtk::Button("scp"),   clicked => sub { 
					 ${$central_widget}->destroy(); message_underdevel(); }),
				     1, new Gtk::VBox(0, 5),
				     ),
			 new Gtk::VBox(0, 15),
			 ),
				       ),
	    );
# test si x11
#print system("xterm -fn 7x14 -bg black -fg white -e ssh-keygen -f ~/.ssh/identity-backup && scp") . "\n";

    if ($previous_function) { fonction_env (\$box_where_ssh, \&advanced_where_net_ssh, \&$previous_function, "ssh" );}
    else { fonction_env (\$box_where_ssh, \&advanced_where_net_ssh, \&advanced_where, "ssh" );}
    $up_box->show_all();
}

sub advanced_where_net {
    my ($previous_function) = @_,
    my $box_where_net;
    
    gtkpack($advanced_box,
	    $box_where_net = gtkpack_(new Gtk::HBox(0, 15),
				      1, new Gtk::VBox(0, 5),
				      1, gtkpack_(new Gtk::VBox(0, 15),	
						  1, new Gtk::VBox(0, 5),
						  1, new Gtk::VBox(0,10),
						  1, gtksignal_connect(new Gtk::Button(_("FTP Connection")), clicked => sub { 
						      $box_where_net->destroy(); 
						      if ($previous_function ) {
							  advanced_where_net_ftp(\&$previous_function);
						      } else {
							  advanced_where_net_ftp();
						      }}),
						  1, gtksignal_connect(new Gtk::Button(_("Secure Connection")),  clicked => sub {
						      $box_where_net->destroy(); 
						      if ($previous_function ) {
							  advanced_where_net_ssh(\&$previous_function);
						      } else {
							  advanced_where_net_ssh();
						      }}),
						  1, new Gtk::VBox(0, 5),
						  1, new Gtk::VBox(0,10),
						  ),
				      1, new Gtk::VBox(0, 5),	
				      ),
	    );
    if ($previous_function) { fonction_env (\$box_where_net, \&advanced_where_net, \&$previous_function, "remote" );}
    else { fonction_env (\$box_where_net, \&advanced_where_net, \&advanced_where, "remote" );}
    $up_box->show_all();
}

sub advanced_where_cd {
    my ($previous_function) = @_,
    my $box_where_cd;
    my $combo_where_cd_time = new Gtk::Combo();
    $combo_where_cd_time->set_popdown_strings ("650","700", "750", "800");    
 
    gtkpack($advanced_box,
	    $box_where_cd = gtkpack_(new Gtk::VBox(0, 6),
	 0, my $check_where_cd = new Gtk::CheckButton( _("Use CD/DVDROM to backup")),
	 0, new Gtk::HSeparator,
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please choose your CD space")), $where_cd),
		     1, new Gtk::VBox(0, 5),
		     0, gtkset_sensitive(gtkset_usize($combo_where_cd_time, 200, 20), $where_cd),
		     ),
	 0, new Gtk::VBox(0, 5),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please check if you are using CDRW media")), $where_cd),
		     1, new Gtk::VBox(0, 5),
		     0, gtkset_sensitive(my $check_cdrw = new Gtk::CheckButton(), $where_cd),
		     ),
	 0, new Gtk::VBox(0, 5),
	 0, gtkpack_(new Gtk::HBox(0,10),
	    0, gtkset_sensitive(new Gtk::Label(_("Please check if you want to erase your CDRW before")), $cdrw && $where_cd),
	    1, new Gtk::VBox(0, 5),
	    0, gtkset_sensitive(my $check_cdrw_erase = new Gtk::CheckButton(), $cdrw && $where_cd),
		     ),
	 0, new Gtk::VBox(0, 5),
	 0, gtkpack_(new Gtk::HBox(0,10),
	   0, gtkset_sensitive(new Gtk::Label(_("Please check if you want to include\n install boot on your CD.")),  $where_cd),
	   1, new Gtk::VBox(0, 5),
 	   0, gtkset_sensitive(my $check_cd_with_install_boot = new Gtk::CheckButton(), $where_cd),
		     ),
	 0, new Gtk::VBox(0, 5),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please enter your CD Writer device name\n ex: 0,1,0")),  $where_cd),
		     1, new Gtk::VBox(0, 5),
		     0, gtkset_usize(gtkset_sensitive($cd_devive_entry = new Gtk::Entry(), $where_cd), 200, 20),
		     ),
	 ),
	    );

    foreach ([$check_cdrw_erase, \$cdrw_erase], [$check_cd_with_install_boot, \$cd_with_install_boot ]) {
	my $ref = $_->[1];
	gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => sub { ${$ref} = ${$ref} ? 0 : 1; })
	}
    gtksignal_connect(gtkset_active($check_where_cd, $where_cd), toggled => sub { 
	$where_cd = $where_cd ? 0 : 1;
	${$central_widget}->destroy();
	$current_widget->();
    });
    gtksignal_connect(gtkset_active($check_cdrw, $cdrw), toggled => sub { 
	$cdrw = $cdrw ? 0 : 1;
	${$central_widget}->destroy();
	$current_widget->();
    });
    $cd_devive_entry->set_text( $cd_devive );
    $cd_devive_entry->signal_connect( 'changed', sub { $cd_devive = $cd_devive_entry->get_text(); });
    $combo_where_cd_time->entry->set_text($cd_time);
    $combo_where_cd_time->entry->signal_connect( 'changed', sub { $cd_time = $combo_where_cd_time->entry->get_text()});	       

    if ($previous_function) { fonction_env(\$box_where_cd, \&advanced_where_cd, \&$previous_function, ""); }
    else { fonction_env(\$box_where_cd, \&advanced_where_cd, \&advanced_where, ""); }
    $up_box->show_all();
}

sub advanced_where_tape {
    my ($previous_function) = @_,
    my $box_where_tape;
    my $button;
    my $adj = new Gtk::Adjustment 550.0, 1.0, 10000.0, 1.0, 5.0, 0.0;
    my ($pix_fs_map, $pix_fs_mask) = gtkcreate_png("filedialog");
    
    gtkpack($advanced_box,
	    $box_where_tape = gtkpack_(new Gtk::VBox(0, 6),
		 0, new Gtk::HSeparator,
		 0, my $check_where_tape = new Gtk::CheckButton( _("Use tape to backup") ),
		 0, new Gtk::HSeparator,
		 0, gtkpack_(new Gtk::HBox(0,10),
			     0, gtkset_sensitive(new Gtk::Label(_("Please enter the device name to use for backup")), $where_tape ),
			     1, new Gtk::VBox(0, 6),
			     0, gtkset_usize(gtkset_sensitive(my $save_device_tape_entry = new Gtk::Entry(), $where_tape), 200, 20),
				 ),
		 0, new Gtk::VBox(0, 6),
		 0, gtkpack_(new Gtk::HBox(0,10),
		  0, gtkset_sensitive(new Gtk::Label(_("Please enter the maximum size\n allowed for Drakbackup")), $where_tape),
		  1, new Gtk::VBox(0, 6),
		  0, gtkset_usize(gtkset_sensitive(my $spinner = new Gtk::SpinButton( $adj, 0, 0), $where_tape ), 200, 20),
			     ),
		     0, gtkpack_(new Gtk::HBox(0,10),
				 ),
		 ),
	    );
    gtksignal_connect(gtkset_active($check_where_tape, $where_tape), toggled => sub { 
	$where_tape = $where_tape ? 0 : 1;
	${$central_widget}->destroy();
	$current_widget->();
    });
    $save_device_tape_entry->set_text( $save_device_tape );
    $save_device_tape_entry->signal_connect( 'changed', sub { $save_device_tape = $save_device_tape_entry->get_text()});
    if ($previous_function) { fonction_env(\$box_where_tape, \&advanced_where_tape, \&$previous_function, ""); }
    else { fonction_env(\$box_where_tape, \&advanced_where_tape, \&advanced_where, ""); }
    $up_box->show_all();
}

sub advanced_where_hd {
    my ($previous_function) = @_,
    my $box_where_hd;
    my $button;
    my $adj = new Gtk::Adjustment 550.0, 1.0, 10000.0, 1.0, 5.0, 0.0;
    my ($pix_fs_map, $pix_fs_mask) = gtkcreate_png("ic82-dossier-32");
    
    gtkpack($advanced_box,
	    $box_where_hd = gtkpack_(new Gtk::VBox(0, 6),
	 0, new Gtk::HSeparator,
#	 0, my $check_where_hd = new Gtk::CheckButton( _("Use Hard Disk to backup") ),
#	 0, new Gtk::HSeparator,
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please enter the directory to save:")), $where_hd ),
		     1, new Gtk::VBox(0, 6),
		     0, gtkset_usize(gtkset_sensitive($save_path_entry = new Gtk::Entry(), $where_hd), 152, 20),
		     0, gtkset_sensitive($button = gtksignal_connect(new Gtk::Button(),  clicked => sub {
			 filedialog_where_hd();}), $where_hd ),
		     ),
	 0, new Gtk::VBox(0, 6),
	 0, gtkpack_(new Gtk::HBox(0,10),
	   0, gtkset_sensitive(new Gtk::Label(_("Please enter the maximum size\n allowed for Drakbackup")),  $where_hd ),
	   1, new Gtk::VBox(0, 6),
	   0, gtkset_usize(gtkset_sensitive(my $spinner = new Gtk::SpinButton( $adj, 0, 0), $where_hd ), 200, 20),
		     ),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     1, new Gtk::VBox(0, 6),
	   0, gtkset_sensitive(my $check_where_hd_quota = new Gtk::CheckButton( _("Use quota for backup files.")), $where_hd ),
		     0, new Gtk::VBox(0, 6),
		     ),
	 ),
	    );
    foreach ([$check_where_hd_quota, \$hd_quota]) {
	my $ref = $_->[1];
	gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => sub { ${$ref} = ${$ref} ? 0 : 1; })
	}
#    gtksignal_connect(gtkset_active($check_where_hd, $where_hd), toggled => sub { 
#	$where_hd = $where_hd ? 0 : 1;
#	$where_hd = 1;
#	${$central_widget}->destroy();
#	$current_widget->();
#    });
    $button->add(gtkpack(new Gtk::HBox(0,10), new Gtk::Pixmap($pix_fs_map, $pix_fs_mask)));
    $save_path_entry->set_text( $save_path );
    $save_path_entry->signal_connect( 'changed', sub { $save_path = $save_path_entry->get_text()});
    if ($previous_function) { fonction_env(\$box_where_hd, \&advanced_where_hd, \&$previous_function, ""); }
    else { fonction_env(\$box_where_hd, \&advanced_where_hd, \&advanced_where, ""); }
    $up_box->show_all();
}

sub advanced_where{
    my $box_where;
    my ($pix_net_map, $pix_net_mask) = gtkcreate_png("ic82-network-40");
    my ($pix_cd_map, $pix_cd_mask) = gtkcreate_png("ic82-CD-40");
    my ($pix_hd_map, $pix_hd_mask) = gtkcreate_png("ic82-discdurwhat-40");
    my ($pix_tape_map, $pix_tape_mask) = gtkcreate_png("ic82-tape-40");

    gtkpack($advanced_box,
	    $box_where = gtkpack_(new Gtk::HBox(0, 15),
				  1, new Gtk::VBox(0, 5),
				  1, gtkpack_(new Gtk::VBox(0, 15),	
					  1, new Gtk::VBox(0, 5),
					  1, gtksignal_connect(my $button_where_net = new Gtk::Button(), clicked => sub { 
#					      $box_where->destroy(); advanced_where_net(); }),
					      $box_where->destroy(); advanced_where_net_ftp(); }),
					  1, gtksignal_connect(my $button_where_cd = new Gtk::Button(),  clicked => sub { 
					      ${$central_widget}->destroy(); 
					      if (require_rpm("mkisofs", "cdrecord", "toto")) { advanced_where_cd(); }
					      else { 
						  print "have to install @list_of_rpm_to_install...\n";
						  ${$central_widget}->destroy();
						  install_rpm(\&advanced_where);
						  }
					  }),
					  1, gtksignal_connect(my $button_where_hd = new Gtk::Button(),  clicked => sub { 
					      ${$central_widget}->destroy(); advanced_where_hd(); }),
#					  1, gtksignal_connect(my $button_where_tape = new Gtk::Button(),  clicked => sub { 
#					      ${$central_widget}->destroy(); message_underdevel();}), #advanced_where_tape(); }),
					  1, new Gtk::VBox(0, 5),
					     ),
				  1, new Gtk::VBox(0, 5),	
				  ),
	    );
    $button_where_net->add(gtkpack(new Gtk::HBox(0,10),
				   new Gtk::Pixmap($pix_net_map, $pix_net_mask),
				   new Gtk::Label(_("Network")),
				   new Gtk::HBox(0, 5)
				   ));
    $button_where_cd->add(gtkpack(new Gtk::HBox(0,10),
				  new Gtk::Pixmap($pix_cd_map, $pix_cd_mask),
				  new Gtk::Label(_("CDROM / DVDROM")),
				  new Gtk::HBox(0, 5)
				  ));
    $button_where_hd->add(gtkpack(new Gtk::HBox(0,10),
				  new Gtk::Pixmap($pix_hd_map, $pix_hd_mask),
				  new Gtk::Label(_("HardDrive / NFS")),
				  new Gtk::HBox(0, 5)
				  ));
#     $button_where_tape->add(gtkpack(new Gtk::HBox(0,10),
# 				  new Gtk::Pixmap($pix_tape_map, $pix_tape_mask),
# 				  new Gtk::Label(_("Tape")),
# 				  new Gtk::HBox(0, 5)
# 				  ));
    fonction_env(\$box_where, \&advanced_where, \&advanced_box, ""); 
    $up_box->show_all();
}

sub advanced_when{
    my $box_when;
    my $check_where_cd_daemon;
    my $check_where_hd_daemon;
    my $check_where_ssh_daemon;
    my $check_where_ftp_daemon;
    my ($pix_time_map, $pix_time_mask) = gtkcreate_png("ic82-when-40");
    my $combo_when_space = new Gtk::Combo();
    $combo_when_space->set_popdown_strings (_("hourly"),_("daily"),_("weekly"),_("monthly"));    

    gtkpack($advanced_box,
	    $box_when = gtkpack_(new Gtk::VBox(0, 15),
	  0, gtkpack_(new Gtk::HBox(0,10),
		      1, new Gtk::HBox(0,10),
		      1, new Gtk::Pixmap($pix_time_map, $pix_time_mask),
		      0, my $check_when_daemon  = new Gtk::CheckButton( _("Use daemon")  ), 
		      1, new Gtk::HBox(0,10),
		      ),
	  0, new Gtk::HSeparator,
	  0, gtkpack_(new Gtk::HBox(0,10),
		      0, gtkset_sensitive(new Gtk::Label(_("Please choose the time \ninterval between each backup")),  $backup_daemon),
		      1, new Gtk::HBox(0,10),
		      0, gtkset_sensitive($combo_when_space, $backup_daemon),
		      ),
	  0, new Gtk::HBox(0,10),
	  0, gtkpack_(new Gtk::HBox(0,10),
		   0, gtkset_sensitive(new Gtk::Label(_("Please choose the\nmedia for backup.")), $backup_daemon),
		   1, new Gtk::HBox(0,10),
		   0, gtkpack_(new Gtk::VBox(0,10),
#	   0, gtkset_sensitive($check_where_cd_daemon = new Gtk::CheckButton(_("Use CD/DVDROM with daemon")), $backup_daemon),
	   0, gtkset_sensitive($check_where_hd_daemon = new Gtk::CheckButton( _("Use Hard Drive with daemon")), $backup_daemon),
#	   0, gtkset_sensitive($check_where_ssh_daemon = new Gtk::CheckButton( _("Use SSH with daemon")), $backup_daemon),
	   0, gtkset_sensitive($check_where_ftp_daemon = new Gtk::CheckButton( _("Use FTP with daemon")), $backup_daemon),
			       ),
		      ),
	  0, new Gtk::HSeparator,
	  1, gtkset_sensitive(new Gtk::Label(_("Please be sure that the cron daemon is included in your services.")),  $backup_daemon),
	  ),
	    );

    check_list([$check_where_hd_daemon, \$hd_daemon], [$check_where_ftp_daemon, \$ftp_daemon]);
#    check_list([$check_where_hd_daemon, \$hd_daemon], [$check_where_ftp_daemon, \$ftp_daemon], 
#	       [$check_where_cd_daemon, \$cd_daemon],[$check_where_ssh_daemon, \$ssh_daemon] );
    gtksignal_connect(gtkset_active($check_when_daemon, $backup_daemon), toggled => sub { 
	$backup_daemon = $backup_daemon ? 0 : 1;
	${$central_widget}->destroy();
	advanced_when();
    });
    $combo_when_space->entry->set_text( $when_space );
    $combo_when_space->entry->signal_connect( 'changed', sub { 	$when_space = $combo_when_space->entry->get_text(); });
    fonction_env(\$box_when, \&advanced_when, \&advanced_box, "");
    $up_box->show_all();
}

sub advanced_options{
    my $box_options;
    my ($pix_options_map, $pix_options_mask) = gtkcreate_png("ic82-moreoption-40");
    
    gtkpack($advanced_box,
	    $box_options = gtkpack_(new Gtk::VBox(0, 15),
# 				 0, gtkpack_(new Gtk::HBox(0,10),
# 					     1, new Gtk::VBox(0,10),
# 					     1, new Gtk::Pixmap($pix_options_map, $pix_options_mask),
# 					     1, _("Please choose correct options to backup."),
# 					     1, new Gtk::VBox(0,10),
# 					     ),
# 				 0, new Gtk::HSeparator,
# 				 0, gtkpack_(new Gtk::VBox(0,10),
# 					     0, gtkset_sensitive(my $check_tar_bz2  = new Gtk::CheckButton( _("Use Tar and bzip2 (very slow) [Please be careful if you\n (un)select this option, as all your old backups will be deleted.]") ), 0),
# 			 0, gtkset_sensitive(my $check_backupignore = new Gtk::CheckButton( _("Use .backupignore files")), 0),
				    0, new Gtk::VBox(0,10),
				    0, gtkpack_(new Gtk::HBox(0,10),
						0, my $check_mail = new Gtk::CheckButton( _("Send mail report after each backup to :")),
						1, new Gtk::HBox(0,10),
						0, my $mail_entry = new Gtk::Entry(),
						),
#					     ),
				    ),
	    );
    check_list([$check_mail, \$send_mail]);
#    check_list([$check_mail, \$send_mail], [$check_tar_bz2, \$comp_mode], [$check_backupignore, \$backupignore]);
    $mail_entry->set_text( $user_mail );
    $mail_entry->signal_connect( 'changed', sub { $user_mail = $mail_entry->get_text()});
    fonction_env(\$box_options, \&advanced_options, \&advanced_box, "options");
    $up_box->show_all();
}

sub advanced_box{
    my $box_adv;
    my ($pix_hd_map, $pix_hd_mask) = gtkcreate_png("ic82-discdurwhat-40");
    my ($pix_time_map, $pix_time_mask) = gtkcreate_png("ic82-when-40");
    my ($pix_net_map, $pix_net_mask) = gtkcreate_png("ic82-where-40");
    my ($pix_options_map, $pix_options_mask) = gtkcreate_png("ic82-moreoption-40");

    gtkpack($advanced_box,
	    $box_adv = gtkpack_(new Gtk::HBox(0, 15),
				    1, new Gtk::VBox(0, 5),	
				    1, gtkpack_(new Gtk::VBox(0, 15),	
						1, new Gtk::VBox(0, 5),	
						1, gtksignal_connect(my $button_what = new Gtk::Button(), clicked => sub { 
						    ${$central_widget}->destroy(); advanced_what(); }),
						1, gtksignal_connect(my $button_where = new Gtk::Button(), clicked => sub { 
						    ${$central_widget}->destroy();  advanced_where(); }),
						1, gtksignal_connect(my $button_when = new Gtk::Button(), clicked => sub { 
						    ${$central_widget}->destroy();  advanced_when(); }),
						1, gtksignal_connect(my $button_options = new Gtk::Button(), clicked => sub {
						    ${$central_widget}->destroy(); advanced_options();}),
						1, new Gtk::VBox(0, 5),	
						),
				    1, new Gtk::VBox(0, 5),	
				    ),
	    );
    $button_what->add(gtkpack(new Gtk::HBox(0,10),
			      new Gtk::Pixmap($pix_hd_map, $pix_hd_mask),
			      new Gtk::Label(_("What")),
			      new Gtk::HBox(0, 5)
			      ));
    $button_where->add(gtkpack(new Gtk::HBox(0,10),
			      new Gtk::Pixmap($pix_net_map, $pix_net_mask),
			      new Gtk::Label(_("Where")),
			      new Gtk::HBox(0, 5)
			      ));
    $button_when->add(gtkpack(new Gtk::HBox(0,10),
			      new Gtk::Pixmap($pix_time_map, $pix_time_mask),
			      new Gtk::Label(_("When")),
			      new Gtk::HBox(0, 5)
			      ));
    $button_options->add(gtkpack(new Gtk::HBox(0,10),
			      new Gtk::Pixmap($pix_options_map, $pix_options_mask),
			      new Gtk::Label(_("More Options")),
			      new Gtk::HBox(0, 5)
			      ));
    fonction_env(\$box_adv, \&advanced_box, \&interactive_mode_box, "");
    $up_box->show_all();
}

################################################  WIZARD  ################################################  

sub wizard_step3 {
    my $box2;    
    my $text = new Gtk::Text(undef, undef);
    system_state();
    gtktext_insert($text, $system_state);
    button_box_restore_main();

    gtkpack($advanced_box,
	    $box2 =  gtkpack_(new Gtk::HBox(0, 15),	
			      1, gtkpack_(new Gtk::VBox(0,10),
					  0, _("Drakbackup Configuration"),
					  1, createScrolledWindow($text),
					  ),
			      ),
	    );
    button_box_wizard_end();
    fonction_env(\$box2, \&wizard_step3, \&wizard_step2, "");
    $up_box->show_all();
}

sub wizard_step2 {
    my $box2;    
    
    gtkpack($advanced_box,
	    $box2 =  gtkpack_(new Gtk::HBox(0, 15),	
			      1, new Gtk::VBox(0, 5),	
			      1, gtkpack_(new Gtk::VBox(0, 15),	
					  1, new Gtk::VBox(0, 5),
					  0, _("Please choose where you want to backup"),
					  0, gtkpack_(new Gtk::HBox(0, 15),	      
						      0, my $check_wizard_hd = new Gtk::CheckButton(_("on Hard Drive")),
						      1, new Gtk::VBox(0, 5),
						      0, gtkset_sensitive(gtksignal_connect(new Gtk::Button(_("Configure")),
											    clicked => sub {
												${$central_widget}->destroy();
												advanced_where_hd(\&wizard_step2);
											    }), $where_hd ),
									  ),
					  0, gtkpack_(new Gtk::HBox(0, 15),	      
						      0, my $check_wizard_net = new Gtk::CheckButton(_("across Network")),
						      1, new Gtk::VBox(0, 5),
						      0, gtkset_sensitive(gtksignal_connect(new Gtk::Button(_("Configure")),
											    clicked => sub {
												${$central_widget}->destroy();
												advanced_where_net(\&wizard_step2);
											    }), $where_net ),
						      ),
# 					  0, gtkpack_(new Gtk::HBox(0, 15),	      
# 						      0, my $check_wizard_cd = new Gtk::CheckButton(_("on CDROM")),
# 						      1, new Gtk::VBox(0, 5),	
# 						      0, gtkset_sensitive(gtksignal_connect(new Gtk::Button(_("Configure")),
# 											    clicked => sub {
# 												${$central_widget}->destroy();
# 												advanced_where_cd(\&wizard_step2);
# 											    }), $where_cd ),
# 						      ),
# 					  0, gtkpack_(new Gtk::HBox(0, 15),	      
# 						      0, my $check_wizard_tape = new Gtk::CheckButton(_("on Tape Device")),
# 						      1, new Gtk::VBox(0, 5),
# 						      0, gtkset_sensitive(gtksignal_connect(new Gtk::Button(_("Configure")), 
# 											    clicked => sub {
# 												${$central_widget}->destroy();
# 												advanced_where_tape(\&wizard_step2);
# 											    }), $where_tape),
# 						      ),
					  1, new Gtk::VBox(0, 5),
					  ),
			      1, new Gtk::VBox(0, 5),	
			      ),
	    );
    $where_net = $where_net_ssh || $where_net_ftp;
    button_box_wizard();
    foreach ([$check_wizard_hd, \$where_hd], 
#	     [$check_wizard_cd, \$where_cd], 
#	     [$check_wizard_tape, \$where_tape],
	     [$check_wizard_net, \$where_net]) {
	my $ref = $_->[1];
	gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => 
			  sub { ${$ref} = ${$ref} ? 0 : 1;
				$where_hd = 1;
				if (!$where_hd && !$where_cd && !$where_net) {  $next_widget = \&message_noselect_box; }
				else { $next_widget = \&wizard_step3;   }
				if(!$where_net) {$where_net_ssh = 0; $where_net_ftp = 0; }
				else {$where_net_ftp = 1;}
				${$central_widget}->destroy();
				wizard_step2();
			    })
	}
    if (!$where_hd && !$where_cd && !$where_net) { fonction_env(\$box2, \&wizard_step2, \&wizard, "", \&message_noselect_box)}
    else { fonction_env(\$box2, \&wizard_step2, \&wizard, "", \&wizard_step3)}
    $up_box->show_all();
}

sub wizard   {
    my $box2;    
    
    gtkpack($advanced_box,
	    $box2 =  gtkpack_(new Gtk::HBox(0, 15),	
			      1, new Gtk::VBox(0, 5),	
			      1, gtkpack_(new Gtk::VBox(0, 15),	
					  1, new Gtk::VBox(0, 5),
					  0, _("Please choose what you want to backup"),
					  0, my $check_wizard_sys = new Gtk::CheckButton(_("Backup system")),
					  0, my $check_wizard_user = new Gtk::CheckButton(_("Backup Users")),
					  0, gtkpack_(new Gtk::HBox(0, 15),
					       1, new Gtk::VBox(0, 5),	
					       0, gtksignal_connect(new Gtk::Button(_("Select user manually")), clicked => sub {
						   ${$central_widget}->destroy();
						   advanced_what_user(\&wizard);
					       }),
						      ),
					  1, new Gtk::VBox(0, 5),	
					  ),
			      1, new Gtk::VBox(0, 5),	
			      ),
	    );
    foreach ([$check_wizard_sys, \$backup_sys], [$check_wizard_user, \$backup_user]) {
	my $ref = $_->[1];
	gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => 
			  sub { ${$ref} = ${$ref} ? 0 : 1;
				if ($backup_sys || $backup_user && @user_list ) { $next_widget = \&wizard_step2; } 
				else { $next_widget = \&message_noselect_what_box; }
			    })}
    if ($backup_sys || $backup_user && @user_list ) { fonction_env(\$box2, \&wizard, \&interactive_mode_box, "", \&wizard_step2) } 
    else { fonction_env(\$box2, \&wizard, \&interactive_mode_box, "", \&message_noselect_what_box) } 
    button_box_wizard();
    $up_box->show_all();
}

################################################  RESTORE  ################################################  

sub find_backup_to_restore {
	# fixme: 
	# faire test existance cd
	# faire reponse si non existance de  $path_to_find_restore
    my @list_backup = ();
    my @list_backup_tmp2 = ();
    my $to_put;
    @sys_backuped = ();
    my @list_backup_tmp;
    my @user_backuped_tmp;

    @user_backuped = ();
    -d $path_to_find_restore and my @list_backup_tmp2 = all($path_to_find_restore);
    foreach (@list_backup_tmp2) {
	s/\_base//gi;
	s/\_incr//gi;
	push @list_backup , $_;
    }
    if (grep /^backup_other/, @list_backup) {$other_backuped = 1;}
    if (grep /^backup_sys/, @list_backup) {$sys_backuped = 1;}
    foreach (grep /^backup_sys_/, @list_backup) {
	chomp;
	s/^backup_sys_//gi;
	s/.tar.gz$//gi;
	s/.tar.bz2$//gi;
 	my ( $date, $heure) = /^(.*)_([^_]*)$/; 
	my $year = substr($date, 0, 4);
	my $month = substr($date, 4,  2);
	my $day =  substr($date, 6, 2);
	my $hour = substr($heure, 0,  2);
	my $min =  substr($heure, 2, 2);
	$to_put = "$day/$month/$year $hour:$min                   $_";
 	push @sys_backuped , $to_put;
    }
    $restore_step_sys_date  = $to_put;
    foreach (grep /^backup_user_/, @list_backup) {
	chomp;
	s/^backup_user_//gi;
	s/.tar.gz$//gi;
	s/.tar.bz2$//gi;
	my ($nom, $date, $heure) = /^(.*)_([^_]*)_([^_]*)$/;
	my $year = substr($date, 0, 4);
	my $month = substr($date, 4,  2);
	my $day =  substr($date, 6, 2);
	my $hour = substr($heure, 0,  2);
	my $min =  substr($heure, 2, 2);
#	my $to_put = "  $nom,  (date: $date, hour: $heure)";
	$to_put = "$_       user: $nom,   date: $day/$month/$year,   hour: $hour:$min";
	push @user_backuped , $to_put;
	grep ( /^$nom$/, @user_list_backuped) or push @user_list_backuped, $nom;
    }
}

sub system_state {
    $system_state = ();

    if ($cfg_file_exist) { 
	$system_state .= _("\nBackup Sources: \n");
        $backup_sys and $system_state .= _("\n- System Files:\n"); 
        $backup_sys and $system_state .= "\t\t$_\n" foreach @sys_files; 
        $backup_user and $system_state .= _("\n- User Files:\n");
        $backup_user and $system_state .= "\t\t$_\n" foreach @user_list;
        @list_other and $system_state .= _("\n- Other Files:\n"); 
        @list_other and $system_state .= "\t\t$_\n" foreach @list_other;
        $where_hd and $system_state .= _("\n- Save on Hard drive on path : %s\n", $save_path);
	$where_net_ftp and $system_state .= _("\n- Save on FTP on host : %s\n", $host_name);
	$where_net_ftp and $system_state .= _("\t\t user name: %s\n\t\t on path: %s \n", $login_user, $host_path);
	$system_state .= _("\n- Options:\n");
	$backup_sys or $system_state .= _("\tDo not include System Files\n");
	if ($comp_mode) { $system_state .= _("\tBackups use tar and bzip2\n"); }
	else { $system_state .= _("\tBackups use tar and gzip\n"); }   
	$system_state .= _("\n- Daemon (%s) include :\n", $when_space);
	$hd_daemon and $system_state .= _("\t-Hard drive.\n");    
	$cd_daemon and $system_state .= _("\t-CDROM.\n");    
	$ftp_daemon and $system_state .= _("\t-Network by FTP.\n");    
	$ssh_daemon and $system_state .= _("\t-Network by SSH.\n");    
    }
    else {$system_state = _("No configuration, please click Wizard or Advanced.\n")}
}

sub restore_state {
    my @tmp = split( ' ', $restore_step_sys_date);
    $restore_state = _("List of data to restore:\n\n");
    if ($restore_sys) { $restore_state .= "- Restore System Files.\n";
			$restore_state .= "   - from date: $tmp[0] $tmp[1]\n";
			}
    if ($restore_user) { 
	$restore_state .= "- Restore User Files: \n" ;
	$restore_state .= "\t\t$_\n" foreach @user_list_to_restore2 ;
	push @user_list_to_restore, (split(',', $_))[0] foreach @user_list_to_restore2 ;
    }
    if ($restore_other) { 
	$restore_state .= "- Restore Other Files: \n";
	-f "$path_to_find_restore/list_other" and $restore_state .= "\t\t$_\n" foreach split( "\n", cat_("$path_to_find_restore/list_other"));  
    }
    if ($restore_other_path) {
	$restore_state .= "- Path to Restore: $restore_path \n";
    }
}

sub select_most_recent_selected_of {
    my ($user_name) = @_;
    my @list_tmp2;
    my @tmp = sort @user_list_to_restore2;
    foreach (grep /$user_name\_/, sort @tmp) { push @list_tmp2 , $_; }
    return pop @list_tmp2;
}

sub select_user_data_to_restore {
    my $var_eq = 1;
    my @list_backup = ();
    my @list_tmp = ();
    my @list_tmp2 = ();
    @user_list_to_restore = ();

    -d $path_to_find_restore and my @list_backup_tmp2 = grep /^backup/, all($path_to_find_restore);
    @list_tmp2 = @list_backup_tmp2;
    foreach (@list_backup_tmp2) {
	s/\_base//gi;
	s/\_incr//gi;
	push @list_backup , $_;
    }
    foreach my $var_tmp (@user_list_backuped) {
	$var_eq = 1;
	my $more_recent = (split( ' ', select_most_recent_selected_of($var_tmp)))[0]; 
	foreach (grep /^backup\_user\_$var_tmp\_/, sort @list_backup) {
	    s/.tar.gz//gi;
	    s/.tar.bz2//gi;	    
	    if ($more_recent) {
		if ( $_ =~ /$more_recent/ ) {
		    push @list_tmp , $_;
		    $var_eq = 0;    
		}
		else { $var_eq and push @list_tmp , $_;}
	    }
	}
    }
     foreach my $var_to_restore (@list_tmp) {
	$var_to_restore =~ s/backup_//gi;
	foreach my $var_exist ( sort @list_tmp2) {
	    if ($var_exist =~ /$var_to_restore/ ) {
		push @user_list_to_restore, $var_exist;
	    }
	}
    }
    $DEBUG and print "(incremental restore) real user list to restore :  $_ \n" foreach (@user_list_to_restore);
}

sub select_sys_data_to_restore {
    my $var_eq = 1;
    my @list_tmp = ();
    @sys_list_to_restore = ();

    -d $path_to_find_restore and my @list_tmp = grep /^backup/, all($path_to_find_restore);
    my @more_recent = split( ' ', $restore_step_sys_date); 
    my $more_recent = pop @more_recent;
    foreach my $var_exist (grep /\_sys\_/, sort @list_tmp) {
	if ($var_exist =~ /$more_recent/ ) {
	    push @sys_list_to_restore, $var_exist;
	    $var_eq = 0; }
	 else {  $var_eq and push @sys_list_to_restore, $var_exist; }
    }
    $DEBUG and print "sys list to restore: $_\n " foreach (@sys_list_to_restore);
}

sub valid_backup_test {
    my (@files_list) = @_;
    @files_corrupted = ();
    my $is_corrupted = 0;
    foreach (@files_list) {
	if (system("gzip -l $path_to_find_restore/$_") > 1 ) {
	    push @files_corrupted, $_;
	    $is_corrupted = -1;
	}
    }
    return $is_corrupted;
}

sub restore_aff_backup_problems {
    my $do_restore;
    my $button_restore;
    my $text = new Gtk::Text(undef, undef);
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');
    my $restore_pbs_state = _("List of data corrupted:\n\n");
    $restore_pbs_state .= "\t\t$_\n" foreach @files_corrupted ;
    $restore_pbs_state .= _("Please uncheck or remove it on next time.");
    gtktext_insert($text, $restore_pbs_state);
    button_box_restore_main();    

    gtkpack($advanced_box,
	    $do_restore = gtkpack_(new Gtk::VBox(0,10),
				   0, new Gtk::VBox(0,10),
				   1, gtkpack_(new Gtk::HBox(0, 15),	
					      1, new Gtk::VBox(0, 5),	
					      0, new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
					      0, _("Backup files are corrupted"),
					      1, new Gtk::VBox(0, 5),	
					  ),
				   0, new Gtk::VBox(0,10),
				   1, createScrolledWindow($text),
				   ),
	    );
    button_box_restore_pbs_end();
    fonction_env(\$do_restore, \&restore_aff_backup_problems, "", "restore_pbs");
    $up_box->show_all();
}

sub restore_aff_result {
    my $do_restore;
    my $text = new Gtk::Text(undef, undef);
    gtktext_insert($text, $restore_state);
    button_box_restore_main();
    
    gtkpack($advanced_box,
	    $do_restore = gtkpack_(new Gtk::VBox(0,10),
				   1, new Gtk::VBox(0,10),
				   0, _("          All your selectionned data have been          "),
				   0, _("          Successfuly Restored on %s       ", $restore_path),
				   1, new Gtk::VBox(0,10),
				   ),
	    );
    button_box_build_backup_end();
    $central_widget = \$do_restore;
    $up_box->show_all();

}

sub return_path {
    my ($username) = @_;
    my $usr;
    my $home_dir;
    my $passwdfile = "/etc/passwd";
    open (PASSWD, $passwdfile) or exit 1; 
    while (defined(my $line = <PASSWD>)) {
	chomp($line);
	($usr,$home_dir) = (split(/:/, $line))[0,5];
	last if ($usr eq $username); 
    }
    close (PASSWD);
    return $home_dir;
}

sub restore_backend {
    my $untar_cmd;
    my $exist_problem = 0;
    my $user_dir;
    if (grep /tar.gz$/, all($path_to_find_restore)) { $untar_cmd = 0; } 
    else { $untar_cmd = 1; }
    if ($restore_user)  { 
	if ($backup_user_versions) {
	    select_user_data_to_restore();
	    if (valid_backup_test(@user_list_to_restore) == -1) {
		$exist_problem = 1;
		restore_aff_backup_problems();
	    } else {
		foreach (@user_list_to_restore) {
		    my ($tnom, $username, $theure2) = /^(\w+\_\w+\_user_)(.*)_(\d+\_\d+.*)$/;
		    $DEBUG and print "user name to restore: $username, user directory: $user_dir\n";		    
		    if ($remove_user_before_restore) {
			$user_dir = return_path($username);
			-d $user_dir and rm_rf($user_dir);
		    }
		    $untar_cmd or system(" tar xfz  $path_to_find_restore/$_ -C $restore_path") ;
		    $untar_cmd and system("/usr/bin/bzip2 -cd $path_to_find_restore/$_ | tar xf -C $restore_path ") ;
		}
	    }
	}
    }
    if ($restore_sys)   { 
	if ($backup_sys_versions) {
	    select_sys_data_to_restore();
	    if (valid_backup_test(@sys_list_to_restore) == -1) {
		$exist_problem = 1;
		restore_aff_backup_problems();
	    } else {
 $untar_cmd or system("tar xfz $path_to_find_restore/$_  -C $restore_path ") foreach @sys_list_to_restore;
 $untar_cmd and system("/usr/bin/bzip2 -cd $path_to_find_restore/$_  | tar xf -C $restore_path ") foreach @sys_list_to_restore;
		}
	} else {
 $untar_cmd or system("tar xfz $path_to_find_restore/backup_sys.tar.gz  -C $restore_path ");
 $untar_cmd and system("/usr/bin/bzip2 -cd $path_to_find_restore/backup_sys.tar.bz2  | tar xf -C $restore_path ");
	}	    
    }
    if ($restore_other) { 
 $untar_cmd or system("tar xfz $path_to_find_restore/backup_other.tar.gz  -C $restore_path ");
 $untar_cmd and system("/usr/bin/bzip2 -cd $path_to_find_restore/backup_other.tar.bz2  | tar xf -C $restore_path ");
    }
    $exist_problem or restore_aff_result();
}

sub restore_do {
    if ($backup_bef_restore) {
	if ($restore_sys) { $backup_sys = 1;}
	else { $backup_sys = 0;}
	if ($restore_user) { 
	    $backup_user = 1;
	    @user_list = @user_list_to_restore;
	} else { $backup_user = 0;}
	build_backup_status();
	read_conf_file();
	build_backup_files();
	$table->destroy();
    }
    restore_do2();
}

sub restore_do2 {
    my $do_restore;
    my $button_restore;
    my $text = new Gtk::Text(undef, undef);
    restore_state();
    gtktext_insert($text, $restore_state);
    button_box_restore_main();
    
    gtkpack($advanced_box,
	    $do_restore = gtkpack_(new Gtk::VBox(0,10),
				   0, _("         Restore Configuration       "),
				   1, createScrolledWindow($text),
				   ),
	    );
    button_box_restore_end();
    fonction_env(\$do_restore, \&restore_do2, \&restore_box, "restore");
    $up_box->show_all();
}

sub restore_step_other {
    my $retore_step_other;
    my $text = new Gtk::Text(undef, undef);
    my $other_rest = cat_("$path_to_find_restore/list_other");
    gtktext_insert($text, $other_rest); 
    gtkpack($advanced_box,
	    $retore_step_other = gtkpack_(new Gtk::VBox(0,10),
					  1, new Gtk::VBox(0,10),
					  1, createScrolledWindow($text),
			      0, my $check_restore_other_sure = new Gtk::CheckButton(_("OK to restore the other files.")),
					  1, new Gtk::VBox(0,10),
					  ),
	    );
    check_list([$check_restore_other_sure, \$restore_other]);
    fonction_env(\$retore_step_other, \&restore_step_other, \&restore_step2, "restore", \&restore_do);
    $up_box->show_all();
}

my %check_user_to_restore;
sub restore_step_user {
    my $retore_step_user;
    my @tmp_list = sort @user_backuped;
    @user_backuped   = @tmp_list;

    gtkpack($advanced_box,
	    $retore_step_user = gtkpack_(new Gtk::VBox(0,10),
		     0, new Gtk::VBox(0,10),
		     0, _("User list to restore (only the most recent date per user is important)"),
		     1, createScrolledWindow( gtkpack__(new Gtk::VBox(0,0),
							map { my $name;
							      my $var2;
							      my $name_complet = $_;
							      $name = (split( ' ',$name_complet))[0];
							      my @user_list_tmp = ();
							      
							      my $b = new Gtk::CheckButton($name_complet); 
							      if ( grep $name_complet, @user_list_to_restore2)  {
								  gtkset_active($b, 1);
								  $check_user_to_restore{$name_complet}[1] = 1;
							      } else {
								  gtkset_active($b, 0);
								  $check_user_to_restore{$name_complet}[1] = 0;
							      }
							      $b->signal_connect(toggled => sub { 
								  if (!$check_user_to_restore{$name_complet}[1] ) {
								      $check_user_to_restore{$name_complet}[1] = 1;
								      if (!grep (/$name/, @user_list_to_restore2)) {
									  push @user_list_to_restore2, $name_complet;}
								  } else {
								      $check_user_to_restore{$name_complet}[1] = 0;
								      foreach (@user_list_to_restore2) {
									  $var2 =  (split( ' ',$_))[0];
									  if ($name ne $var2) {
									      push @user_list_tmp, $_;
									  }
								      }
								      @user_list_to_restore2 = @user_list_tmp;
								  }
							      });
							      $b } (@user_backuped) 
							),
					      ),
					 ),
	    );
    if ($restore_other) { fonction_env(\$retore_step_user, \&restore_step_user, "", "restore", \&restore_step_other)}
    else{ fonction_env(\$retore_step_user, \&restore_step_user, "", "restore", \&restore_do)}
    $up_box->show_all();
}

sub restore_step_sys {
    my $restore_step_sys;
    my $combo_restore_step_sys = new Gtk::Combo();
    $combo_restore_step_sys->set_popdown_strings (@sys_backuped);

    gtkpack($advanced_box,
	    $restore_step_sys = gtkpack_(new Gtk::VBox(0,10),
					1, new Gtk::VBox(0,10),
					0, my $check_backup_before = new Gtk::CheckButton(_("Backup the system files before:")),
					0, gtkpack_(new Gtk::HBox(0,10),
						    1, _("please choose the date to restore"),
						    0, $combo_restore_step_sys,
						    0, new Gtk::HBox(0,10),
						    ),
					1, new Gtk::VBox(0,10),
					),
	    );
    $combo_restore_step_sys->entry->signal_connect( 'changed', sub {
	$restore_step_sys_date = $combo_restore_step_sys->entry->get_text();
	});
    $combo_restore_step_sys->entry->set_text($restore_step_sys_date);
    fonction_env(\$restore_step_sys, \&restore_step_sys, "", "restore",  );
    if ($restore_user) { fonction_env(\$restore_step_sys, \&restore_step_sys, "", "restore", \&restore_step_user)}
    elsif ($restore_other){ fonction_env(\$restore_step_sys, \&restore_step_sys, "", "restore", \&restore_step_other)}
    else{ fonction_env(\$restore_step_sys, \&restore_step_sys, "", "restore", \&restore_do)}
    $up_box->show_all();
}

sub restore_other_media_hd {
    my ($previous_function) = @_,
    my $box_where_hd;
    my $button;
    my $adj = new Gtk::Adjustment 550.0, 1.0, 10000.0, 1.0, 5.0, 0.0;
    my ($pix_fs_map, $pix_fs_mask) = gtkcreate_png("ic82-dossier-32");
    
    gtkpack($advanced_box,
	    $box_where_hd = gtkpack_(new Gtk::VBox(0, 6),
	 0, new Gtk::HSeparator,
	 0, my $check_where_hd = new Gtk::CheckButton( _("Use Hard Disk to backup") ),
	 0, new Gtk::HSeparator,
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please enter the directory to save:")), $where_hd ),
		     1, new Gtk::VBox(0, 6),
		     0, gtkset_usize(gtkset_sensitive($save_path_entry = new Gtk::Entry(), $where_hd), 152, 20),
		     0, gtkset_sensitive($button = gtksignal_connect(new Gtk::Button(),  clicked => sub {
			 filedialog_where_hd();}), $where_hd ),
		     ),
	 0, new Gtk::VBox(0, 6),
	 0, gtkpack_(new Gtk::HBox(0,10),
	    0, gtkset_sensitive(new Gtk::Label(_("Please enter the maximum size\n allowed for Drakbackup")),  $where_hd ),
	    1, new Gtk::VBox(0, 6),
	    0, gtkset_usize(gtkset_sensitive(my $spinner = new Gtk::SpinButton( $adj, 0, 0), $where_hd ), 200, 20),
		     ),
	 0, gtkpack_(new Gtk::HBox(0,10),
	    1, new Gtk::VBox(0, 6),
	    0, gtkset_sensitive(my $check_where_hd_quota = new Gtk::CheckButton( _("Use quota for backup files.")), $where_hd ),
	    0, new Gtk::VBox(0, 6),
		     ),
	 ),
	    );
    check_list([$check_where_hd_quota, \$hd_quota]);
    gtksignal_connect(gtkset_active($check_where_hd, $where_hd), toggled => sub { 
	$where_hd = $where_hd ? 0 : 1;
	${$central_widget}->destroy();
	$current_widget->();
    });
    $button->add(gtkpack(new Gtk::HBox(0,10), new Gtk::Pixmap($pix_fs_map, $pix_fs_mask)));
    $save_path_entry->set_text( $save_path );
    $save_path_entry->signal_connect( 'changed', sub { $save_path = $save_path_entry->get_text()});
    if ($previous_function) { fonction_env( \$box_where_hd, \&advanced_where_hd, \&$previous_function, "")}
    else { fonction_env( \$box_where_hd, \&advanced_where_hd, \&advanced_where, "")}
    $up_box->show_all();
}

sub restore_find_net {
    my ($previous_function) = @_,
    my $box_where_net;
    
    gtkpack($advanced_box,
	    $box_where_net = gtkpack_(new Gtk::HBox(0, 15),
				      1, new Gtk::VBox(0, 5),
				      1, gtkpack_(new Gtk::VBox(0, 15),	
						  1, new Gtk::VBox(0, 5),
						  1, new Gtk::VBox(0,10),
						  1, gtksignal_connect(new Gtk::Button(_("FTP Connection")), clicked => sub { 
						      $box_where_net->destroy(); 
						      if ($previous_function ) {
							  message_underdevel();
#							  advanced_where_net_ftp(\&$previous_function);
						      } else {
							  advanced_where_net_ftp();
						      }}),
						  1, gtksignal_connect(new Gtk::Button(_("Secure Connection")),  clicked => sub {
						      $box_where_net->destroy(); 
						      if ($previous_function ) {
							  advanced_where_net_ssh(\&$previous_function);
						      } else {
							  advanced_where_net_ssh();
						      }}),
						  1, new Gtk::VBox(0, 5),
						  1, new Gtk::VBox(0,10),
						  ),
				      1, new Gtk::VBox(0, 5),	
				      ),
	    );
    if ($previous_function) { fonction_env( \$box_where_net, \&advanced_where_net, \&$previous_function, "")}
    else { fonction_env( \$box_where_net, \&advanced_where_net, \&advanced_where, "")}
    $up_box->show_all();
}

sub restore_other_media {
    my $box_find_restore;
    my $button;
    my $adj = new Gtk::Adjustment 550.0, 1.0, 10000.0, 1.0, 5.0, 0.0;
    my ($pix_fs_map, $pix_fs_mask) = gtkcreate_png("ic82-dossier-32");
    
    gtkpack($advanced_box,
	    $box_find_restore = gtkpack_(new Gtk::VBox(0, 6),
	 0, new Gtk::HSeparator,
	 0, my $check_other_media_hd = new Gtk::CheckButton( _("Restore from Hard Disk.") ),
				 0, gtkpack_(new Gtk::HBox(0,10),
				 0, gtkset_sensitive(new Gtk::Label(_("Please enter the directory where backups are stored")), $other_media_hd ),
				 1, new Gtk::VBox(0, 6),
				 0, gtkset_usize(gtkset_sensitive($restore_find_path_entry = new Gtk::Entry(), $other_media_hd), 152, 20),
				 0, gtkset_sensitive($button = gtksignal_connect(new Gtk::Button(),  clicked => sub {
				     filedialog_restore_find_path();}), $other_media_hd ),
					     ),
					 1, new Gtk::VBox(0, 6),
#					 0, new Gtk::HSeparator,
# 					 0, my $check_other_media_net = new Gtk::CheckButton( _("Restore from Network") ),
# 					 0, new Gtk::VBox(0, 6),
# 					 1, gtkpack(new Gtk::HBox(0,10),
# 						    new Gtk::VBox(0, 6),
# 						    gtkset_sensitive(gtksignal_connect(new Gtk::Button("Network"),  clicked => sub {
# 							${$central_widget}->destroy();
# 							restore_find_net(\&restore_other_media);}), !$other_media_hd ),
# 						    new Gtk::VBox(0, 6),
# 						    ),
# 					 1, new Gtk::VBox(0, 6),
# 					 0, new Gtk::HSeparator,
					 0, new Gtk::VBox(0, 6),
					 ),
	    );
    gtksignal_connect(gtkset_active($check_other_media_hd, $other_media_hd), toggled => sub { 
	$other_media_hd = $other_media_hd ? 0 : 1;
	${$central_widget}->destroy();
	$current_widget->();
    });
#     gtksignal_connect(gtkset_active($check_other_media_net, !$other_media_hd), toggled => sub { 
# 	$other_media_hd = $other_media_hd ? 0 : 1;
# 	${$central_widget}->destroy();
# 	$current_widget->();
#    });
    $button->add(gtkpack(new Gtk::HBox(0,10), new Gtk::Pixmap($pix_fs_map, $pix_fs_mask)));
    $restore_find_path_entry->set_text( $path_to_find_restore );
    $restore_find_path_entry->signal_connect( 'changed', sub { $path_to_find_restore = $restore_find_path_entry->get_text()});
    fonction_env(\$box_find_restore, \&restore_other_media, \&restore_step2, "other_media");
    $up_box->show_all();
}

sub restore_step2 {
    my $retore_step2;
    my $other_exist;
    my $sys_exist;
    my $user_exist;

    if (-f "$save_path/backup_other*") { $other_exist = 1; } 
    else { my $other_exist = 0; $restore_other = 0; }
    if (grep /\_sys\_/, grep /^backup/, all("$save_path/")) { $sys_exist = 1; } 
    else { my $sys_exist = 0; $restore_sys = 0; }
    if (grep /\_user\_/, grep /^backup/, all("$save_path/")) { $user_exist = 1; } 
    else { my $user_exist = 0; $restore_user = 0; }
    $backup_sys_versions || $backup_user_versions and $backup_bef_restore = 1;

    gtkpack($advanced_box,
	    $retore_step2 = gtkpack_(new Gtk::VBox(0,10),
	 1, new Gtk::VBox(0,10),
	 1, new Gtk::VBox(0,10),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, my $check_restore_other_src = new Gtk::CheckButton(_("Select another media to restore from")),
		     1, new Gtk::HBox(0,10),
		     0, gtkset_sensitive(gtksignal_connect(new Gtk::Button(_("Other Media")),
							   clicked => sub {
							       ${$central_widget}->destroy();
							       restore_other_media();
							   }), $restore_other_src ),
		     ),
	 0, gtkset_sensitive(my $check_restore_sys = new Gtk::CheckButton(_("Restore system")), $sys_exist),
	 0, gtkset_sensitive(my $check_restore_user = new Gtk::CheckButton(_("Restore Users")), $user_exist),
	 0, gtkset_sensitive( my $check_restore_other = new Gtk::CheckButton(_("Restore Other")), $other_exist),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, my $check_restore_other_path = new Gtk::CheckButton(_("select path to restore (instead of / )")),
		     1, new Gtk::HBox(0,10),
		     0, gtkset_sensitive(my $restore_path_entry = new Gtk::Entry(), $restore_other_path),
		     ),
         0, gtkset_sensitive(my $check_backup_bef_restore = new Gtk::CheckButton(_("Do new backup before restore (only for incremental backups.)")), $backup_sys_versions || $backup_user_versions  ),
	 0, gtkset_sensitive(my $check_remove_user_dir = new Gtk::CheckButton(_("Remove user directories before restore.")), $sys_exist),
	 1, new Gtk::VBox(0,10),
	 ),
	    );
    foreach  ([$check_restore_sys, \$restore_sys], 
	      [$check_backup_bef_restore, \$backup_bef_restore],
	      [$check_restore_user, \$restore_user],
	      [$check_remove_user_dir, \$remove_user_before_restore ],
	      [$check_restore_other, \$restore_other]) {
	my $ref = $_->[1];
	gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => sub { 
	    ${$ref} = ${$ref} ? 0 : 1;
	    if (!$restore_sys && !$restore_user && !$restore_other) { $next_widget = \&message_norestore_box; }
	    elsif ($restore_sys && $backup_sys_versions) { $next_widget = \&restore_step_sys; }
	    elsif ($restore_user) { $next_widget = \&restore_step_user;}
	    elsif ($restore_other){ $next_widget = \&restore_step_other;}
	    else{ $next_widget = \&restore_do;}
	})
	}
    gtksignal_connect(gtkset_active($check_restore_other_path, $restore_other_path), toggled => sub {
	$restore_other_path = $restore_other_path ? 0 : 1;
	${$central_widget}->destroy();
	$current_widget->();
    });
    gtksignal_connect(gtkset_active($check_restore_other_src, $restore_other_src), toggled => sub {
	$restore_other_src = $restore_other_src ? 0 : 1;
	${$central_widget}->destroy();
	$current_widget->();
    });
    fonction_env(\$retore_step2, \&restore_step2, \&restore_box, "restore");
    if (!$restore_sys && !$restore_user && !$restore_other) { $next_widget = \&message_norestore_box; }
    elsif ($restore_sys && $backup_sys_versions) { $next_widget = \&restore_step_sys; }
    elsif ($restore_user) { $next_widget = \&restore_step_user;}
    elsif ($restore_other){ $next_widget = \&restore_step_other;}
    else{ $next_widget = \&restore_do;}
    $restore_path_entry->set_text($restore_path); 
    $restore_path_entry->signal_connect( 'changed', sub { $restore_path = $restore_path_entry->get_text(); });
    $up_box->show_all();
}

sub restore_box {
    my $retore_box;
    my $retore_box3;
    my $check_restore_sys;
    my $check_restore_user;
    my $check_restore_other;
    $path_to_find_restore = $save_path;
    find_backup_to_restore();
    button_box_restore_main();

    if ($other_backuped || $sys_backuped || @user_backuped) {
	gtkpack($advanced_box,
		$retore_box = gtkpack_(new Gtk::HBox(0,1),
				       1, new Gtk::VBox(0,10),
				       1, gtkpack_(new Gtk::VBox(0,10),
						   1, new Gtk::VBox(0,10),
						   1, new Gtk::VBox(0,10),
						   1, gtksignal_connect(new Gtk::Button(_("Restore all backups")), 
						       clicked => sub { $retore_box->destroy();
									button_box_restore();
									@user_list_to_restore2 = sort @user_backuped; 
									$restore_sys = 1;
									$restore_other = 1;
									$restore_user = 1;
									restore_do(); }),
						   1, gtksignal_connect(new Gtk::Button(_("Custom Restore")), 
						       clicked => sub { $retore_box->destroy();
									button_box_restore(); 
									restore_step2();
								    }),
						   1, new Gtk::VBox(0,10),
						   1, new Gtk::VBox(0,10),
						   ),
				       1, new Gtk::HBox(0,10),
				       ),
		);
    } else {
	gtkpack($advanced_box,
		$retore_box = gtkpack_(new Gtk::HBox(0,1),
				       message_norestorefile_box(),
				       ),
		),
     }
    fonction_env(\$retore_box, \&restore_box, \&interactive_mode_box, "restore");
    $up_box->show_all();
}

################################################  BUTTON_BOX  ################################################  



# sub generic_button_box {
# # 1-n -  [button name, fonctions associated]
#     $button_box_tmp->destroy();
#     gtkpack($button_box,
# 	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox,				         
# 				       0, gtksignal_connect(new Gtk::Button($_->[0]), clicked => sub {$_->[1]}) foreach (@_), 
# 				       } ), );    
# }

sub button_box_adv {
    $button_box_tmp->destroy();
    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox,
				       0, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
					   ${$central_widget}->destroy(); interactive_mode_box();  }),
				       0, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub { 
					   ${$central_widget}->destroy(); adv_help(\&$current_widget,$custom_help );  }),
				       1, new Gtk::HBox(0, 1),	
				       0, gtksignal_connect(new Gtk::Button(_("Previous")), clicked => sub { 
					   ${$central_widget}->destroy(); $previous_widget->(); }),
				       0, gtksignal_connect(new Gtk::Button(_("Save")), clicked => sub { 
					   ${$central_widget}->destroy();  save_conf_file(); $previous_widget->(); }),
				       ),
	    );
}


# sub button_box_adv {
#     generic_button_box(["cancel", ${$central_widget}->destroy() ]);
# }



sub button_box_restore_main {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(gtkpack_(new Gtk::HButtonBox, 
					       0, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
						   ${$central_widget}->destroy(); interactive_mode_box();  }),
					       0, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub {
						   ${$central_widget}->destroy(); 
						   adv_help(\&$current_widget, $custom_help);
					       }),
					       1, new Gtk::HBox(0, 1),	
					       0, gtksignal_connect(new Gtk::Button(_("Previous")), clicked => sub { 
						   ${$central_widget}->destroy(); interactive_mode_box(); }),
					       0, gtksignal_connect(new Gtk::Button(_("Ok")), clicked => sub { 
						   ${$central_widget}->destroy(); interactive_mode_box(); }),
					       ),
				       ),
	    );
}

sub button_box_backup_end {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox,
				       0, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
					   ${$central_widget}->destroy(); interactive_mode_box();  }),
				       0, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub { 
					   ${$central_widget}->destroy(); adv_help(\&$current_widget,$custom_help );  }),
				       1, new Gtk::HBox(0, 1),	
				       0, gtksignal_connect(new Gtk::Button(_("Previous")), clicked => sub { 
					   ${$central_widget}->destroy(); $previous_widget->(); }),
				       0, gtksignal_connect(new Gtk::Button(_("Build Backup")), clicked => sub { 
					   ${$central_widget}->destroy();
					   build_backup_status();
					   build_backup_files(); 
				       }),
				       ),
	    );
}

sub button_box_wizard_end {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox,
				       0, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
					   ${$central_widget}->destroy(); interactive_mode_box();  }),
				       0, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub { 
					   ${$central_widget}->destroy(); adv_help(\&$current_widget,$custom_help );  }),
				       1, new Gtk::HBox(0, 1),	
				       0, gtksignal_connect(new Gtk::Button(_("Previous")), clicked => sub { 
					   ${$central_widget}->destroy(); $previous_widget->(); }),
				       0, gtksignal_connect(new Gtk::Button(_("Save")), clicked => sub { 
 					   ${$central_widget}->destroy();  save_conf_file(); interactive_mode_box(); }),
				       ),
	    );
}

sub button_box_restore_end {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox,
				       0, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
					   ${$central_widget}->destroy(); interactive_mode_box();  }),
				       0, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub { 
					   ${$central_widget}->destroy(); adv_help(\&$current_widget,$custom_help );  }),
				       1, new Gtk::HBox(0, 1),	
				       0, gtksignal_connect(new Gtk::Button(_("Previous")), clicked => sub { 
					   ${$central_widget}->destroy(); $previous_widget->(); }),
				       0, gtksignal_connect(new Gtk::Button(_("Restore")), clicked => sub { 
 					   ${$central_widget}->destroy(); restore_backend(); }),
				       ),
	    );
}

sub button_box_build_backup_end {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox, 
				       1, new Gtk::HBox(0, 5),	
				       1, new Gtk::HBox(0, 5),	
				       0, gtksignal_connect(new Gtk::Button(_("Ok")), clicked => sub { 
					   ${$central_widget}->destroy(); interactive_mode_box();  }),

				       ),
	    );
}

sub button_box_restore_pbs_end {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox, 
				       1, new Gtk::HBox(0, 5),	
				       1, new Gtk::HBox(0, 5),	
				       1, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub {
					   ${$central_widget}->destroy(); adv_help(\&$current_widget,$custom_help); }),
				       0, gtksignal_connect(new Gtk::Button(_("Ok")), clicked => sub { 
					   ${$central_widget}->destroy(); interactive_mode_box();  }),

				       ),
	    );
}

sub button_box_build_backup {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox,
				       1, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
					   ${$central_widget}->destroy(); interactive_mode_box();  }),
				       1, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub {
					   ${$central_widget}->destroy(); adv_help(\&$current_widget,$custom_help); }),
				       1, new Gtk::HBox(0, 0),
				       0, gtksignal_connect(new Gtk::Button(_("Previous")), clicked => sub { 
					   ${$central_widget}->destroy(); $previous_widget->(); }),
				       1, gtksignal_connect(new Gtk::Button(_("Next")), clicked => sub {
					   ${$central_widget}->destroy(); $next_widget->();
				       }),
				       ),
	    );
}

sub button_box_restore {

    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox,
				       1, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
					   ${$central_widget}->destroy(); interactive_mode_box();  }),
				       1, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub {
					   ${$central_widget}->destroy(); adv_help(\&$current_widget,$custom_help); }),
				       1, new Gtk::HBox(0, 0),
				       0, gtksignal_connect(new Gtk::Button(_("Previous")), clicked => sub { 
					   ${$central_widget}->destroy(); $previous_widget->(); }),
				       1, gtksignal_connect(new Gtk::Button(_("Next")), clicked => sub {
					   ${$central_widget}->destroy(); $next_widget->();
				       }),
				       ),
	    );
}

sub button_box_wizard {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack_(new Gtk::HButtonBox,
				       1, gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { 
								${$central_widget}->destroy(); interactive_mode_box();  }),
				       1, gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub {
								${$central_widget}->destroy(); adv_help(\&$current_widget,$custom_help); }),
				       1, new Gtk::HBox(0, 0),
				       0, gtksignal_connect(new Gtk::Button($next_widget ? _("Previous") : _("OK")), clicked => sub { 
								${$central_widget}->destroy();
								$previous_widget ? $previous_widget->() : $next_widget->();
							    }),
				       if_($next_widget, 1, gtksignal_connect(new Gtk::Button(_("Next")), clicked => sub {
										  ${$central_widget}->destroy();
										  $next_widget ? $next_widget->() : $previous_widget->();
									      })),
				      ),
	    );
}

sub button_box_main {
    $button_box_tmp->destroy();

    gtkpack($button_box,
	    $button_box_tmp = gtkpack(gtkset_layout(new Gtk::HButtonBox, -start),
				      gtksignal_connect(new Gtk::Button(_("Close")), clicked => sub {  
					  Gtk->main_quit() }),
				      gtksignal_connect(new Gtk::Button(_("Help")), clicked => sub { 
					  ${$central_widget}->destroy(); adv_help(\&interactive_mode_box,$custom_help) }),
				      ),
	    );
}

################################################  MESSAGES  ################################################  

sub message_norestorefile_box {
    $box2->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');
    
    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack(new Gtk::HBox(0, 15),	
				       new Gtk::VBox(0, 5),	
				       new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
			     _("Please Build backup before to restore it...\n or verify that your path to save is correct."),
				       new Gtk::VBox(0, 5),	
				       ),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    button_box_restore_main();
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub send_mail_pb {
    $table->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');
    
    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    0, gtkpack_(new Gtk::HBox(0, 15),	
					0, new Gtk::VBox(0, 5),	
					0, new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
					0, _("Error durind sendmail
  your report mail was not sent
  Please configure sendmail"),
					),
			    0, new Gtk::VBox(0, 5),	
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    button_box_restore_main();
    $custom_help = "mail_pb";
    $central_widget = \$box2;
    $up_box->show_all();    
}




sub install_rpm {
    my ($previous_function) = @_,
    my $box_what_user;
    
    gtkpack($advanced_box,
	    $box_what_user = gtkpack_(new Gtk::VBox(0, 15),
				      0, _("Package List to Install"),
				      0, new Gtk::HSeparator,
				      0, createScrolledWindow( 
						gtkpack__(new Gtk::VBox(0,0),
							map { my $b = new Gtk::Button($_); } (@list_of_rpm_to_install) 
							  ),), ),
	    );
    fonction_env(\$box_what_user, \&install_rpm, \&$previous_function, "what");
    $up_box->show_all();
}








sub client_ftp_pb {
    $table->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');
    
    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    0, gtkpack_(new Gtk::HBox(0, 15),	
					0, new Gtk::VBox(0, 5),	
					0, new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
					0, _("Error durind sending file via FTP.
 Please correct your FTP configuration."),
					),
			    0, new Gtk::VBox(0, 5),	
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    button_box_restore_main();
    $custom_help = "mail_pb";
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub message_norestore_box {
    $box2->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');
    
    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack(new Gtk::HBox(0, 15),	
				       new Gtk::VBox(0, 5),	
				       new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
				       _("Please select data to restore..."),
				       new Gtk::VBox(0, 5),	
				       ),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    button_box_restore_main();
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub message_noselect_box {
    $box2->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');
    
    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack(new Gtk::HBox(0, 15),	
				       new Gtk::VBox(0, 5),	
				       new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
				       _("Please select media for backup..."),
				       new Gtk::VBox(0, 5),	
				       ),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    $previous_widget = \&wizard_step2;
    $next_widget = \&wizard_step2;
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub message_noselect_what_box {
    $box2->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');
    
    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack(new Gtk::HBox(0, 15),	
				       new Gtk::VBox(0, 5),	
				       new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
				       _("Please select data to backup..."),
				       new Gtk::VBox(0, 5),	
				       ),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    $previous_widget = \&wizard;
    $next_widget = \&wizard;
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub message_noconf_box {
    $box2->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');

    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack(new Gtk::HBox(0, 15),	
				       new Gtk::VBox(0, 5),	
				       new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
				       _("No configuration file found \nplease click Wizard or Advanced."),
				       new Gtk::VBox(0, 5),	
				       ),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    button_box_restore_main();
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub message_underdevel {
    $box2->destroy();
    my ($pix_warn_map, $pix_warn_mask) = gtkcreate_png('warning');

    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack(new Gtk::HBox(0, 15),	
				       new Gtk::VBox(0, 5),	
				       new Gtk::Pixmap($pix_warn_map, $pix_warn_mask),
				       _("Under Devel ... please wait."),
				       new Gtk::VBox(0, 5),	
				       ),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    $central_widget = \$box2;
    $up_box->show_all();    
}

################################################  BUILD_BACKUP  ################################################  

sub progress {
    my ($progressbar, $incr, $label_text) = @_;
    my($new_val) = $progressbar->get_current_percentage;
    $new_val += $incr;
    if ($new_val > 1) {$new_val = 1}
    $progressbar->update($new_val);
    $progressbar->{label}->set($label_text);
    Gtk->main_iteration while Gtk->events_pending;
}

sub find_backup_to_put_on_cd {
    my @list_backup_tmp;
    my @data_backuped_tmp;
    @data_backuped = ();
    -d $save_path and my @list_backup = all($save_path);
    foreach (grep /^backup_other/, @list_backup) {
	$other_backuped = 1;
	chomp;
	my $tail  = (split(' ',`du $save_path/$_` ))[0] ;
	s/^backup_other//gi;
	s/.tar.gz$//gi;
	s/.tar.bz2$//gi;
	my @user_date = split(/\_20/,$_ );
	my @user_date2 = split(/\_/,$user_date[1] );
	my $to_put = "  other_data,          (tail: $tail ko, date: 20$user_date2[0], hour: $user_date2[1])";
	push @data_backuped , $to_put;
    }
    foreach (grep /_sys_/, @list_backup) {
	$sys_backuped = 1;
	chomp;
	my $tail  = (split(' ',`du $save_path/$_` ))[0] ;
	s/^backup_other//gi;
	s/.tar.gz$//gi;
	s/.tar.bz2$//gi;
	my @user_date = split(/\_20/,$_ );
	my @user_date2 = split(/\_/,$user_date[1] );
	my $to_put = "  system,          (tail: $tail ko, date: 20$user_date2[0], hour: $user_date2[1])";
	push @data_backuped , $to_put;
    }
    foreach (grep /user_/, @list_backup) {
	chomp;
	my $tail  = (split(' ',`du $save_path/$_` ))[0] ;
	s/^backup_user_//gi;
	s/.tar.gz$//gi;
	s/.tar.bz2$//gi;
	my @user_date = split(/\_20/,$_ );
	my @user_date2 = split(/\_/,$user_date[1] );
	my $to_put = "  $user_date[0],          (tail: $tail ko, date: 20$user_date2[0], hour: $user_date2[1])";
	push @data_backuped , $to_put;
    }
}

sub build_backup_status {
    $pbar =   new Gtk::ProgressBar;
    $pbar1 =  new Gtk::ProgressBar;
    $pbar2 =  new Gtk::ProgressBar;
    $pbar3 =  new Gtk::ProgressBar;
    button_box_build_backup_end();
    gtkpack($advanced_box,
	    $table = create_packtable({ col_spacings => 10, row_spacings => 5},
   [""], 
   [""], 
   [""], 
   [""], 
   [""], 
   [""], 
   [""], 
   [""], 
   [_("Backup system files")],
   [ $pbar, $pbar->{label} = new Gtk::Label(' ' )],
   [_("Backup user files") ],
   [$pbar1,$pbar1->{label} = new Gtk::Label(' ' ) ],
   [_("Backup other files")],
   [ $pbar2, $pbar2->{label} = new Gtk::Label(' ' ) ],
   [_("Total Progress")],
   [$pbar3,$pbar3->{label} = new Gtk::Label(' ' ) ],
				      ),
	    );
    $custom_help = "options";
    $central_widget = \$table;
    $up_box->show_all();
    Gtk->main_iteration while Gtk->events_pending;
}


sub build_backup_ftp_status {
    $pbar =   new Gtk::ProgressBar;
    $pbar3 =  new Gtk::ProgressBar;
    $table->destroy();
    button_box_build_backup_end();
    $pbar->set_value(0);
    $pbar3->set_value(0);


    gtkpack($advanced_box,
	    $table =  gtkpack_(new Gtk::VBox(0, 15),
			       1, _("files sending by FTP"),
			       1, new Gtk::VBox(0, 15),
			       1, create_packtable({ col_spacings => 10, row_spacings => 5},
#						    [ $pbar->set_show_text( $show_text );
						    [_("Sending files...")],
						    [""], 
						    [ $pbar->{label} = new Gtk::Label(' ' )],
						    [ $pbar],
						    [""], 
						    [_("Total Progress")],
						    [ $pbar3->{label} = new Gtk::Label(' ' ) ],
						    [$pbar3],
						    ),
			       1, new Gtk::VBox(0, 15),
			      ),
	    );
    $custom_help = "options";
    $central_widget = \$table;
    $up_box->show_all();
    Gtk->main_iteration while Gtk->events_pending;
}



sub build_backup_box_see_conf {
    my $box2;    
    my $text = new Gtk::Text(undef, undef);
    system_state();
    gtktext_insert($text, $system_state);
    button_box_restore_main();

    gtkpack($advanced_box,
	    $box2 =  gtkpack_(new Gtk::HBox(0, 15),	
			      1, gtkpack_(new Gtk::VBox(0,10),
					  0, _("Drakbackup Configuration"),
					  1, createScrolledWindow($text),
					  ),
			      ),
	    );
    button_box_backup_end();
    $custom_help = "";
    $central_widget = \$box2;
    $current_widget = \&build_backup_box_see_conf;
    $previous_widget =\&build_backup_box;
    $up_box->show_all();
}

sub build_backup_box_progress {
#    build_backup_files(); 
}

sub aff_total_tail {
    my @toto = ();
    my $total = 0;
    push @toto, (split (",", $_))[1]  foreach @list_to_build_on_cd;
    foreach (@toto) {
	s/\s+\(tail://gi;
	s/\s+//gi;
	s/ko//gi;
	$total += $_; 
	}
    $label_tail->set("total tail: $total ko");
}

my %check_data_to_backup_cd;
sub build_backup_cd_select_data {
    my $retore_step_user;
    find_backup_to_put_on_cd();
    @list_to_build_on_cd = sort @data_backuped;
    @data_backuped = @list_to_build_on_cd;

    gtkpack($advanced_box,
	    $retore_step_user = gtkpack_(new Gtk::VBox(0,10),
		     0, new Gtk::VBox(0,10),
		     0, _("Data list to include on CDROM."),
		     1, createScrolledWindow( gtkpack__(new Gtk::VBox(0,0),
						      map { my $name = $_;
							    my @user_list_tmp = ();
							    my $b = new Gtk::CheckButton($name); 
							    if ( grep $name , @list_to_build_on_cd)  {
								gtkset_active($b, 1);
							    } else {
								gtkset_active($b, 0);
							    }
							    $b->signal_connect(toggled => sub {
								if (!$check_data_to_backup_cd{$name}[1] ) {
								    $check_data_to_backup_cd{$name}[1] = 1;
								    if (!grep ( /$name$/, @list_to_build_on_cd) ) {
									push @list_to_build_on_cd, $name;}
								} else {
								    $check_data_to_backup_cd{$name}[1] = 0;
								    foreach (@list_to_build_on_cd) {
									if ($name ne $_) {
									    push @user_list_tmp, $_;
									}
								    }
								    @list_to_build_on_cd = @user_list_tmp;
								}
								aff_total_tail();
							    });
							    $b } (@data_backuped) 
						      ),
					      ),
		      0, new Gtk::HSeparator,
		      0, $label_tail = new Gtk::Label(" "),
		      0, new Gtk::HSeparator,
					 ),
	    );
    aff_total_tail();
    fonction_env(\$retore_step_user, \&restore_step_user, \&build_backup_cd_box, "restore", \&build_backup_box_see_conf);
    $up_box->show_all();
}

sub build_backup_cd_box {
    my $box_build_backup_cd;
    my $combo_where_cd_time = new Gtk::Combo();
    my $adj = new Gtk::Adjustment 4.0, 1.0, 10000.0, 1.0, 5.0, 0.0;
    $combo_where_cd_time->set_popdown_strings ("650","700", "750", "800");

    button_box_build_backup();
    gtkpack($advanced_box,
	    $box_build_backup_cd = gtkpack_(new Gtk::VBox(0, 6),
	 0, my $check_where_cd = new Gtk::CheckButton( _("Use CD/DVDROM to backup")),
	 0, new Gtk::HSeparator,
	 0, new Gtk::VBox(0, 5),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please choose your CD space")), $where_cd),
		     1, new Gtk::VBox(0, 5),
		     0, gtkset_usize(gtkset_sensitive($combo_where_cd_time, $where_cd), 100, 20),
		     ),
	 0, new Gtk::VBox(0, 5),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please enter the cd writer speed")),  $where_cd ),
		     1, new Gtk::VBox(0, 6),
		     0, gtkset_usize(gtkset_sensitive(my $spinner = new Gtk::SpinButton( $adj, 0, 0), $where_cd ),  100, 20),
		     ),				 
	 0, new Gtk::VBox(0, 5),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please check if you are using CDRW media")), $where_cd),
		     1, new Gtk::VBox(0, 5),
		     0, gtkset_sensitive(my $check_cdrw = new Gtk::CheckButton(), $where_cd),
		     ),
	 0, new Gtk::VBox(0, 5),
	 0, gtkpack_(new Gtk::HBox(0,10),
	    0, gtkset_sensitive(new Gtk::Label(_("Please check if you want to erase your CDRW before")), $cdrw && $where_cd),
	    1, new Gtk::VBox(0, 5),
	    0, gtkset_sensitive(my $check_cdrw_erase = new Gtk::CheckButton(), $cdrw && $where_cd),
		     ),
					    0, new Gtk::VBox(0, 5),
					    0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please enter your CD Writer device name (ex: 0,1,0)")),  $where_cd),
		     1, new Gtk::VBox(0, 5),
		     0, gtkset_usize(gtkset_sensitive($cd_devive_entry = new Gtk::Entry(), $where_cd), 100, 20),
		     ),
	 0, new Gtk::VBox(0, 5),
	 0, gtkpack_(new Gtk::HBox(0,10),
		     0, gtkset_sensitive(new Gtk::Label(_("Please check if you want to include install boot on your CD.")),  0),
		     1, new Gtk::VBox(0, 5),
		     0, gtkset_sensitive(my $check_cd_with_install_boot = new Gtk::CheckButton(), 0),
		     ),
	 ),
	    );
    foreach ([$check_cdrw_erase, \$cdrw_erase], [$check_cd_with_install_boot, \$cd_with_install_boot ]) {
	my $ref = $_->[1];
	gtksignal_connect(gtkset_active($_->[0], ${$ref}), toggled => sub { ${$ref} = ${$ref} ? 0 : 1; })
	}
    gtksignal_connect(gtkset_active($check_where_cd, $where_cd), toggled => sub { 
	$where_cd = $where_cd ? 0 : 1;
	${$central_widget}->destroy();
	$current_widget->();
	if($where_cd) { $next_widget = \&build_backup_cd_select_data;}
	else { $next_widget = \&build_backup_cd_box;}
    });
    gtksignal_connect(gtkset_active($check_cdrw, $cdrw), toggled => sub { 
	$cdrw = $cdrw ? 0 : 1;
	${$central_widget}->destroy();
	$current_widget->();
    });
    if($where_cd) { $next_widget = \&build_backup_cd_select_data;}
    else { $next_widget = \&build_backup_cd_box;}
    $cd_devive_entry->set_text( $cd_devive );
    $cd_devive_entry->signal_connect( 'changed', sub { $cd_devive = $cd_devive_entry->get_text(); });
    $combo_where_cd_time->entry->set_text($cd_time);
    $combo_where_cd_time->entry->signal_connect( 'changed', sub { $cd_time = $combo_where_cd_time->entry->get_text()});	       
    fonction_env(\$box_build_backup_cd, \&build_backup_cd_box, \&build_backup_box, "");
    $up_box->show_all();
}

sub build_backup_box {
    $box2->destroy();
    my ($pix_cd_map, $pix_cd_mask) = gtkcreate_png("ic82-CD-40");
    my ($pix_hd_map, $pix_hd_mask) = gtkcreate_png("ic82-discdurwhat-40");
    my ($pix_options_map, $pix_options_mask) = gtkcreate_png("ic82-moreoption-40");

    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack_(new Gtk::VBox(0, 15),	
					1, new Gtk::VBox(0, 5),	
					1, gtksignal_connect(my $button_from_conf_file = new Gtk::Button(),
							     clicked => sub { ${$central_widget}->destroy();
									      build_backup_box_see_conf();
									  }),
					0, new Gtk::VBox(0, 5),	
# 					1, gtksignal_connect(my $button_on_cd = new Gtk::Button(), 
# 							     clicked => sub { ${$central_widget}->destroy(); 
# 									      $where_cd = 1;
# 									      build_backup_cd_box();
# 									  }),
# 					0, new Gtk::VBox(0, 5),	
					1, gtksignal_connect(my $button_see_conf = new Gtk::Button(), 
							     clicked => sub { ${$central_widget}->destroy();
									      build_backup_box_see_conf();
									  }),
					1, new Gtk::VBox(0, 5),	
					),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );

    $button_from_conf_file->add(gtkpack(new Gtk::HBox(0,10),
			      new Gtk::Pixmap($pix_hd_map, $pix_hd_mask),
			      new Gtk::Label(_("Backup Now from configuration file")),
			      new Gtk::HBox(0, 5)
			      ));
#     $button_on_cd->add(gtkpack(new Gtk::HBox(0,10),
# 			      new Gtk::Pixmap($pix_cd_map, $pix_cd_mask),
# 			      new Gtk::Label(_("Backup Now on CDROM")),
# 			      new Gtk::HBox(0, 5)
# 			      ));
    $button_see_conf->add(gtkpack(new Gtk::HBox(0,10),
			      new Gtk::Pixmap($pix_options_map, $pix_options_mask),
			      new Gtk::Label(_("View Backup Configuration.")),
			      new Gtk::HBox(0, 5)
			      ));


    button_box_restore_main();
    fonction_env(\$box2, \&build_backup_box, \&interactive_mode_box, "options");
    $up_box->show_all();    
}

################################################  INTERACTIVE  ################################################  

sub interactive_mode_box {
    $box2->destroy();

    read_conf_file();
    gtkadd($advanced_box,
	   $box2 = gtkpack_(new Gtk::HBox(0, 15),	
			    1, new Gtk::VBox(0, 5),	
			    1, gtkpack_(new Gtk::VBox(0, 15),	
					1, new Gtk::VBox(0, 5),	
					1, gtksignal_connect(new Gtk::Button(_("Wizard Configuration")), 
							     clicked => sub { ${$central_widget}->destroy();
									      read_conf_file();
									      wizard(); }),
					1, gtksignal_connect(new Gtk::Button(_("Advanced Configuration")), 
							     clicked => sub { button_box_adv();
									      ${$central_widget}->destroy();
									      advanced_box(); }),
					1, gtksignal_connect(new Gtk::Button(_("Backup Now")), 
							     clicked => sub { ${$central_widget}->destroy();
									      if ($cfg_file_exist) { build_backup_box();}
									      else { message_noconf_box();}
									  }),
					1, gtksignal_connect(new Gtk::Button(_("Restore")), 
							     clicked => sub {${$central_widget}->destroy(); restore_box();}),
					1, new Gtk::VBox(0, 5),	
					),
			    1, new Gtk::VBox(0, 5),	
			    ),
	   );
    button_box_main();
    $custom_help = "main";
    $central_widget = \$box2;
    $up_box->show_all();    
}

sub interactive_mode {
    $interactive = 1;
    my $box;
    my $window1 = $::isEmbedded ? new Gtk::Plug ($::XID) : new Gtk::Window -toplevel;
    init Gtk;
    $window1->signal_connect (delete_event => sub { Gtk->exit(0) });
    $window1->set_position(1);
    $window1->set_title(_("Drakbackup"));
    my ($pix_u_map, $pix_u_mask) = gtkcreate_png("drakbackup.540x57");
    read_conf_file();    

    gtkadd($window1,
	   gtkpack(new Gtk::VBox(0,0),
		   gtkpack(gtkset_usize($up_box = new Gtk::VBox(0, 5), 540, 400),
		      $box = gtkpack_(new Gtk::VBox(0, 3),
			 0,  new Gtk::Pixmap($pix_u_map, $pix_u_mask),
			    1, gtkpack_(new Gtk::HBox(0, 3),
				  1, gtkpack_(new Gtk::HBox(0, 15),	
					     0, new Gtk::HBox(0, 5),	
					     1, $advanced_box = gtkpack_(new Gtk::HBox(0, 15),	
								      1, $box2 = gtkpack_(new Gtk::VBox(0, 15),	
											  ),
									  ),
					      0, new Gtk::HBox(0, 5),	
					      ),
					),
				      0, new Gtk::HSeparator,
				      0, $button_box = gtkpack(new Gtk::VBox(0, 15),	
							       $button_box_tmp = gtkpack(new Gtk::VBox(0, 0),	
											 ),
							       ),
				      ),
			   ),
		   ),
	   );
    interactive_mode_box();
    $custom_help = "main";
    button_box_main();
    $central_widget = \$box2;
    $window1->show_all;
    $window1->realize;
    $window1->show_all();    
    Gtk->main;
    Gtk->exit(0);
}

################################################  HELP & ABOUT  ################################################  


sub adv_help {
    my ($function, $custom_help) = @_,
    my $text = new Gtk::Text(undef, undef);
    my $advanced_box_help;

################################################  help definition ##############################################

    my %custom_helps = (
			"options" => 
			_("options description:

 In this step Drakbackup allow you to change:

 - The compression mode:
    
      If you check bzip2 compression, you will compress
      your data better than gzip (about 2-10 %).
      This option is not checked by default because
      this compression mode needs more time ( about 1000% more).
 
 - The update mode:

      This option will update your backup, but this
      option is not really useful because you need to
      decompress your backup before you can update it.
      
 - the .backupignore mode:

      Like with cvs, Drakbackup will ignore all references
      included in .backupignore files in each directories.
      ex: 
         #> cat .backupignore
         *.o
         *~
         ...
      

"), 
			"mail_pb" =>
			_("
 Some errors during sendmail are caused by 
 a bad configuration of postfix. To solve it you have to
 set myhostname or mydomain in /etc/postfix/main.cf

"),

			"what" =>
			_("options description:

 - Backup system files:
       
	This option allows you to backup your /etc directory,
	which contains all configuration files. Please be
	careful during the restore step to not overwrite:
		/etc/passwd 
		/etc/group 
		/etc/fstab

 - Backup User files: 

	This option allows you select all users that you want 
	to backup.
	To preserve disk space, it is recommended that you 
	do not include web browser's cache.

 - Backup Other files: 

	This option allows you to add more data to save.
	With the other backup it's not possible at the 
	moment to select select incremental backup.		
 
 - Incremental Backups:

	The incremental backup is the most powerful 
	option for backup. This option allows you 
	to backup all your data the first time, and 
	only the changed afterward.
	Then you will be able, during the restore
	step, to restore your data from a specified
	date.
	If you have not selected this option all
	old backups are deleted before each backup.    


"), 
			"restore" =>
			_("restore description:
 
Only the most recent date will be used ,because with incremental 
backups it is necesarry to restore one by one each older backups.

So if you don't like to restore an user please unselect all his
check box.

Otherwise, you are able to select only one of this

 - Incremental Backups:

	The incremental backup is the most powerfull 
	option to use backup, this option allow you 
	to backup all your data the first time, and 
	only the changed after.
	So you will be able during the restore
	step, to restore your data from a specified
	date.
	If you have not selected this options all
	old backups are deleted before each backup.    



"),  
			"main" =>
			_(" Copyright (C) 2001 MandrakeSoft by DUPONT Sebastien <dupont_s\@epita.fr>") .
"\n\n" .
_(" This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.") .
"\n\n                                            _____________________\n" .
_("Description:

  Drakbackup is used to backup your system.
  During the configuration you can select: 
	- System files, 
	- Users files, 
	- Other files.
	or All your system ...  and Other (like Windows Partitions)

  Drakbackup allows you to backup your system on:
	- Harddrive.
	- NFS.
	- CDROM (CDRW), DVDROM (with autoboot, rescue and autoinstall.).
	- FTP.
	- Rsync.
	- Webdav.
	- Tape.

  Drakbackup allows you to restore your system to
  a user selected directory.

  Per default all backup will be stored on your
  /var/lib/drakbackup directory

  Configuration file:
	/etc/drakconf/drakbackup/drakbakup.conf


Restore Step:
  
  During the restore step, DrakBackup will remove 
  your original directory and verify that all 
  backup files are not corrupted. It is recommended 
  you do a last backup before restoring.


"),
			"ftp" =>
			_("options description:

Please be careful when you are using ftp backup, because only 
backups that are already built are sent to the server.
So at the moment, you need to build the backup on your hard 
drive before sending it to the server.

"),
			"restore_pbs" =>
			_("
Restore Backup Problems:

During the restore step, Drakbackup will verify all your
backup files before restoring them.
Before the restore, Drakbackup will remove 
your original directory, and you will loose all your 
data. It is important to be careful and not modify the 
backup data files by hand.
")
);

    my $default_help = _(" Copyright (C) 2001 MandrakeSoft by DUPONT Sebastien <dupont_s\@epita.fr>") .
"\n\n" .
_(" This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.") .
"\n\n                                            _____________________\n" .
_("Description:

  Drakbackup is used to backup your system.
  During the configuration you can select 
	- System files, 
	- Users files, 
	- Other files.
	or All your system ...  and Other (like Windows Partitions)

  Drakbackup allows you to backup your system on:
	- Harddrive.
	- NFS.
	- CDROM (CDRW), DVDROM (with autoboot, rescue and autoinstall.).
	- FTP.
	- Rsync.
	- Webdav.
	- Tape.

  Drakbackup allows you to restore your system to
  a user selected directory.

  Per default all backup will be stored on your
  /var/lib/drakbackup directory

  Configuration file:
	/etc/drakconf/drakbackup/drakbakup.conf

Restore Step:
  
  During the restore step, Drakbackup will remove
  your original directory and verify that all
  backup files are not corrupted. It is recommended
  you do a last backup before restoring.
 

");

################################################  help fonction ##############################################

    gtktext_insert($text, $custom_helps{$custom_help} || $default_help);
    gtkpack($advanced_box,
	    $advanced_box_help = gtkpack_(new Gtk::VBox(0,10),
					  1, gtkpack_(new Gtk::HBox(0,0),
						      1, $text, 
						      0, new Gtk::VScrollbar($text->vadj),
						      ),
					  0, gtkadd(gtkset_layout(new Gtk::HButtonBox, -spread),
						    gtksignal_connect(new Gtk::Button(_("OK")), clicked => sub { 
							${$central_widget}->destroy(); $function->();}),
						    ),
					  )
	    );
    $central_widget = \$advanced_box_help;
    $up_box->show_all();
}
