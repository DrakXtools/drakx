#!/usr/bin/perl

# DiskDrake
# Copyright (C) 1999 MandrakeSoft (pixel@mandrakesoft.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# DiskDrake uses resize_fat which is a perl rewrite of the work of Andrew
# Clausen (libresize).
# DiskDrake is also based upon the libfdisk and the install from Red Hat Software


use lib qw(/usr/lib/libDrakX);

use standalone;     #- warning, standalone must be loaded very first, for 'explanations'

use common;
use diskdrake::interactive;
use interactive;
use detect_devices;
use fsedit;
use fs;
use log;
use c;


my %options;
my @l = @ARGV;
while (my $e = shift @l) {
    my ($option) = $e =~ /--?(.*)/ or next;
    if ($option eq 'embedded') {
	$::isEmbedded = 1;
	($::XID, $::CCPID, @l) = @l;
    } elsif ($option =~ /(.*?)=(.*)/) {
	$options{$1} = $2;
    } else {
	$options{$option} = '';
    }
}
$::expert = defined(delete $options{expert});
$::testing = defined(delete $options{testing});

my @types = qw(hd nfs smb removable fileshare);
my ($type, $para) = ('hd', '');
foreach (@types) {
    if (exists $options{$_}) {
        $para = delete $options{$_};
	$type = $_;
	last;
    }
}
%options and die "usage: diskdrake [--expert] [--testing] [--{" . join(",", @types) . "}]\n";

if ($>) {
    $ENV{PATH} = "/sbin:/usr/sbin:$ENV{PATH}";
}


my $in = 'interactive'->vnew('su');

if ($type eq 'fileshare') {
    any::fileshare_config($in);
    $in->exit(0);
}

my $all_hds = do {
    if ($type eq 'hd') {
	catch_cdie { fsedit::hds([ detect_devices::hds() ], {}) }
	  sub {
	      my $err = formatError($@);
	      if ($err =~ s/ask_before_blanking://) {
		  $in->ask_okcancel(_("Error"),
[_("I can't read your partition table, it's too corrupted for me :(
I'll try to go on blanking bad partitions"), $err]);
              } else {
	          $in->ask_warn('', $err);
		  1;
	      }
	  };
    } else { fsedit::empty_all_hds() }
};

$SIG{__DIE__} = sub { my $m = chomp_($_[0]); log::l("ERROR: $m") };
my $fstab = [ fsedit::get_all_fstab($all_hds) ];

fs::get_raw_hds('', $all_hds);

fs::merge_info_from_fstab([ fsedit::get_really_all_fstab($all_hds) ]);
fs::merge_info_from_mtab([ fsedit::get_really_all_fstab($all_hds) ]);

$all_hds->{current_fstab} = fs::fstab_to_string($all_hds);

if ($type eq 'hd') {
    diskdrake::interactive::main($in, $all_hds);
} elsif ($type eq 'removable') {
    require diskdrake::removable;
    $para =~ s|^/dev/||;
    my ($raw_hd) = $para ?
      first(grep { $para eq $_->{device} } @{$all_hds->{raw_hds}}) || die "unknown removable $para\n" :
      $in->ask_from_listf('', '', \&diskdrake::interactive::format_raw_hd_info, $all_hds->{raw_hds}) or $in->exit(0);
    diskdrake::removable::main($in, $all_hds, $raw_hd);
} else {
    $in->ask_warn('', "Sorry only a gtk frontend is available") if !$in->isa('interactive::gtk');
    require diskdrake::smbnfs_gtk;
    diskdrake::smbnfs_gtk::main($in, $all_hds, $type);
}

$in->exit(0);
