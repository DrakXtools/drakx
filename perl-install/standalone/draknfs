#!/usr/bin/perl
#
# Copyright (C) 2005 by Mandriva aginies _ateuh_ mandriva.com
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.

my $version = "0.2";

use strict;
use lib qw(/usr/lib/libDrakX);
use standalone;
use common;
use network::network;
use interactive;
use ugtk2 qw(:ask :wrappers :create :dialogs);

my $in = 'interactive'->vnew('su');
$in->do_pkgs->ensure_is_installed('nfs-utils', '/usr/sbin/rpc.nfsd') or return;

use constant FALSE => 0;
use constant TRUE => 1;
use constant COLUMN_DIR => 0;
use constant COLUMN_ACCESS => 1;
use constant COLUMN_RIGHT => 2;
use constant COLUMN_OPTIONS => 3;
use constant NUM_COLUMNS => 4;

my $CONF = "/etc/exports";
my @listshare;
my $root_squash = N("map root user as anonymous");
my $all_squash = N("map all users to anonymous user");
my $no_all_squash = N("allow real remote user access");
my $no_root_squash = N("allow real remote root access");
my @listuserid_data = split(", ", qq($root_squash, $all_squash, $no_all_squash, $no_root_squash)); push @listuserid_data, "";

my $userid_data = {
		   root_squash => $root_squash,
		   no_root_squash => $no_root_squash,
		   all_squash => $all_squash,
		   no_all_squash => $no_all_squash,
		  };

my @yesno = qw(yes no); push @yesno, "";

sub get_items {
    my @items = (
		 [ "/_File", undef, undef, undef, '<Branch>', ],
		 [ "/_File/_Exit", undef, \&quit_all, 1, '<StockItem>', 'gtk-quit' ],

		 [ "/_NFS Server", undef, undef, undef, '<Branch>', ],
		 [ "/_NFS Server/_Restart", undef, \&restart_dialog, 1, '<StockItem>', 'gtk-execute' ],
		 [ "/_NFS Server/R_eload", undef, \&reload_dialog, 1, '<StockItem>', 'gtk-refresh' ],
		 );
    return @items;
}

sub quit_all() {
  ugtk2->exit;
}

sub restart_dialog {
  wait_action("service nfs restart");
}

sub reload_dialog {
  wait_action("service nfs reload");
}

sub wait_action {
    my ($cmd) = @_;
    my $w = $in->wait_message(N("NFS server"), N("Restarting/Reloading NFS server..."));
    run_program::get_stdout($cmd) !~ /unknown|error/ or err_dialog(N("Error!"), N("Error Restarting/Reloading NFS server")) and return;
    undef $w;
}

my %size_groups = map { $_ => Gtk2::SizeGroup->new('horizontal') } qw(label widget button);
my $label_and_widgets = sub {
  my ($label, $widget, $button) = @_;
  gtkpack_(Gtk2::HBox->new(0,5),
           0, gtkadd_widget($size_groups{label}, $label),
           1, gtkadd_widget($size_groups{widget}, $widget),
	   2, gtkadd_widget($size_groups{button}, $button),
          );
};

my $fdwidget = sub {
  my ($data, $label) = @_;
  my $fd = new Gtk2::FileSelection(N("Directory Selection"));
  $fd->set_modal(TRUE);
  $fd->signal_connect("destroy", sub { $fd->hide });
  $fd->ok_button->signal_connect(clicked => sub {
				   my $file = $fd->get_filename;
				   -d $file or err_dialog(N("Error!"), N("Should be a directory.")) and return;
				   $data->set_text($file);
				   $fd->hide;
				 }, $fd);
  $fd->cancel_button->signal_connect(clicked => sub { $fd->hide });
  return $fd;
};

sub get_nfs_data {
# /home/nis *(async,rw,no_root_squash)
# /home/nis/guibo/Build *(async,rw,no_root_squash)
  foreach (cat_($CONF)) {
    my ($dir, $access, $right, $options) = m!^(/\S+)\s+(\S*)\((\S*)\)\s+(\S*)!;
    $dir and push @listshare, {
			       dir => $dir,
			       access => $access,
			       right => $right,
			       options => $options,
			     };
  }
}

sub write_conf {
  output($CONF, "# generated by drakhosts.pl\n");
  foreach my $a (@listshare) {
    append_to_file($CONF, "$a->{dir} $a->{access}($a->{right}) $a->{options}\n");
  }
}

my $help_access;
$help_access = N("<span weight=\"bold\">NFS clients</span> may be specified in a number of ways:


<span foreground=\"royalblue3\">single host:</span> a host either by an abbreviated name recognized be the resolver, fully qualified domain name, or an IP address


<span foreground=\"royalblue3\">netgroups:</span> NIS netgroups may be given as \@group.


<span foreground=\"royalblue3\">wildcards:</span> machine names may contain the wildcard characters * and ?. For instance: *.cs.foo.edu  matches all  hosts  in the domain cs.foo.edu.


<span foreground=\"royalblue3\">IP networks:</span> you can also export directories to all hosts on an IP (sub-)network simultaneously. for example, either `/255.255.252.0' or  `/22'  appended to the network base address result.
");

my $help_userid = N("<span weight=\"bold\">User ID options</span>


<span foreground=\"royalblue3\">root_squash:</span> map requests from uid/gid 0 to the anonymous uid/gid.


<span foreground=\"royalblue3\">no_root_squash:</span> turn off root squashing. This option is mainly useful for diskless clients.


<span foreground=\"royalblue3\">all_squash:</span> map all uids and gids to the anonymous  user. Useful  for  NFS-exported public FTP directories, news spool directories, etc. The opposite option is no_all_squash, which is the default  setting.


<span foreground=\"royalblue3\">anonuid and anongid:</span> explicitly  set the uid and gid of the anonymous account.
");

my $help_global = N("<span weight=\"bold\">Advanced Options</span>


<span foreground=\"royalblue3\">secure:</span> this option requires that requests originate on an internet port less than IPPORT_RESERVED (1024). This option is on by default. To turn it off, specify insecure.


<span foreground=\"royalblue3\">rw:</span> allow both read and write requests on this NFS volume. The default is to disallow any request which changes the filesystem. This can also be made explicit by using the ro option.


<span foreground=\"royalblue3\">async:</span> allows the NFS server to violate the NFS protocol and reply to requests before any changes made by that request have been committed to stable storage (e.g. disc drive).
");

sub create_pango_help_box {
  # perl code from draksec
  my ($help) = @_;
  my $text = Gtk2::TextView->new;
  use Gtk2::Pango;
  my %common_opts = ('left-margin' => '10', 'right-margin' => '10');
  gtktext_insert($text, [ map  {
    if (s!^/span>!!) {
      [ $_, \%common_opts ];
    } elsif (s!span !!) {
      my %tags = %common_opts;
      while (s!(\w+?)="(\w+?)"!!) {
	$tags{weight} ||= Gtk2::Pango->PANGO_WEIGHT_BOLD if $1 eq 'foreground';
	$tags{$1} = $2 eq "bold" ? Gtk2::Pango->PANGO_WEIGHT_BOLD : $2;
      }
      s/^>//;
      [ $_, \%tags ];
    } else {
      [ $_, \%common_opts ];
    }
  } split("<", formatAlaTeX($help)) ]);
  gtkset_size_request(create_scrolled_window($text), 350, 300);
}

sub help_b {
  my ($tittle, $help_data) = @_;
  gtksignal_connect(new Gtk2::Button->new_from_stock('gtk-dialog-info'), clicked => sub {

		      my $dialog = new Gtk2::Dialog();
		      $dialog->set_title(N("Help"));
		      $dialog->set_modal(1);
		      gtkpack_($dialog->vbox,
			       1, $help_data,
			       0, gtksignal_connect(Gtk2::Button->new_from_stock('gtk-close'), clicked => sub {
				   $dialog->destroy;
						    }
						   ),
			      );
		      $dialog->show_all;
		    }
		    );
}

sub get_access_list {
  my $net = {};
  network::network::read_net_conf($net);
  my $interface ||= $net->{net_interface};
  my $ip_address = network::tools::get_interface_ip_address($net, $interface);
  my $domain = chomp_(`dnsdomainname`);
  my @o = split(/\./, $ip_address);
  my $ipnet;
  if ($ip_address) {
    $ipnet = $o[0] . "." . $o[1] . "." . $o[2] . ".0";
  } else { $ipnet = "ip_address" }
  my @all = split(", ", qq(*, *.$domain, $ipnet/8, $ipnet/24, $ipnet/32));
  return @all;
}

sub add_modify_entry {
  my ($widget, $treeview, $wanted) = @_;
  my $model = $treeview->get_model;
  my $selection = $treeview->get_selection;
  my $iter;
  my ($i, $dir, $access, $right, $anonuid, $anongid, $options);
  my ($lr, $luserid, $lsecure, $lsync, $lr_data, $lsync_data, $lsecure_data);
  undef $i;
  undef $iter;

  $_ = Gtk2::Entry->new foreach $dir, $anongid, $anonuid, $options;
  $_ = Gtk2::OptionMenu->new foreach $lr, $luserid, $lsecure, $lsync;

  $access = Gtk2::ComboBoxEntry->new_text;
  foreach (get_access_list()) {
    $_ and $access->append_text($_);
  }

  $luserid->set_popdown_strings(@listuserid_data);
  $lr->set_popdown_strings(@yesno);
  $lsync->set_popdown_strings(@yesno);
  $lsecure->set_popdown_strings(@yesno);

  my $file_dialog = $fdwidget->($dir, "");
  my $button = Gtk2::Button->new_from_stock('gtk-open');
  $button->signal_connect(clicked => sub { $file_dialog->show });

# test if modify or add a nfs share
  my $dialog = new Gtk2::Dialog();
  $dialog->set_title("Draknfs entry");
  $dialog->set_position('center');
  $dialog->set_modal(1);
  $dialog->set_resizable(1);

  if ($wanted =~ /modify/) {
    $iter = $selection->get_selected;
    my $path = $model->get_path($iter);
    $i = ($path->get_indices)[0];
    $dir->set_text($listshare[$i]{dir});
    $access->append_text($listshare[$i]{access});
    $access->child->set_text($listshare[$i]{access});
#    $access->set_active(0);
    # list of all rigth in bracket
    #    $anongid, $anonuid, $lr, $luserid, $lsecure, $lsync;
    $right = $listshare[$i]{right};
    my @opts = split(/,/, $right);
    $_->set_text("") foreach $lr, $lsync, $anonuid, $anongid, $luserid, $lsecure;

    foreach my $opt (@opts) {
      if ($opt =~ m/(\bro\b|\brw\b)/) {
	if ($opt =~ /ro/) { $lr->set_text("yes") } else { $lr->set_text("no") }
      } elsif ($opt =~ m/\bsync\b|\basync\b/) {
	if ($opt =~ /sync/) { $lsync->set_text("yes") } else { $lsync->set_text("no") }
      } elsif ($opt =~ m/anongid=(\d+)/) {
	$anongid->set_text($1);
      } elsif ($opt =~ m/anonuid=(\d+)/) {
	$anonuid->set_text($1);
      } elsif ($opt =~ m/(no_root_squash|root_squash|all_squash|no_all_squash)/) {
	if ($opt =~ /no_root_squash/) {
	  $luserid->set_text($userid_data->{no_root_squash});
	} elsif ($opt =~ /root_squash/) {
	  $luserid->set_text($userid_data->{root_squash});
	} elsif ($opt =~ /all_squash/) {
	  $luserid->set_text($userid_data->{all_squash});
	} elsif ($opt =~ /no_all_squash/) {
	  $luserid->set_text($userid_data->{no_all_squash});
	}
      } elsif ($opt =~ m/(\bsecure\b|\binsecure\b)/) {
	if ($opt =~ /insecure/) { $lsecure->set_text("no") } else { $lsecure->set_text("yes") }
      } else { next }
    }
  }

  $luserid->signal_connect(changed => sub {
			     if ($luserid->get_text =~ /$userid_data->{no_root_squash}/) {
			       $anongid->set_sensitive(0);
			       $anonuid->set_sensitive(0);
			     } else {
			       $anongid->set_sensitive(1);
			       $anonuid->set_sensitive(1);
			     }
			   });

  if ($wanted =~ /add/) {
    # default choice root_squash and ro
    $luserid->set_text($userid_data->{no_root_squash});
    $lr->set_text("yes");
    $lsecure->set_text("");
    $lsync->set_text("");
  }

  if ($luserid->get_text =~ /$userid_data->{no_root_squash}/) {
    $anongid->set_sensitive(0);
    $anonuid->set_sensitive(0);
  }

  my $advanced = Gtk2::CheckButton->new("Enable advanced options");
  $advanced->set_active(0);
  foreach ($lsync, $lr, $lsecure) { $_->set_sensitive(0) }
  $advanced->signal_connect(clicked => sub {
      if ($advanced->get_active =~ /1/) {
	  foreach ($lsync, $lr, $lsecure) { $_->set_sensitive(1) }
      } else {
	  foreach ($lsync, $lr, $lsecure) { $_->set_sensitive(0) }
      }
  });

  gtkpack_($dialog->vbox,
	   0, gtkadd(Gtk2::Frame->new(N("NFS directory")),
		     gtkpack_(gtkset_border_width(Gtk2::VBox->new, 5),
			      0, $label_and_widgets->(N("Directory:"), $dir, $button),
			     ),
		     ),
	   0, gtkadd(Gtk2::Frame->new(N("Host access")),
                     gtkpack_(gtkset_border_width(Gtk2::VBox->new, 5),
			      0, $label_and_widgets->(N("Access:"), $access, help_b(N_("Hosts Access"), create_pango_help_box($help_access))),
			     ),
		    ),
	   0, gtkadd(Gtk2::Frame->new(N("User ID Mapping")),
                     gtkpack_(gtkset_border_width(Gtk2::VBox->new, 5),
			      0, $label_and_widgets->(N("User ID:"), $luserid, help_b(N_("Help User ID"), create_pango_help_box($help_userid))),
			      0, $label_and_widgets->(N("anonuid:"), $anonuid, ""),
			      0, $label_and_widgets->(N("anongid:"), $anongid, ""),
			     ),
		    ),
	   0, gtkadd(Gtk2::Frame->new(N("Advanced Options")),
                     gtkpack_(gtkset_border_width(Gtk2::VBox->new, 5),
			      0, $advanced,
			      0, $label_and_widgets->(N("Synchronous access:"), $lsync, help_b(N_("Help Adcanced options"), create_pango_help_box($help_global))),
			      0, $label_and_widgets->(N("Secured Connection:"), $lsecure, ""),
			      0, $label_and_widgets->(N("Read-Only share:"), $lr, ""),
			     ),
		    ),
	   0, gtkadd(Gtk2::Frame->new(N("Custom Options")),
                     gtkpack_(gtkset_border_width(Gtk2::VBox->new, 5),
			      0, $label_and_widgets->(N("options:"), $options, ""),
			     ),
		    ),
	   0, create_okcancel({
			       cancel_clicked => sub { $dialog->destroy },
			       ok_clicked => sub {
				 my ($anonu, $anong);
				 $anonuid->get_text and $anonu = "anonuid=" . $anonuid->get_text;
				 $anongid->get_text and $anong = "anongid=" . $anongid->get_text;
				 if ($lsync->get_text =~ /yes/) { $lsync_data = "sync" } elsif ($lsync->get_text =~ /no/) { $lsync_data = "async" } else { undef $lsync_data }
				 if ($lr->get_text =~ /yes/) { $lr_data = "ro" } elsif ($lr->get_text =~ /no/) { $lr_data = "rw" } else { undef $lr_data }
				 if ($lsecure->get_text =~ /yes/) { $lsecure_data = "secure" } elsif ($lsecure->get_text =~ /no/) { $lsecure_data = "insecure" } else { undef $lsecure_data }
				 # test $luserid->get_text
				 my $luserid_toput;
				 if ($luserid->get_text =~ /root/) {
				   if ($luserid->get_text =~ /no/) {
				     $luserid_toput = "no_root_squash";
				   } else {
				     $luserid_toput = "root_squash";
				   }
				 } else {
				   if ($luserid->get_text =~ /no/) {
				     $luserid_toput = "no_all_squash";
				   } else {
				     $luserid_toput = "all_squash";
  				   }
				 }
				 my $all_right = join(",", grep { defined $_ } $luserid_toput, $anonu, $anong, $lsync_data, $lsecure_data, $lr_data);
				 my $test_dir = $dir->get_text;
				 -d $test_dir or err_dialog(N("Error!"), N("Please enter a directory to share.")) and return;
				 my $test_access = $access->child->get_text;
				 $test_access or err_dialog(N("Error!"), N("You must specify hosts access.")) and return;
				 if ($wanted =~ /add/) {
				   $iter = $model->append;
				   $i = "-1";
				   push @listshare, {
						     dir => $dir->get_text,
						     access => $access->child->get_text,
						     right => $all_right,
						     options => $options->get_text,
						    };
				 }
				 $listshare[$i]{right} = $all_right;
				 $listshare[$i]{access} = $access->child->get_text;
				 $listshare[$i]{dir} = $dir->get_text;
				 $listshare[$i]{options} = $options->get_text;
				 $model->set($iter,
					     COLUMN_DIR, $listshare[$i]{dir},
					     COLUMN_ACCESS, $listshare[$i]{access},
					     COLUMN_RIGHT, $all_right,
					     COLUMN_OPTIONS, $listshare[$i]{options},
					    );
				 $dialog->destroy;
#				 write_conf();
			       },
			      },
			     ),
	  );
  $dialog->show_all;
}

sub remove_entry {
  my ($widget, $treeview) = @_;
  my $model = $treeview->get_model;
  my $selection = $treeview->get_selection;
  my $iter = $selection->get_selected;
    if ($iter) {
      my $path = $model->get_path($iter);
      my $i = ($path->get_indices)[0];
      ask_okcancel("Remove entry ?", "Remove $listshare[$i]{dir}") or return;
      $model->remove($iter);
      splice @listshare, $i, 1;
    }
#  write_conf();
}

sub create_model() {
  get_nfs_data();
  my $model = Gtk2::ListStore->new("Glib::String", "Glib::String",  "Glib::String", "Glib::String");
  foreach my $a (@listshare) {
    my $iter = $model->append;
    $model->set($iter,
		COLUMN_DIR, $a->{dir},
		COLUMN_ACCESS, $a->{access},
		COLUMN_RIGHT, $a->{right},
		COLUMN_OPTIONS, $a->{options},
		);
	     }
  return $model;
}

# add colum to model
sub add_columns {
  my $treeview = shift;
  my $model = $treeview->get_model;
#  my @colsize = (120, 160, 120);
#  each_index {
#    my $renderer = Gtk2::TreeViewColumn->new_with_attributes($_, Gtk2::CellRendererText->new, 'text' => $::i);
#    $renderer->set_sort_column_id($::i);
#    $renderer->set_min_width($colsize[$::i]);
#    $treeview->append_column($renderer);
#  } N("Share Directory"), N("Hosts Wildcard"), N("General Options"), N("Custom Options");

  each_index {
    my $renderer = Gtk2::CellRendererText->new;
    $renderer->set(editable => 0);
    $renderer->signal_connect(edited => \&cell_edited, $model);
    $renderer->set_data(column => $::i);
    $treeview->insert_column_with_attributes(-1, $_, $renderer, 'text' => $::i);
  } N("Share Directory"), N("Hosts Wildcard"), N("General Options"), N("Custom Options");
}

sub cell_edited {
  my ($cell, $path_string, $new_text, $model) = @_;
  my $path = Gtk2::TreePath->new_from_string($path_string);
  my $column = $cell->get_data("column");
  my $iter = $model->get_iter($path);

  if ($column == COLUMN_DIR) {
    my $i = ($path->get_indices)[0];
    $listshare[$i]{dir} = $new_text;
    -d $new_text or err_dialog(N("Error!"), N("Please enter a directory to share.")) and return;
    $model->set($iter, $column, $listshare[$i]{dir});
  } elsif ($column == COLUMN_ACCESS) {
    my $i = ($path->get_indices)[0];
    $listshare[$i]{access} = $new_text;
    $model->set($iter, $column, $listshare[$i]{access});
  } elsif ($column == COLUMN_RIGHT) {
    err_dialog(N("Error!"), N("Please use the modify button to set right access.")) and return;
  } elsif ($column == COLUMN_OPTIONS) {
    my $i = ($path->get_indices)[0];
    $listshare[$i]{options} = $new_text;
    $model->set($iter, $column, $listshare[$i]{options});
  }
  write_conf();
}

###############
# Main Program
###############
# create model
my $model = create_model();

my $window = ugtk2->new("Draknfs $version");
$window->{rwindow}->set_size_request(550, 400) unless $::isEmbedded;
$window->{rwindow}->set_position('center') if !$::isEmbedded;
my $W = $window->{window};
$W->signal_connect(delete_event => sub { ugtk2->exit });

my $treeview = Gtk2::TreeView->new_with_model($model);
$treeview->set_rules_hint(TRUE);
$treeview->get_selection->set_mode('single');
add_columns($treeview);

# double clic and popup modify window
$treeview->signal_connect(button_press_event => sub {
			    my (undef, $event) = @_;
			    my $model = $treeview->get_model;
			    my $selection = $treeview->get_selection;
			    my $iter = $selection->get_selected;
			    if ($iter) {
			      my $path = $model->get_path($iter);
			      my $i = ($path->get_indices)[0];
			      add_modify_entry($model, $treeview, "modify") if $event->type eq '2button-press';
			    }
			  });

# create menu
my @items = get_items();
my $factory = Gtk2::ItemFactory->new('Gtk2::MenuBar', '<main>', undef);
$factory->create_items('menu', @items);
my $menu = $factory->get_widget('<main>');

my $okcancel = create_okcancel({
				cancel_clicked => sub { ugtk2->exit },
				ok_clicked => \&write_conf,
			       },
			      );

# main interface
$W->add(gtkpack_(Gtk2::VBox->new(0,0),
		 if_(!$::isEmbedded, 0, Gtk2::Banner->new('drakgw', N("DrakNFS add/remove/alter NFS shares"))),
		 0, $menu,
		 if_($::isEmbedded, 0, Gtk2::Label->new("Here you can add, remove and alter NFS shares.")),
		 1, gtkpack_(gtkset_border_width(Gtk2::HBox->new, 0),
			     1, create_scrolled_window($treeview),
			     0, gtkpack_(create_vbox('start'),
					 0, gtksignal_connect(Gtk2::Button->new(N("Add")), clicked => sub {
								eval { add_modify_entry($model, $treeview, "add") };
								my $err = $@;
								if ($err) {
								  err_dialog(N("Error"), N("Failed to add NFS share.") . "\n\n" . $err);
								}
							      }),
					 0, gtksignal_connect(Gtk2::Button->new(N("Modify")), clicked => sub {
								eval { add_modify_entry($model, $treeview, "modify") };
								my $err = $@;
								if ($err) {
								  err_dialog(N("Error"), N("Failed to Modify NFS share.") . "\n\n" . $err);
								}
							      }),
					 
					 0, gtksignal_connect(Gtk2::Button->new(N("Remove")), clicked => sub {
								eval { remove_entry($model, $treeview) };
								my $err = $@;
								if ($err) {
								  err_dialog(N("Error"), N("Failed to remove an NFS share.") . "\n\n" . $err);
								}
							      }),
					),
			    ),
		 0, $okcancel,
		 ),
	);

$W->show_all;
Gtk2->main;
