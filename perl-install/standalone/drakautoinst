#!/usr/bin/perl

#
# Guillaume Cottenceau (gc@mandrakesoft.com)
#
# Copyright 2001 MandrakeSoft
#
# This software may be freely redistributed under the terms of the GNU
# public license.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

use lib qw(/usr/lib/libDrakX);

use standalone;     #- warning, standalone must be loaded very first, for 'explanations'

use common;
use interactive;
use devices;
use detect_devices;
use steps;
use commands;
use fs;
use Data::Dumper;

$::isEmbedded = ($::XID, $::CCPID) = "@ARGV" =~ /--embedded (\w+) (\w+)/;


local $_ = join '', @ARGV;

/-h/ and die "usage: drakautoinst [--version]\n";
/-version/ and die 'version: $Id$ '."\n";
$::direct = /-direct/;
$::direct = 1; #DEBUG

my $in = 'interactive'->vnew('su', 'default');

begin:
$::isEmbedded and kill USR2, $::CCPID;

my $imagefile = "/root/drakx/replay_install.img";
-f $imagefile or $in->ask_okcancel(_("Error!"), 
				   _("I can't find needed image file `%s'.", $imagefile), 1), quit_global($in, 0);

$::direct or $in->ask_okcancel(_("Auto Install Configurator"),
_("You are about to configure an Auto Install floppy. This feature is somewhat dangerous and must be used circumspectly.

With that feature, you will be able to replay the installation you've performed on this computer, being interactively prompted for some steps, in order to change their values.

For maximum safety, the partitioning and formatting will never be performed automatically, whatever you chose during the install of this computer.

Do you want to continue?"), 1) or quit_global($in, 0);


my @manual_steps = qw(doPartitionDisks formatPartitions);
my @all_steps;
my @choices;

my $st = \%steps::installSteps;

for (my $f = $st->{first}; $f; $f = $st->{$f}{next}) {
    next if member($f, @manual_steps);
    my $def_choice = 'replay';
    push @choices, { label => _($st->{$f}{text}), val => \$def_choice, list => [ _('replay'), _('manual') ] };
    push @all_steps, [ $f, \$def_choice ];
}

$in->ask_from(_("Automatic Steps Configuration"),
	      _("Please choose for each step whether it will replay like your install, or it will be manual"),
	      \@choices
	     ) or quit_global($in, 0);

${$_->[1]} eq _('manual') and push @manual_steps, $_->[0] foreach @all_steps;

my $mountdir = "/root/tmp/drakautoinst-mountdir"; -d $mountdir or mkdir $mountdir, 0755;
my $floppy = detect_devices::floppy();
my $dev = devices::make($floppy);
$in->ask_okcancel('', _("Insert a blank floppy in drive %s", $floppy), 1) or quit_global($in, 0);
{
    my $w = $in->wait_message('', _("Creating auto install floppy"));
    commands::dd("if=$imagefile", "of=$dev", "bs=1440", "count=1024");
    common::sync();
}
fs::mount($dev, $mountdir, 'vfat', 0);
my $cfgfile = "$mountdir/auto_inst.cfg";
eval(cat_($cfgfile));
my $o_old = $o;

if (!$::isEmbedded && $in->isa('interactive_gtk')) {
    require Gtk;
    init Gtk;
    require my_gtk;
    import my_gtk qw(:helpers :wrappers);

    my %tree;
    $struct_gui{$_} = 'General' foreach qw(lang isUpgrade autoExitInstall timezone default_packages mkbootdisk);
    $struct_gui{$_} = 'Security' foreach qw(crypto security);
    $struct_gui{$_} = 'Harddrive' foreach qw(partitions manualFstab useSupermount partitioning);
    $struct_gui{$_} = 'Network' foreach qw(intf netc netcnx);
    $struct_gui{$_} = 'Users' foreach qw(superuser users authentication);
    $struct_gui{$_} = 'Hardware' foreach qw(keyboard mouse X printer wacom nomouseprobe);

    %pixmap = ( lang => 'language',
		isUpgrade => '',
		security => 'security',
		autoExitInstall => '',
		timezone => '',
		default_packages => '',
		partitions => 'harddrive',
		manualFstab => 'partition',
		useSupermount => '',
		partitioning => 'partition',
		intf => 'network',
		netc => 'network',
		netcnx => 'network',
		superuser => 'user',
		users => 'user',
		authentication => '',
		keyboard => 'keyboard',
		mouse => 'mouse',
		X => 'X',
		printer => 'printer',
		wacom => '',
	      );

    member($_, keys %struct_gui) and push @{$tree{$struct_gui{$_}}}, [$_ , $pixmap{$_}, h2widget($o->{$_}, "\$o->\{$_\}") ] foreach (keys %$o);

    my $W = my_gtk->new(_('$o edition'));
    my @box_to_hide;
    my $nb_pages=0;
    my $notebook = new Gtk::Notebook;
    $notebook->set_show_border(0);
    $notebook->set_show_tabs(0);
    $notebook->append_page(gtkpack_(gtkset_border_width(new Gtk::VBox(0,0), 10),
				    1, new Gtk::VBox(0,0),
				    0, gtkpack_(new Gtk::HBox(0,0),
						1, new Gtk::VBox(0,0),
						0, gtkadd(gtkset_shadow_type(new Gtk::Frame, 'etched-in'),
							  new Gtk::Pixmap(gtkcreate_png('mdk_logo'))),
						1, new Gtk::VBox(0,0),
					       ),
				    0, _("\nWelcome.\n\nThe parameters of the auto-install are available in the sections on the left"),
				    1, new Gtk::VBox(0,0),
				   ), undef);
    $notebook->show_all;
    $notebook->set_page(0);

    gtkadd($W->{window},
	   gtkpack_(new Gtk::VBox(0,5),
	   1, gtkpack_(new Gtk::HBox(0,0),
		    0, gtkadd(gtkset_usize(gtkset_shadow_type(new Gtk::Frame, 'in'), 130, 470),
			    gtkpack_(new Gtk::VBox(0,0),
				     map {
					 my $box = new Gtk::VBox(0,0);
					 push @box_to_hide, $box;
					 $box->{vis} = 0;
					 my @button_to_hide;
					 0, gtksignal_connect(new Gtk::Button($_), clicked => sub {
								if($box->{vis}) { $box->hide(); $box->{vis} = 0; $notebook->set_page(0); }
								else {
								    $_->hide, $_->{vis}=0 foreach @box_to_hide;
								    $box->show; $box->{vis} = 1;
								    $box->{active_function} and $box->{active_function}->();
								}
							    }), 1, gtkpack__($box,
							  map {
							      my $button = gtkset_relief(new Gtk::ToggleButton(), 'none');
							      push @button_to_hide, $button;
							      my $gru = $_->[0];
							      $notebook->append_page(gtkshow($_->[2]), undef);
							      $nb_pages++;
							      my $local_page = $nb_pages;
							      my $function = sub { $notebook->set_page($local_page) };
							      gtksignal_connect($button, toggled => sub {
										    $button->get_active() and $function->()
										});
							      my $b;
							      if ($_->[1] ne "") { $b = new Gtk::Pixmap(gtkcreate_png($_->[1]))} else { $b = ()};
							      gtksignal_connect(gtkadd($button,
										       gtkpack__(new Gtk::VBox(0,3),
												 $b,
												 _($_->[0]),
												)
										      ), released => sub {
											  $button->get_active() or $button->set_active(1),return;
											  $_->set_active(0) foreach @button_to_hide;
											  $button->set_active(1);
											  $box->{active_function} = $function;
											  $function->();
										      })
									    } @{$tree{$_}}
									   )
							} keys(%tree)
				    )
			   ),
		    1, $notebook,
		   ),
	    0, new Gtk::HSeparator,
	    0, gtkadd(gtkset_border_width(gtkset_layout(new Gtk::HButtonBox, 'end'), 5),
		      gtksignal_connect(new Gtk::Button(_("Accept")), clicked => sub { Gtk->main_quit;  }),
		      gtksignal_connect(new Gtk::Button(_("Cancel")), clicked => sub { $o = $o_old; Gtk->main_quit; quit_global($in, 0) }),
		     )
	   )
	  );
    $_->hide foreach @box_to_hide;
#    $W->{window}->show_all;
#      gtkadd($W->{window},
#  	   gtkpack_($W->create_box_with_title(_("Edit variables")),
#  		    1, my $notebook = create_notebook( map { $_, h2widget($o->{$_}, "\$o->\{$_\}") } keys %$o ),
#  		    0, gtkpack(gtkset_border_width(new Gtk::HBox(0,0),5), $W->create_okcancel),
#  		   ),
#  	  );
#    $notebook->set_tab_pos('left');
#    $::isEmbedded and Gtk->main_iteration while Gtk->events_pending;
    $::isEmbedded and kill (12, $::CCPID);
    $W->main;
#    $W->destroy();
}

my $str = join('',
"#!/usr/bin/perl -cw
#
# Special file generated by ``drakautoinst''.
#
# You should check the syntax of this file before using it in an auto-install.
# You can do this with 'perl -cw auto_inst.cfg.pl' or by executing this file
# (note the '#!/usr/bin/perl -cw' on the first line).
",
	       Data::Dumper->Dump([$o], ['$o']), q(
package install_steps_auto_install;
$graphical = 1;
), Data::Dumper->Dump([\@manual_steps], ['$msteps']),
q(push @graphical_steps, @$msteps;
), "\0");
$str =~ s/ {8}/\t/g; #- replace all 8 space char by only one tabulation, this reduces file size so much :-)
output($cfgfile, $str);

fs::umount($mountdir);

$in->ask_okcancel(_("Congratulations!"), 
_("The floppy has been successfully generated.
You may now replay your installation."));

quit_global($in, 0);


sub quit_global {
    my ($in, $exitcode) = @_;
    $::isEmbedded ? kill USR1, $::CCPID : $in->exit($exitcode);
    goto begin;
}



sub h2widget {
    my ($k, $label) = @_;
    my $w;
    if(ref($k) =~ /HASH/) {
	my $vb;
	my @widget_list;
	my $i = -1;
	my @list_keys = keys(%{$k});
	if (ref(${$k}{$list_keys[0]}) =~ /HASH/) {
	    $i++;
	    my ($button_add, $button_remove);
	    $w = gtkpack_(new Gtk::VBox(0,0),
			  1, createScrolledWindow(gtkpack__($vb = new Gtk::VBox(0,10),
							    $widget_list[$i] = create_packtable({ col_spacings => 10, row_spacings => 3 },
					map {
					    my $e;
					    $e = h2widget(${$k}{$_}, "$label\{$_\}");
					    [ "$_ : ", $e ] } @list_keys
									    ),
						       )
					     ),
			  control_buttons(${$k}{$list_keys[0]},
					  sub { my ($vb, $widget_list2, $ref_local_k, $i) = @_;
						my @widget_list = @{$widget_list2};
			my $field = $in->ask_from_entry(_("Auto Install"), ("Enter the name of the new field you want to add")) or return undef;
						$field eq '' and return undef;
						gtkpack__($vb,
							  $widget_list[$i] = create_packtable({ col_spacings => 10, row_spacings => 3 },
										      [ "$field : ", h2widget($ref_local_k, "$label\{$field\}")])
							 );
						@{$widget_list2} = @widget_list;
					    },
					  $vb, \$i, \@widget_list)
			 );
	} else {
	    $w = create_packtable({ col_spacings => 10, row_spacings => 3 },
				  map { create_entry_element(${$k}{$_}, "$label\{$_\}", $_) } @list_keys
				 )
	}
    } elsif(ref($k) =~ /ARRAY/) {
	my $vb;
	my @widget_list;
	my $i = -1;
	$w = gtkpack_(new Gtk::VBox(0,0),
		      1, createScrolledWindow(
					      gtkpack__($vb = new Gtk::VBox(0,5),
							map { $i++; $widget_list[$i] = h2widget($_, "$label\[$i\]") } @{$k},
						       )
					     ),
		      control_buttons(@{$k}[0],
				      sub { my ($vb, $widget_list2, $ref_local_k, $i) = @_;
					    my @widget_list = @{$widget_list2};
					    gtkpack__($vb, $widget_list[$i] = h2widget($ref_local_k, "$label\[$i\]"));
					    @{$widget_list2} = @widget_list;
					},
				      $vb, \$i, \@widget_list)
		     );
    } else {
	$label =~ /\$o->\{(.+)\}/;
	$w = create_packtable({ col_spacings => 10, row_spacings => 3 },
			      create_entry_element($k, $label, $1))
    }
    return $w;
}


sub create_entry_element {
    my ($text, $value, $label) = @_;
    my $e;
    if(ref ($text) =~ /HASH/) {
	return ([ "$label : ", h2widget($text, $label) ]);
    } elsif (ref ($text) =~ /ARRAY/) {
	return ([ "$label : ", h2widget($text, $label) ]);
    } else {
	$e = new Gtk::Entry;
	$e->{value} = $value;
	my $tag = Gtk->timeout_add(1000, sub { $e->set_text($text); 0 });
	gtksignal_connect($e, changed => sub {
			      my $exe = $e->{value} . "='" . $e->get_text() . "'";
			      print "EXEC : $exe\n ";
			      eval "$exe";
			  });
    }
    [ $label ? "$label : " : "" , $e ]
}

sub control_buttons {
    my ($ref_local_k, $local_gui, $vb, $j, $widget_list2) = @_;
    my @widget_list = @{$widget_list2};
    my $i = ${$j};
    ref($ref_local_k) =~ /HASH/ or return();
    my (%local_k) = %{$ref_local_k};
    my ($button_add, $button_remove);
    0, gtkadd(gtkset_border_width(gtkset_layout(new Gtk::HButtonBox, 'spread'), 5),
	      gtksignal_connect($button_add = new Gtk::Button(_("Add an item")), clicked => sub {
				    $local_k{$_} = undef foreach keys %local_k;
				    $i++;
				    $local_gui->($vb, \@widget_list, \%local_k, $i) or $i--, return;
				    $i>=0 and $button_remove->set_sensitive(1);
				}
			       ),
	      gtksignal_connect($button_remove = new Gtk::Button(_("Remove the last item")), clicked => sub {
				    $i>=0 or return;
				    $widget_list[$i]->destroy();
				    $i--;
				    $i>=0 or $button_remove->set_sensitive(0);
				}
			       )
	     )
}

#-------------------------------------------------
#- $Log$
#- Revision 1.18  2002/03/06 20:17:51  damien
#- corrected HASH and ARRAY label
#-
#- Revision 1.17  2002/01/29 22:38:31  gc
#- move /root/* files (ddebug.log, install.log, report.bug,
#- auto_inst.cfg.pl, replay_install.img) to /root/drakx/,
#- and also save stage1.log there
#-
#- Revision 1.16  2002/01/18 20:22:20  gc
#- - write the 'common' part of the 'explanations' stuff,
#-   with nice help from Pixel for the tough Perl part
#- - move 'use standalone' up in all standalone apps,
#-   to comply to 'explanations'
#-
#- Revision 1.15  2002/01/08 10:21:15  fpons
#- removed stupid invocation of _("$_"), is it correct code to change it to $_ only ?
#-
#- Revision 1.14  2001/11/05 16:07:21  damien
#- typo
#-
#- Revision 1.13  2001/10/30 20:11:31  damien
#- corrected ref($in) =~ /gtk/
#-
#- Revision 1.12  2001/10/30 17:00:05  damien
#- updated
#-
#- Revision 1.11  2001/10/26 13:45:11  damien
#- progress bar hack
#-
#- Revision 1.10  2001/10/25 11:59:58  damien
#- simple variables handled, code compression.
#-
#- Revision 1.9  2001/10/25 11:17:03  damien
#- The new and shiny drakautoinst is coming. P|-|34R
#-
#- Revision 1.8  2001/10/25 02:18:24  damien
#- The new drakautoinst is coming. P|-|34R
#-
#- Revision 1.7  2001/09/18 17:35:50  gc
#- have "manual" and "replay" translated
#-
#- Revision 1.6  2001/09/14 17:30:23  siegel
#- Check exisence of "/root/replay_install.img" before anything else ...
#-
#- Revision 1.5  2001/08/29 21:58:24  gc
#- quit_global
#-
#- Revision 1.4  2001/08/26 14:34:10  gc
#- require -> use
#-
#- Revision 1.3  2001/08/18 17:52:21  prigaux
#- big renaming of ask_from_entries_refH in ask_from and ask_from_entries_refH_powered in ask_from_
#-
#- Revision 1.2  2001/08/13 19:08:27  gc
#- ouch! use lib from /usr/lib/libDrakX, rather than from ..
#-
#- Revision 1.1  2001/08/13 19:06:50  gc
#- initial revision for drakautoinst
#- - put %installSteps in a separate package (steps.pm) (for drakxtools)
#- - use additional fields {auto} and {noauto}, by step, to ease interactive auto install and oem stuff
#- - in install2.pm, perform each step either from the interactive class or from install_steps, according to the {auto} flag
#- - id, tell each step to not try to be automatic if {noauto}
#- - in the install, have auto install bootdisk created in install_any so we can always write a bootdisk (from install_steps) for further use from drakautoinst in standalone
#- - interactive version of install_steps_auto_install is now inheriting from the interactive class, so we can click on a previous automatic step and have it interactively during an interactive auto install
#-
#-
