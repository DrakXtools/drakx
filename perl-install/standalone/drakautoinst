#!/usr/bin/perl

#
# Guillaume Cottenceau (gc@mandrakesoft.com)
#
# Copyright 2001-2002 MandrakeSoft
#
# This software may be freely redistributed under the terms of the GNU
# public license.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

use lib qw(/usr/lib/libDrakX);

use standalone;     #- warning, standalone must be loaded very first, for 'explanations'

use common;
use interactive;
use devices;
use detect_devices;
use steps;
use commands;
use fs;
use Data::Dumper;


local $_ = join '', @ARGV;

$::direct = /-direct/;

my $in = 'interactive'->vnew('su', 'default');

begin:
$::isEmbedded and kill 'USR2', $::CCPID;

my $imagefile = "/root/drakx/replay_install.img";
-f $imagefile or $in->ask_warn(N("Error!"), 
			       N("I can't find needed image file `%s'.", $imagefile), 1), quit_global($in, 0);

$::direct or $in->ask_okcancel(N("Auto Install Configurator"),
N("You are about to configure an Auto Install floppy. This feature is somewhat dangerous and must be used circumspectly.

With that feature, you will be able to replay the installation you've performed on this computer, being interactively prompted for some steps, in order to change their values.

For maximum safety, the partitioning and formatting will never be performed automatically, whatever you chose during the install of this computer.

Do you want to continue?"), 1) or quit_global($in, 0);


my @manual_steps = qw(doPartitionDisks formatPartitions);
my @all_steps;
my @choices;

my $st = \%steps::installSteps;

for (my $f = $st->{first}; $f; $f = $st->{$f}{next}) {
    next if member($f, @manual_steps);
    my $def_choice = 'replay';
    push @choices, { label => translate($st->{$f}{text}), val => \$def_choice, list => [ N("replay"), N("manual") ] };
    push @all_steps, [ $f, \$def_choice ];
}

$in->ask_from(N("Automatic Steps Configuration"),
	      N("Please choose for each step whether it will replay like your install, or it will be manual"),
	      \@choices
	     ) or quit_global($in, 0);

${$_->[1]} eq N("manual") and push @manual_steps, $_->[0] foreach @all_steps;

my $mountdir = "/root/tmp/drakautoinst-mountdir"; -d $mountdir or mkdir $mountdir, 0755;
my $floppy = detect_devices::floppy();
my $dev = devices::make($floppy);
$in->ask_okcancel('', N("Insert a blank floppy in drive %s", $floppy), 1) or quit_global($in, 0);
{
    log::explanations(N("Creating auto install floppy"));
    my $w = $in->wait_message('', N("Creating auto install floppy"));
    commands::dd("if=$imagefile", "of=$dev", "bs=1440", "count=1024");
    common::sync();
}
fs::mount($dev, $mountdir, 'vfat', 0);
my $cfgfile = "$mountdir/auto_inst.cfg";
eval(cat_($cfgfile));
my $o_old = $o;

if (!$::isEmbedded && $in->isa('interactive::gtk')) {
    require ugtk2;
    ugtk2->import(qw(:helpers :wrappers));

    my %tree;
    $struct_gui{$_} = 'General' foreach qw(lang isUpgrade autoExitInstall timezone default_packages mkbootdisk);
    $struct_gui{$_} = 'Security' foreach qw(crypto security);
    $struct_gui{$_} = 'Harddrive' foreach qw(partitions manualFstab useSupermount partitioning);
    $struct_gui{$_} = 'Network' foreach qw(intf netc netcnx);
    $struct_gui{$_} = 'Users' foreach qw(superuser users authentication);
    $struct_gui{$_} = 'Hardware' foreach qw(keyboard mouse X printer wacom nomouseprobe);

    %pixmap = ( lang => 'language',
		isUpgrade => '',
		security => 'security',
		autoExitInstall => '',
		timezone => '',
		default_packages => '',
		partitions => 'harddrive',
		manualFstab => 'partition',
		useSupermount => '',
		partitioning => 'partition',
		intf => 'network',
		netc => 'network',
		netcnx => 'network',
		superuser => 'user',
		users => 'user',
		authentication => '',
		keyboard => 'keyboard',
		mouse => 'mouse',
		X => 'X',
		printer => 'printer',
		wacom => '',
	      );

    member($_, keys %struct_gui) and push @{$tree{$struct_gui{$_}}}, [$_ , $pixmap{$_}, h2widget($o->{$_}, "\$o->\{$_\}") ] foreach (keys %$o);

    my $W = ugtk2->new('$o edition');
    my @box_to_hide;
    my $nb_pages=0;
    my $notebook = new Gtk2::Notebook;
    $notebook->set_show_border(0);
    $notebook->set_show_tabs(0);
    $notebook->append_page(gtkpack_(gtkset_border_width(new Gtk2::VBox(0,0), 10),
				    1, new Gtk2::VBox(0,0),
				    0, gtkpack_(new Gtk2::HBox(0,0),
						1, new Gtk2::VBox(0,0),
						0, gtkadd(gtkset_shadow_type(new Gtk2::Frame, 'etched-in'),
							  gtkcreate_img('mdk_logo')),
						1, new Gtk2::VBox(0,0),
					       ),
				    0, N("\nWelcome.\n\nThe parameters of the auto-install are available in the sections on the left"),
				    1, new Gtk2::VBox(0,0),
				   ), undef);
    $notebook->show_all;
    $notebook->set_page(0);

    gtkadd($W->{window},
	   gtkpack_(new Gtk2::VBox(0,5),
	   1, gtkpack_(new Gtk2::HBox(0,0),
		    0, gtkadd(gtkset_size_request(gtkset_shadow_type(new Gtk2::Frame, 'in'), 130, 470),
			    gtkpack_(new Gtk2::VBox(0,0),
				     map {
					 my $box = new Gtk2::VBox(0,0);
					 push @box_to_hide, $box;
					 $box->{vis} = 0;
					 my @button_to_hide;
					 0, gtksignal_connect(new Gtk2::Button($_), clicked => sub {
								if($box->{vis}) { $box->hide(); $box->{vis} = 0; $notebook->set_page(0); }
								else {
								    $_->hide, $_->{vis}=0 foreach @box_to_hide;
								    $box->show; $box->{vis} = 1;
								    $box->{active_function} and $box->{active_function}->();
								}
							    }), 1, gtkpack__($box,
							  map {
							      my $button = gtkset_relief(new Gtk2::ToggleButton(), 'none');
							      push @button_to_hide, $button;
							      my $gru = $_->[0];
							      $notebook->append_page(gtkshow($_->[2]), undef);
							      $nb_pages++;
							      my $local_page = $nb_pages;
							      my $function = sub { $notebook->set_page($local_page) };
							      gtksignal_connect($button, toggled => sub {
										    $button->get_active() and $function->()
										});
							      my $b;
							      if ($_->[1] ne "") { $b = gtkcreate_img($_->[1])} else { $b = ()};
							      gtksignal_connect(gtkadd($button,
										       gtkpack__(new Gtk2::VBox(0,3),
												 $b,
												 translate($_->[0]),
												)
										      ), released => sub {
											  $button->get_active() or $button->set_active(1),return;
											  $_->set_active(0) foreach @button_to_hide;
											  $button->set_active(1);
											  $box->{active_function} = $function;
											  $function->();
										      })
									    } @{$tree{$_}}
									   )
							} keys(%tree)
				    )
			   ),
		    1, $notebook,
		   ),
	    0, new Gtk2::HSeparator,
	    0, gtkadd(gtkset_border_width(gtkset_layout(new Gtk2::HButtonBox, 'end'), 5),
		      gtksignal_connect(new Gtk2::Button(N("Accept")), clicked => sub { Gtk2->main_quit;  }),
		      gtksignal_connect(new Gtk2::Button(N("Cancel")), clicked => sub { $o = $o_old; Gtk2->main_quit; quit_global($in, 0) }),
		     )
	   )
	  );
    $_->hide foreach @box_to_hide;
#    $W->{window}->show_all;
#      gtkadd($W->{window},
#  	   gtkpack_($W->create_box_with_title(N("Edit variables")),
#  		    1, my $notebook = create_notebook( map { $_, h2widget($o->{$_}, "\$o->\{$_\}") } keys %$o ),
#  		    0, gtkpack(gtkset_border_width(new Gtk2::HBox(0,0),5), $W->create_okcancel),
#  		   ),
#  	  );
#    $notebook->set_tab_pos('left');
#    $::isEmbedded and gtkflush();
    $::isEmbedded and kill ('USR2', $::CCPID);
    $W->main;
#    $W->destroy();
}

$o->{interactiveSteps} = \@manual_steps;

my $str = join('',
"#!/usr/bin/perl -cw
#
# Special file generated by ``drakautoinst''.
#
# You should check the syntax of this file before using it in an auto-install.
# You can do this with 'perl -cw auto_inst.cfg.pl' or by executing this file
# (note the '#!/usr/bin/perl -cw' on the first line).
",
	       Data::Dumper->Dump([$o], ['$o']), "\0");
$str =~ s/ {8}/\t/g; #- replace all 8 space char by only one tabulation, this reduces file size so much :-)
output($cfgfile, $str);

fs::umount($mountdir);

$in->ask_okcancel(N("Congratulations!"), 
N("The floppy has been successfully generated.
You may now replay your installation."));

quit_global($in, 0);


sub quit_global {
    my ($in, $exitcode) = @_;
    $::isEmbedded ? kill 'USR1', $::CCPID : $in->exit($exitcode);
    goto begin;
}



sub h2widget {
    my ($k, $label) = @_;
    my $w;
    if(ref($k) =~ /HASH/) {
	my $vb;
	my @widget_list;
	my $i = -1;
	my @list_keys = keys(%{$k});
	if (ref(${$k}{$list_keys[0]}) =~ /HASH/) {
	    $i++;
	    my ($button_add, $button_remove);
	    $w = gtkpack_(new Gtk2::VBox(0,0),
			  1, create_scrolled_window(gtkpack__($vb = new Gtk2::VBox(0,10),
							    $widget_list[$i] = create_packtable({ col_spacings => 10, row_spacings => 3 },
					map {
					    my $e;
					    $e = h2widget(${$k}{$_}, "$label\{$_\}");
					    [ "$_ : ", $e ] } @list_keys
									    ),
						       )
					     ),
			  control_buttons(${$k}{$list_keys[0]},
					  sub { my ($vb, $widget_list2, $ref_local_k, $i) = @_;
						my @widget_list = @{$widget_list2};
			my $field = $in->ask_from_entry(N("Auto Install"), ("Enter the name of the new field you want to add")) or return undef;
						$field eq '' and return undef;
						gtkpack__($vb,
							  $widget_list[$i] = create_packtable({ col_spacings => 10, row_spacings => 3 },
										      [ "$field : ", h2widget($ref_local_k, "$label\{$field\}")])
							 );
						@{$widget_list2} = @widget_list;
					    },
					  $vb, \$i, \@widget_list)
			 );
	} else {
	    $w = create_packtable({ col_spacings => 10, row_spacings => 3 },
				  map { create_entry_element(${$k}{$_}, "$label\{$_\}", $_) } @list_keys
				 )
	}
    } elsif(ref($k) =~ /ARRAY/) {
	my $vb;
	my @widget_list;
	my $i = -1;
	$w = gtkpack_(new Gtk2::VBox(0,0),
		      1, create_scrolled_window(
					      gtkpack__($vb = new Gtk2::VBox(0,5),
							map { $i++; $widget_list[$i] = h2widget($_, "$label\[$i\]") } @{$k},
						       )
					     ),
		      control_buttons(@{$k}[0],
				      sub { my ($vb, $widget_list2, $ref_local_k, $i) = @_;
					    my @widget_list = @{$widget_list2};
					    gtkpack__($vb, $widget_list[$i] = h2widget($ref_local_k, "$label\[$i\]"));
					    @{$widget_list2} = @widget_list;
					},
				      $vb, \$i, \@widget_list)
		     );
    } else {
	$label =~ /\$o->\{(.+)\}/;
	$w = create_packtable({ col_spacings => 10, row_spacings => 3 },
			      create_entry_element($k, $label, $1))
    }
    return $w;
}


sub create_entry_element {
    my ($text, $value, $label) = @_;
    my $e;
    if(ref $text =~ /HASH/) {
	return ([ "$label : ", h2widget($text, $label) ]);
    } elsif (ref $text =~ /ARRAY/) {
	return ([ "$label : ", h2widget($text, $label) ]);
    } else {
	$e = new Gtk2::Entry;
	$e->{value} = $value;
	my $tag = Gtk2->timeout_add(1000, sub { $e->set_text($text); 0 });
	gtksignal_connect($e, changed => sub {
			      my $exe = $e->{value} . "='" . $e->get_text() . "'";
			      print "EXEC : $exe\n ";
			      eval "$exe";
			  });
    }
    [ $label ? "$label : " : "" , $e ]
}

sub control_buttons {
    my ($ref_local_k, $local_gui, $vb, $j, $widget_list2) = @_;
    my @widget_list = @{$widget_list2};
    my $i = ${$j};
    ref($ref_local_k) =~ /HASH/ or return();
    my (%local_k) = %{$ref_local_k};
    my ($button_add, $button_remove);
    0, gtkadd(gtkset_border_width(gtkset_layout(new Gtk2::HButtonBox, 'spread'), 5),
	      gtksignal_connect($button_add = new Gtk2::Button(N("Add an item")), clicked => sub {
				    $local_k{$_} = undef foreach keys %local_k;
				    $i++;
				    $local_gui->($vb, \@widget_list, \%local_k, $i) or $i--, return;
				    $i>=0 and $button_remove->set_sensitive(1);
				}
			       ),
	      gtksignal_connect($button_remove = new Gtk2::Button(N("Remove the last item")), clicked => sub {
				    $i>=0 or return;
				    $widget_list[$i]->destroy();
				    $i--;
				    $i>=0 or $button_remove->set_sensitive(0);
				}
			       )
	     )
}
