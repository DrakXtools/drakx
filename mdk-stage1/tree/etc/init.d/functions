# -*-Shell-script-*-
#
# functions	This file contains functions to be used by most or all
#		shell scripts in the /etc/init.d directory.
#

TMP=/tmp
TMPDIR=/tmp
export TMP TMPDIR

DATE="`date +%Y%m%d-%Hh%M`"

# Make sure umask is sane
umask 022

# Set up a default search path.
PATH="/sbin:/usr/sbin:/bin:/usr/bin"
export PATH

# Get a sane screen width, and default to 80 when exact info not available
[ -z "${COLUMNS:-}" ] && COLUMNS=`stty -a 2>/dev/null | sed -n 's/.*columns \([0-9]*\);.*/\1/p'`
[ -z "${COLUMNS:-}" ] && COLUMNS=80

# color => new RH6.0 bootup
# verbose => old-style bootup
# anything else => new style bootup without ANSI colors or positioning
BOOTUP=color
# column to start "[  OK  ]" label in 
RES_COL=$((COLUMNS - 15))
# terminal sequence to move to that column. You could change this
# to something like "tput hpa ${RES_COL}" if your terminal supports it
MOVE_TO_COL="echo -en \\033[${RES_COL}G"
# terminal sequence to set color to a 'success' color (currently: green)
SETCOLOR_SUCCESS="echo -en \\033[1;32m"
# terminal sequence to set color to a 'failure' color (currently: red)
SETCOLOR_FAILURE="echo -en \\033[1;31m"
# terminal sequence to set color to a 'warning' color (currently: yellow)
SETCOLOR_WARNING="echo -en \\033[1;33m"
# terminal sequence to reset to the default color.
SETCOLOR_NORMAL="echo -en \\033[0;39m"
# default kernel loglevel on boot (syslog will reset this)
LOGLEVEL=3

if [ "$CONSOLETYPE" = "serial" ]; then
	BOOTUP=serial
	MOVE_TO_COL=
	SETCOLOR_SUCCESS=
	SETCOLOR_FAILURE=
	SETCOLOR_WARNING=
	SETCOLOR_NORMAL=
fi

log_stderr () {
	echo "Writing to /var/log/${NAME}.log for $0" > /var/log/${NAME}.log
	LOG=/var/log/$(basename $0).log
	exec 2>> $LOG 2>&1
}

# Check if $pid (could be plural) are running with
# the same root as this script
inmyroot() {
	local i r

	for i in $* ; do
		[ "/proc/$i/root" -ef "/proc/$$/root" ] && r="$r $i"
	done
	echo "$r"
}

# Check if any of $pid (could be plural) are running
checkpid() {
	local i

	for i in $* ; do
		[ -d "/proc/$i" ] && return 0
	done
	return 1
}

killproc() { # kill the named process(es)
	pid=`pidofproc $1` && kill $pid
}

pidofproc () {

	# pidof output null when no program is running, so no "2>/dev/null".
	pid=`pidof $1`
	status=$?
	case $status in
	0)
		echo $pid
		return 0
		;;
	127)
		echo "ERROR: command pidof not found" >&2
		exit 127
		;;
	*)
		return $status
		;;
	esac
}

gprintf() {
	local TEXT=$1
	[ "${1#*\\n}" ] || TEXT="$TEXT\n"

	shift
	printf -- "$TEXT" "$@"
}	

# Frontend to gprintf (support up to 4 %s in format string)
# returns the message transleted in GPRINTF_MSG and
# the resting parms in GPRINTF_REST
# This simplifies a lot the call of functions like action,
# now with i18n support
gprintf_msg_rest() {
case "$1" in
       *%s*%s*%s*%s*)
               GPRINTF_MSG=$(gprintf "$1" "$2" "$3" "$4" "$5")
               shift 5;;
       *%s*%s*%s*)
               GPRINTF_MSG=$(gprintf "$1" "$2" "$3" "$4")
               shift 4;;
       *%s*%s*)
               GPRINTF_MSG=$(gprintf "$1" "$2" "$3")
               shift 3;;
       *%s*)
               GPRINTF_MSG=$(gprintf "$1" "$2")
               shift 2;;
       *)
               GPRINTF_MSG=$(gprintf "$1")
               shift;;
esac
GPRINTF_REST="$@"
}

echo_success() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_SUCCESS
  gprintf "  OK  "
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  echo -ne "\r"
  return 0
}

echo_failure() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
  gprintf "FAILED"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  echo -ne "\r"
  return 1
}

echo_passed() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
  gprintf "PASSED"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  echo -ne "\r"
  return 1
}

echo_warning() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
  gprintf "WARNING"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  echo -ne "\r"
  return 1
}



# Log that something succeeded
success() {
  gprintf_msg_rest "$@"
  #if [ -z "${IN_INITLOG:-}" ]; then
  #   initlog $INITLOG_ARGS -n $0 -s "$GPRINTF_MSG" -e 1
  #fi
  [ "$BOOTUP" != "verbose" -a -z "${LSB:-}" ] && echo_success
  return 0
}

# Log that something failed
failure() {
  local rc=$?
  gprintf_msg_rest "$@"
  #if [ -z "${IN_INITLOG:-}" ]; then
  #   initlog $INITLOG_ARGS -n $0 -s "$GPRINTF_MSG" -e 2
  #fi
  [ "$BOOTUP" != "verbose" -a -z "${LSB:-}" ] && echo_failure
  return $rc
}

# Log that something passed, but may have had errors. Useful for fsck
passed() {
  local rc=$?
  gprintf_msg_rest "$@"
  #if [ -z "${IN_INITLOG:-}" ]; then
  #   initlog $INITLOG_ARGS -n $0 -s "$GPRINTF_MSG" -e 1
  #fi
  [ "$BOOTUP" != "verbose" -a -z "${LSB:-}" ] && echo_passed
  return $rc
}  

# Log a warning
warning() {
  local rc=$?
  gprintf_msg_rest "$@"
  #if [ -z "${IN_INITLOG:-}" ]; then
  #   initlog $INITLOG_ARGS -n $0 -s "$1" -e 1
  #fi
  [ "$BOOTUP" != "verbose" -a -z "${LSB:-}" ] && echo_warning
  return $rc
}  

# Run some action. Log its output.
action() {
  local rc
  gprintf_msg_rest "$@"
  echo -n "$GPRINTF_MSG "

  $GPRINTF_REST && success "$GPRINTF_MSG" || failure "$GPRINTF_MSG"
  rc=$?
  echo
  return $rc
}

# returns OK if $1 contains $2
strstr() {
  [ "${1#*$2*}" = "$1" ] && return 1
  return 0
}


# Confirm whether we really want to run this service
confirm() {
  gprintf "Start service %s (Y)es/(N)o/(C)ontinue? [Y] \n" $1
  local YES=`gprintf "yY"`
  local NOT=`gprintf "nN"`
  local CNT=`gprintf "cC"`
  read answer

  if strstr "$YES" "$answer" || [ "$answer" = "" ] ; then
    return 0
  elif strstr "$CNT" "$answer" ; then
    return 2
  elif strstr "$NOT" "$answer" ; then
    return 1
  fi
  confirm $*
}

# resolve a device node to its major:minor numbers in decimal or hex
get_numeric_dev() {
(
    fmt="%d:%d"
    if [ "$1" = "hex" ]; then
        fmt="%x:%x"
    fi
    ls -lH "$2" | awk '{ sub(/,/, "", $5); printf("'"$fmt"'", $5, $6); }'
) 2>/dev/null
}

# Evaluate shvar-style booleans
is_true() {
    case "$1" in
	[tT] | [yY] | [yY][eE][sS] | [tT][rR][uU][eE])
	return 0
	;;
    esac
    return 1
}

# Evaluate shvar-style booleans
is_false() {
    case "$1" in
	[fF] | [nN] | [nN][oO] | [fF][aA][lL][sS][eE])
	return 0
	;;
    esac
    return 1
}

key_is_random() {
    [ "$1" = "/dev/urandom" -o "$1" = "/dev/hw_random" \
	-o "$1" = "/dev/random" ]
}

getarg() {
    local _var _args _o _val _doecho
    unset _var
    unset _args
    unset _val
    unset _o
    unset _doecho
   
    _var="$1"
    shift
    _args=$@

    for _o in $_args; do
        if [ "${_o%%=*}" = "${_var%%=*}" ]; then
            if [ -n "${_var#*=}" -a "${_var#*=*}" != "${_var}" ]; then
                # if $1 has a "=<value>", we want the exact match
                if [ "$_o" = "$_var" ]; then
                    _val="1";
                    unset _doecho
                fi
                continue
            fi

            if [ "${_o#*=}" = "$_o" ]; then
                # if argument has no "=<value>", we assume "=1"
                _val="1";
                unset _doecho
                continue
            fi

            _val=${_o#*=};
            _doecho=1
        fi
    done
    if [ -n "$_val" ]; then
        [ "x$_doecho" != "x" ] && echo "$_val";
        return 0;
    fi
    return 1;
}
