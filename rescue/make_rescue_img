#!/usr/bin/perl

use MDK::Common;
use lib "../perl-install";
use keyboard;

$lib = (arch() =~ /x86_64/ ? "lib64" : "lib");
$tmp = "/tmp/rescue_tmp";
$mnt = "/tmp/rescue_stage2_img";
$mke2fs = "/sbin/mke2fs -q -m 0 -F -s 1";
$rescue = "rescue_stage2";

if ($>) {
    $sudo = "sudo";
    $ENV{PATH} = "/sbin:/usr/sbin:$ENV{PATH}";
}

BEGIN { undef *_; }
sub __ { print @_, "\n"; system(@_); }
sub _ { __ @_; $? and die; }

sub install_raw {
    s|^/|| foreach @_;
    _ "tar c -C / @_ | tar x -C $tmp" if @_;
}
sub install_deref {
    s|^/|| foreach @_;
    _ "tar c -C / --dereference @_ | tar x -C $tmp" if @_;
}

sub install_l {
    my @l = @_;

    @l = uniq(map { chomp_($_) } @l);
    push @l, 
      `ldd @l 2>/dev/null | grep "=>" | perl -pe 's/.*=> //; s/ .*//; s,^/lib/.*?/,/lib/,'`;

    my ($deref, $raw) = partition { /lib.*\.so/ || readlink("/$_") =~ m|/etc/alternatives| } uniq(map { chomp_($_) } @l);
    install_raw(@$raw);
    install_deref(@$deref);
}

sub installown($$) {
    my ($own, $dir) = @_;
    return if -e "$tmp$dir$own";
    mkdir_p("$tmp$dir");
    _ "cp -a $own $tmp$dir";
}

_ "$sudo rm -rf $tmp" if -e $tmp;
_ "mkdir $tmp";
_ 'find . -name "*~" | xargs rm -f';
foreach (cat_("dirs")) {
    chomp;
    mkdir_p("$tmp$_");
}
_ "cp -a tree/* $tmp";
_ "find $tmp -name 'CVS*' | xargs rm -rf";
_ "perl devices.pl $tmp/dev";

install_raw(keyboard::loadkeys_files());
my %keytable_conflicts;
my @less_important_keytables = qw(am_old am_phonetic no-dvorak fr_CH-latin1);
foreach (keyboard::loadkeys_files()) {
    my ($dir, $fname) = (dirname($_), basename($_));
    my ($name) = $fname =~ /(.*)\.kmap\.gz/ or next;
    next if member($name, @less_important_keytables);
    if (my ($short) = $name =~ m|(.+?)[\W_]|) {
	$keytable_conflicts{$short} and warn("conflict between $keytable_conflicts{$short} and $name for short name $short (choosing the first)\n"), next;
	$keytable_conflicts{$short} = $name;
	# create the short name based on the long one
	symlinkf($fname, "$tmp$dir/$short.kmap.gz");
    }
}

my $perl_version = join ".", unpack "C3", $^V;
my @bad;
@files = map { 
    chomp;
    s/PERL_VERSION/$perl_version/g;
    s|/LIB/|/$lib/|g;
    my @l = glob($_) or push @bad, $_;
    m|\*.*/| && @l != 1 and die "multiple match for $_\n";
    @l;
} (cat_("list"), cat_(`../tools/specific_arch list`));
@bad and die "files missing\n" . join("\n", @bad) . "\n";
install_l(@files);

foreach (cat_("aliases")) {
    chomp; my ($f, $dest) = split;
    symlink $dest, "$tmp$f";
}

-e "../kernel/all.modules" or die "use ./update_kernel in gi/kernel first\n";

chomp($main = `cat ../kernel/all.kernels/.main`);

_ "cp ../kernel/all.modules/modules.cz-$main $tmp/modules/modules.cz";
_ "cp ../kernel/all.modules/$main/modules.dep $tmp/modules";

installown("drvinst", "/usr/bin");
installown("guessmounts", "/usr/bin");
installown("install_bootloader", "/usr/bin");
if (arch() =~ /^i.86/) {
    installown("restore_ms_boot", "/usr/bin");
}
installown("lsparts", "/usr/bin");
installown("rescue-doc", "/usr/bin");
_ "cd ../mdk-stage1 && make rescue-gui";
installown("../mdk-stage1/rescue-gui", "/usr/bin");

#- note that on biarch systems, we may need to have both /lib and /lib64
__ "strip $tmp/{lib,$lib,bin,sbin}/* $tmp/usr/{bin,sbin}/* 2>/dev/null";

exit 0 if $ARGV[0];

if (arch() =~ /ppc/) {
    #- xfs module on PPC is 4MB! - need room to unpack it
    $size = `du -s $tmp | cut -f1` + 4096; #- add 4MB of free space
} else {
    $size = `du -s $tmp | cut -f1` + 2048; #- add 2MB of free space
}

mkdir_p($mnt);
__ "$sudo umount $rescue 2>/dev/null";

_ "dd if=/dev/zero of=$rescue bs=1k count=$size";
_ "$mke2fs $rescue";
_ "$sudo mount -t ext2 $rescue $mnt -o loop";
_ "rmdir $mnt/lost+found";

_ "$sudo chown -R root.root $tmp";
_ "$sudo cp -a $tmp/* $mnt";
_ "$sudo rm -rf $tmp";

_ "$sudo umount $rescue";
_ "rmdir $mnt";

_ "bzip2 -f -9 $rescue";
