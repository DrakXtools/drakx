#!/usr/bin/perl

use MDK::Common;
use lib "/usr/lib/libDrakX";
use keyboard;

my $tmp = "/tmp/rescue_tmp";
my $rescue = "rescue.sqfs";

if ($>) {
    $ENV{PATH} = "/sbin:/usr/sbin:$ENV{PATH}";
}

BEGIN { undef *_ }
sub __ { print @_, "\n"; system(@_) }
sub _ { __ @_; $? and die }

_ "rm -rf $tmp" if -e $tmp;
_ "mkdir $tmp";
_ 'find . -name "*~" | xargs rm -f';
mkdir_p($tmp . chomp_($_)) foreach cat_("dirs");
_ "cp -a tree/* $tmp";
_ "find $tmp -name .svn | xargs rm -rf";
_ "perl devices.pl $tmp/dev";
_ "mkfifo $tmp/dev/initctl";
substInFile { s/DISTRIB_DESCR/$ENV{DISTRIB_DESCR}/ } "$tmp/etc/issue";

_ "../tools/install-xml-file-list list.xml $tmp";

my %keytable_conflicts;
my @less_important_keytables = qw(am_old am_phonetic no-dvorak de-latin1);
foreach (keyboard::loadkeys_files()) {
    my ($dir, $fname) = (dirname($_), basename($_));
    my ($name) = $fname =~ /(.*)\.map\.gz/ or next;
    next if member($name, @less_important_keytables);
    if (my ($short2, $short) = $name =~ m|((.+?)[\W_][^\W_]*)|) {
	$keytable_conflicts{$short} && $short2 ne $name and $short = $short2;
	$keytable_conflicts{$short} and warn("conflict between $keytable_conflicts{$short} and $name for short name $short (choosing the first)\n"), next;
	$keytable_conflicts{$short} = $name;
	# create the short name based on the long one
	symlinkf($fname, "$tmp$dir/$short.map.gz");
    }
}

foreach (cat_("aliases")) {
    chomp; my ($f, $dest) = split;
    symlink $dest, "$tmp$f";
}


if (my ($LANGUAGE) = map { if_(/LANGUAGE_(.*)/, $1) } keys %ENV) {
    substInFile {
	$_ = "export LANGUAGE=$LANGUAGE\n" . "export LC_ALL=$LANGUAGE\n" if /^#LANGUAGE/;	
    } "$tmp/etc/rc.sysinit";
}

exit 0 if $ARGV[0];

_ "mksquashfs $tmp $rescue -all-root -noappend >/dev/null || mksquashfs3 $tmp $rescue -all-root -noappend >/dev/null";
_ "chmod 755 $rescue";
_ "rm -rf $tmp";
